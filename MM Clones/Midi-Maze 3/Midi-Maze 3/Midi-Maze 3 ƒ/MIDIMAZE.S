master_flag     EQU 1           ;0= Slave only-Versionshareware       EQU 1           ;0= Shareware-Version, 1= Vollversionhacker_date     EQU $1596       ;Anti-Hacker-Datum: 22.12.90no_protect      EQU 1           ;1= keine Schutzabfragedefault_players EQU 16          ;Anzahl der Spieler bei SOLOshort_timeout   EQU 200         ;1sek Timeoutlong_timeout    EQU 60*200      ;60sek Timeoutt_anz           EQU 16          ;max.Anzahl der Teams (normal: 4)max_elements    EQU 100         ;maximale Anzahl gleichzeitig sichtbarer Objekte (100 ist normal)max_objects     EQU 1000        ;maximale Anzahl von Objekten                OPT F+,O+,W+                ENDPARTheight          EQU 100         ;100 ist normalwidth           EQU 160         ;160 ist normal                TEXT                PART 'startup'                IF no_protect=0                bra     startup                OPT W-                REPT 137                DC.W ^^RANDOM&$FFFF                ENDRserial:         DC.W $AFFE                REPT 118                DC.W ^^RANDOM&$FFFF                ENDR                OPT W+                ENDCstartup:        movea.l 4(SP),A1                movea.w #$0100+4096,A0  ;+ 4K Stack                adda.l  12(A1),A0                adda.l  20(A1),A0                adda.l  28(A1),A0                move.l  A0,D0                add.l   A1,D0                addq.l  #1,D0                and.b   #-2,D0                movea.l D0,SP           ;eigener Stack                move.l  A0,-(SP)                move.l  A1,-(SP)                move.l  #$4A0000,-(SP)                trap    #1              ;Mshrink()                lea     12(SP),SP                clr.w   -(SP)                move.w  #4206,-(SP)                trap    #14             ;Oscanswitch(normalMode)                addq.l  #4,SP                linea   #10 [ Hidem ]                move.l  #short_timeout,timeout ;kurzer Timeout                sf      maus_or_joy     ;Joystick an                move.l  #$0E0000,-(SP)                trap    #14             ;Iorec()                addq.l  #4,SP                movea.l D0,A0                lea     save_midi,A2                move.l  A0,(A2)+        ;Alle Werte retten                move.l  (A0),(A2)+                move.w  4(A0),(A2)                lea     midi_buffer,A1                move.l  A1,(A0)+        ;Zeiger auf den Buffer                move.w  #8192,(A0)+     ;8k lang                clr.l   (A0)+           ;MIDI-Buffer lšschen                moveq   #'E',D0                bsr     esc_code                clr.l   -(SP)                move.w  #$20,-(SP)                trap    #1                move.l  D0,2(SP)                movem.l $FFFF8240.w,D0-D7 ;Farben zurŸck                movem.l D0-D7,save_colors                lea     _rte(PC),A0                move.l  $14.w,old_vector ;Division durch Null abfangen                move.l  A0,$14.w                ori.b   #8,$0484.w                trap    #1                addq.l  #6,SP                bsr.s   main                moveq   #'E',D0                bsr     esc_code                bsr     exit_joystick                bsr     exit_mouse                clr.l   -(SP)                move.w  #$20,-(SP)                trap    #1                move.l  D0,2(SP)                movem.l save_colors,D0-D7 ;Farben zurŸck                movem.l D0-D7,$FFFF8240.w                move.l  old_vector(PC),$14.w ;Division durch Null auf normal                andi.b  #$F7,$0484.w                trap    #1                addq.l  #6,SP                lea     save_midi,A2                movea.l (A2)+,A0        ;Alle Werte zurŸcksetzen                move.l  (A2)+,(A0)+                move.w  (A2),(A0)                linea   #9 [ Showm ]                clr.w   -(SP)                trap    #1              ;Pterm0()                DC.L 'XBRA'     ;nun auch mit XBRA...                DC.L 'MM_2'old_vector:     DS.L 1_rte:           rte                ENDPART                >PART 'main'    ;nŠchste main()-Funktionmain:           move.w  #4,-(SP)                trap    #14                addq.l  #2,SP                move.w  D0,screen_rez                subq.w  #1,D0                bne.s   main1                lea     wrong_rez,A0                bra     small_alertmain1:          moveq   #width/2,D2                moveq   #height/2,D1                move.w  screen_rez,D0   ;Farbe?                beq.s   main2           ;Ja! =>                moveq   #2,D0                move.w  D0,wand_farb_tab ;WŠnde stets in "Farbe" 2                move.w  D0,wand_farb_tab+2                move.w  #width,D2                move.w  #height,D1main2:          move.w  D2,window_width                move.w  D1,window_height                lsr.w   #2,D2                move.w  D2,word_per_line                move.w  #40*160+40,D1                move.w  #16*160+8,D2                move.w  #157*160+40,D3                tst.w   D0              ;Farbe?                beq.s   main3           ;Ja! =>                move.w  #80*80+20,D1                move.w  #32*80+2,D2                move.w  #314*80+20,D3main3:          move.w  D1,main_wind_off ;Das 3D-Window                move.w  D2,live_wind_off ;Anzahl der Leben (Smily)                move.w  D3,pscore_wind_off ;Die AbschŸsse                bsr     calc_160_tab    ;zwei Rechentabelle anlegen                bsr     calc_80_tab                bsr     init_screen                bsr     load_datas                bsr     init_shapes                bsr     init_some_shp                bsr     init_live_shape                bsr     init_end_shape                bsr     calc_sin_table                bsr     init_richtung                moveq   #15,D0                lea     score_table,A0                lea     akt_score,A1main4:          clr.w   (A0)+                move.w  #-1,(A1)+                dbra    D0,main4                moveq   #'b',D0                bsr     esc_code                moveq   #1,D0                bsr     con_out                moveq   #'c',D0                bsr     esc_code                moveq   #0,D0                bsr     con_out                IF master_flag                move.w  #10,reload_time                move.w  #100,refresh_time                move.w  #50,regen_time                move.w  #3,revive_lives                clr.w   team_flag       ;keine Teams                moveq   #15,D0          ;Daten aller Spieler initialisieren                lea     player_data,A1main5:          move.w  reload_time,ply_reload_t(A1)                move.w  refresh_time,ply_refresh_t(A1)                move.w  regen_time,ply_regen_t(A1)                move.w  revive_lives,ply_revive_live(A1)                move.w  #100,ply_winscore(A1) ;nštiger Score zum Gewinn                clr.w   ply_team(A1)                clr.w   ply_swioffset(A1)                clr.w   ply_swcinit(A1)                clr.l   ply_features_b(A1) ;kaufbare Features setzen                lea     ply_name(A1),A0                lea     default_name,A2 ;"Player ##"main6:          move.b  (A2)+,(A0)+     ;Defaultname                bne.s   main6           ;weiter geht's                lea     ply_size(A1),A1                dbra    D0,main5                ENDC                move.w  #1,all_players                bsr.s   dispatch                bra     switch_org_scr                ENDPART                >PART 'dispatch' ;Dispatcher fŸr alle Funktionendispatch:       bsr     play_tmusic     ;Titelmusik laden & spielendispatch0:      IF master_flag                bsr     clr_midi                moveq   #0,D0                bsr     send_midi       ;Nullbyte senden                move.w  D0,own_number                beq.s   dispatch13      ;MASTER =>                ENDC                moveq   #1,D0           ;SLAVE                bra.s   dispatch13cmd_solo:       IF master_flag                move.w  D1,-(SP)                bsr     master_loop     ;MASTER/SOLO                bra.s   cmd_slave1                ENDCcmd_slave:      move.w  D1,-(SP)                bsr     slave_subroutine ;MIDICAM/SLAVEcmd_slave1:     addq.l  #2,SPdispatch13:     bsr     redraw_desktop                tst.w   D0              ;Programmende?                bmi.s   dispatch12      ;dann raus =>                cmp.w   #5,D0                bhi.s   dispatch12      ;Wert zu gro§ => raus =>                add.w   D0,D0                add.w   D0,D0                move.w  dispatch_table+2(PC,D0.w),D1 ;†bergabewert                move.w  dispatch_table(PC,D0.w),D0                jmp     dispatch_table(PC,D0.w) ;Funktion anspringendispatch12:     rts                BASE DC.W,dispatch_tabledispatch_table: DC.W cmd_solo,0                DC.W cmd_slave,0                DC.W cmd_solo,1                DC.W dispatch0,0                DC.W cmd_slave,0                ENDPART                >PART 'load_datas' ;Smily-Daten laden und Datei schlie§enload_datas:     lea     load_buffer1,A4 ;Smily-Daten laden                movea.l lzs_pnt,A5                bsr     DecodeLarc                move.l  #load_buffer1,sinus_table                move.l  #shape_face_data,shape_face_ptr                move.l  #shape_img,shape_ptr                rts                ENDPART                >PART 'init_some_shp'init_some_shp:  lea     crossedsmil_img,A0                moveq   #15,D3init_some_shp1: move.l  (A0),D1                moveq   #0,D2                moveq   #17,D0init_some_shp2: addx.l  D1,D1           ;die obersten 18 Bit umdrehen                roxr.l  #1,D2                dbra    D0,init_some_shp2                move.l  D2,(A0)+                dbra    D3,init_some_shp1                move.l  #crossedsmil_img,crossedsmil_ptr                move.l  #mapsmily_img,mapsmily_ptr                move.l  #mapsmily2_img,mapsmily2_ptr                tst.w   screen_rez      ;Farbe?                beq.s   init_some_shp3  ;Ja! =>                moveq   #30,D0                movea.l crossedsmil_ptr,A0                bsr     convert_sw                moveq   #5,D0                movea.l mapsmily_ptr,A0                bsr     convert_sw                moveq   #5,D0                movea.l mapsmily2_ptr,A0                bsr     convert_swinit_some_shp3: rts                ENDPART                >PART 'init_end_shape'init_end_shape: move.l  #loosershape_img,loosershape_ptr                move.l  #blinzshape_img,blinzshape_ptr                tst.w   screen_rez      ;Farbe?                beq.s   init_end_shape1 ;Ja! =>                moveq   #18,D0                movea.l loosershape_ptr,A0                bsr     convert_sw                moveq   #6,D0                movea.l blinzshape_ptr,A0                bsr     convert_swinit_end_shape1:rts                ENDPART                >PART 'init_live_shape'init_live_shape:move.l  #live_shape_img,live_shape_ptr                tst.w   screen_rez      ;Farbe?                beq.s   init_live_shape1 ;Ja! =>                move.l  #200,D0         ;Anzahl der Langworte                movea.l live_shape_ptr,A0                bsr     convert_swinit_live_shape1:rts                ENDPART                >PART 'init_shapes'init_shapes:    link    A6,#-28                clr.w   D0                move.w  D0,-16(A6)                move.w  D0,-14(A6)                move.w  D0,-12(A6)                clr.w   -4(A6)init_shapes1:   moveq   #24,D0                sub.w   -4(A6),D0                move.w  D0,-20(A6)                cmp.w   #16,D0                ble.s   init_shapes2                move.w  -20(A6),D0                sub.w   #16,D0                add.w   D0,D0                add.w   #16,D0                move.w  D0,-20(A6)init_shapes2:   move.w  -20(A6),D0                muls    #40,D0                ext.l   D0                divs    #12,D0                addq.w  #1,D0                asr.w   #1,D0                movea.w -4(A6),A1                adda.l  A1,A1                adda.l  #set_shape_tab4,A1                move.w  D0,(A1)                move.w  -20(A6),D0                subq.w  #1,D0                asr.w   #3,D0                addq.w  #1,D0                move.w  D0,-18(A6)                movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab4,D1                move.w  0(A0,D1.l),D0                asr.w   #2,D0                movea.w -4(A6),A1                adda.l  A1,A1                adda.l  #set_shape_tab1,A1                move.w  D0,(A1)                bne.s   init_shapes3                movea.w -4(A6),A0                adda.l  A0,A0                adda.l  #set_shape_tab1,A0                move.w  #1,(A0)init_shapes3:   movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab1,D1                move.w  0(A0,D1.l),D0                subq.w  #1,D0                move.w  D0,-22(A6)                bne.s   init_shapes4                move.w  #1,-22(A6)init_shapes4:   movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab1,D1                move.w  0(A0,D1.l),D0                asr.w   #1,D0                move.w  D0,-24(A6)                clr.w   -6(A6)                bra     init_shapes10init_shapes5:   movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab4,D1                move.w  0(A0,D1.l),D0                move.w  -6(A6),D1                sub.w   -24(A6),D1                movea.w -4(A6),A2                adda.l  A2,A2                adda.l  #set_shape_tab4,A2                move.w  (A2),D2                subq.w  #1,D2                muls    D2,D1                add.w   D1,D1                ext.l   D1                divs    -22(A6),D1                add.w   D1,D0                subq.w  #1,D0                asr.w   #1,D0                move.w  D0,-8(A6)                clr.w   -10(A6)                bra.s   init_shapes9init_shapes6:   tst.w   -8(A6)                blt.s   init_shapes7                movea.l shape_face_ptr,A0                move.w  -8(A6),D1                muls    -18(A6),D1                add.w   -12(A6),D1                add.w   -10(A6),D1                ext.l   D1                add.l   D1,D1                move.w  0(A0,D1.l),D0                bra.s   init_shapes8init_shapes7:   clr.w   D0init_shapes8:   move.w  -6(A6),D1                muls    -18(A6),D1                add.w   -16(A6),D1                add.w   -10(A6),D1                movea.w D1,A1                adda.l  A1,A1                adda.l  #set_shape_tab3,A1                move.w  D0,(A1)                addq.w  #1,-10(A6)init_shapes9:   move.w  -10(A6),D0                cmp.w   -18(A6),D0                blt.s   init_shapes6                addq.w  #1,-6(A6)init_shapes10:  movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab1,D1                move.w  0(A0,D1.l),D0                cmp.w   -6(A6),D0                bgt     init_shapes5                movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab4,D1                move.w  0(A0,D1.l),D0                muls    -18(A6),D0                add.w   -12(A6),D0                movea.w -4(A6),A1                adda.l  A1,A1                adda.l  #set_shape_tab5,A1                move.w  D0,(A1)                move.w  D0,-12(A6)                movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab1,D1                move.w  0(A0,D1.l),D0                muls    -18(A6),D0                add.w   -16(A6),D0                movea.w -4(A6),A1                adda.l  A1,A1                adda.l  #set_shape_tab2,A1                move.w  D0,(A1)                move.w  D0,-16(A6)                movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab4,D1                move.w  0(A0,D1.l),D0                muls    -18(A6),D0                add.w   -14(A6),D0                ext.l   D0                movea.w -4(A6),A1                adda.l  A1,A1                adda.l  A1,A1                adda.l  #set_shape_tab6,A1                move.l  D0,(A1)                movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab4,D1                move.w  0(A0,D1.l),D0                muls    -18(A6),D0                muls    #20,D0                add.w   D0,-14(A6)                addq.w  #1,-4(A6)                cmpi.w  #24,-4(A6)                blt     init_shapes1                tst.w   screen_rez      ;Farbe?                beq     init_shapes16   ;Ja! =>                moveq   #0,D1init_shapes12:  lea     set_shape_tab2,A0                asl.w   0(A0,D1.w)                lea     set_shape_tab5,A0                asl.w   0(A0,D1.w)                lea     set_shape_tab6,A0                adda.w  D1,A0                adda.w  D1,A0                move.l  (A0),D0                add.l   D0,D0                move.l  D0,(A0)                addq.w  #2,D1                cmp.w   #48,D1                blt.s   init_shapes12                lea     convert_table,A0                move.w  #255,D0                moveq   #0,D2init_shapes13:  moveq   #0,D1                move.w  #$C000,D4                moveq   #7,D3init_shapes14:  btst    D3,D2           ;Umrechnungstabelle von Farbe => s/w                beq.s   init_shapes15   ;errechnen                or.w    D4,D1init_shapes15:  lsr.w   #2,D4                dbra    D3,init_shapes14                move.w  D1,(A0)+                addq.w  #1,D2                dbra    D0,init_shapes13                move.l  #376,D0                lea     set_shape_tab3,A0                bsr.s   convert_sw                move.l  #33306,D0                movea.l shape_face_ptr,A0                bsr.s   convert_sw                movea.l shape_face_ptr,A0                lea     6344(A0),A0                move.l  A0,shape_ptrinit_shapes16:  unlk    A6                rts                ENDPART                >PART 'convert_sw' ;D0 Farblangworte ab A0 nach SW konvertierenconvert_sw:     add.l   D0,D0           ;Anzahl der Langworte                lea     0(A0,D0.l),A1                adda.l  D0,A0                adda.l  D0,A0           ;Zeiger auf das Farbwort                lea     convert_table,A2convert_sw1:    moveq   #0,D1                move.b  -(A1),D1                add.w   D1,D1                move.w  0(A2,D1.w),-(A0)                subq.l  #1,D0                bne.s   convert_sw1                rts                ENDPART                >PART 'init_screen' ;Bildschirmseiten init, Hintergrundbild ladeninit_screen:    move.w  main_wind_off,D0                bsr     set_screen_offs                clr.w   screen_flag                move.l  #screen_buffer+255,D0                clr.b   D0                move.l  D0,screen_1                move.w  #2,-(SP)                trap    #14             ;Physbase()                addq.l  #2,SP                move.l  D0,screen_2                pea     color_palette(PC)                move.w  #6,-(SP)                trap    #14             ;Farbpalette setzen                addq.l  #6,SP                lea     shape_img,A4                lea     lzs_file,A5     ;Zeiger auf den Eingabebuffer                bsr.s   DecodeLarc                move.l  A5,lzs_pnt                lea     shape_img,A3                lea     save_page,A0    ;Hier kommt das Bild                move.w  #7999,D0                tst.w   screen_rez      ;Farbe?                bne.s   init_screen3    ;Nein! =>init_screen4:   move.l  (A3)+,(A0)+     ;Farbbild umkopieren                dbra    D0,init_screen4                bra.s   init_screen5init_screen3:   lea     32000(A3),A3    ;als 2.Bild liegt das S/W-Bildinit_screen6:   move.l  (A3)+,D1        ;Bild umkopieren                not.l   D1              ;und dabei invertieren                move.l  D1,(A0)+                dbra    D0,init_screen6init_screen5:   bsr     redraw_desktop                bra     switch_org_scr                ENDPART                >PART 'DecodeLarc' ;Programm dekodierenN               EQU 4096        ;size of ring bufferF               EQU 18          ;upper limit for match_lengthTHRESHOLD       EQU 2           ;encode string into position and length, if match_length is greater than thissave_regs       REG D1-A3DecodeLarc:     movem.l save_regs,-(SP)                lea     text_buf,A3                movea.l A3,A0                bsr     get_byte        ;LŠnge des Headers                move.w  D0,D1DecodeLarc1:    bsr.s   get_byte        ;Header in den Buffer                move.b  D0,(A0)+                dbra    D1,DecodeLarc1                movea.l A3,A0                movep.w 14-1(A3),D4                move.b  13-1(A3),D4                swap    D4                movep.w 12-1(A3),D4                move.b  11-1(A3),D4     ;LŠnge des entpackten Programms                move.w  #N-F-1,D0                moveq   #' ',D1DecodeLarc6:    move.b  D1,0(A3,D0.w)   ;Ring-Buffer initialisieren                dbra    D0,DecodeLarc6                moveq   #0,D7           ;keine Bits gelesen                move.w  #N-F,D5         ;BufferpointerDecodeLarc7:    dbra    D7,DecodeLarc8  ;noch Bits im Register? Nein =>                bsr.s   get_byte        ;Bitmaske holen                move.b  D0,D6                moveq   #7,D7           ;8 Bits gelesenDecodeLarc8:    lsr.b   #1,D6           ;Byte Ÿbertragen oder Block kopieren?                bcc.s   DecodeLarc9     ;Block kopieren =>                bsr.s   get_byte                move.b  D0,0(A3,D5.w)   ;in den Ring-Buffer                bsr.s   put_byte        ;und schreiben                addq.w  #1,D5           ;Buffer-Pointer erhšhen                and.w   #N-1,D5                bra.s   DecodeLarc7     ;nŠchstes ByteDecodeLarc9:    bsr.s   get_byte                moveq   #0,D2                move.b  D0,D2           ;lower-Byte des Offsets                bsr.s   get_byte                moveq   #$0F,D1                and.b   D0,D1           ;Anzahl der Bytes                eor.b   D1,D0                addq.w  #THRESHOLD,D1   ;+ minimale Byteanzahl                lsl.w   #4,D0                or.w    D0,D2DecodeLarc10:   move.b  0(A3,D2.w),D0   ;Byte aus dem Ringbuffer holen                move.b  D0,0(A3,D5.w)   ;und hinten an den Ringbuffer ranhŠngen                bsr.s   put_byte        ;Byte auch schreiben                addq.w  #1,D5                and.w   #$0FFF,D5       ;aktuellen Buffer-Pointer erhšhen                addq.w  #1,D2                and.w   #$0FFF,D2       ;Lesepointer auch erhšhen                dbra    D1,DecodeLarc10 ;schon alle Bytes kopiert? Nein! =>                bra.s   DecodeLarc7     ;das nŠchste Byte                ENDPART                >PART 'get_byte'get_byte:       moveq   #0,D0           ;oberes Byte lšschen!                move.b  (A5)+,D0                rts                ENDPART                >PART 'put_byte' ;Byte in D0 in den Write-Buffer, ggf. CRCput_byte:       move.b  D0,(A4)+        ;Zeichen in den Buffer                subq.l  #1,D4           ;Anzahl der entpackten Bytes erniedriegen                bls.s   put_byte1       ;alle Bytes entpackt => raus                rtsput_byte1:      clr.b   (A4)            ;Buffer mit Nullbyte abschlie§en                addq.l  #4,SP           ;RŸcksprungadresse entfernen                movem.l (SP)+,save_regs ;und raus                rts                ENDPART                >PART 'play_game' ;Hier beginnt das Spiel...play_game:      link    A6,#-32                lea     _maze_datas,A0                lea     maze_datas,A1                move.w  #4095,D0play_game1:     move.b  (A0)+,(A1)+     ;Originalmaze wieder zurŸck                dbra    D0,play_game1                lea     _object_datas,A0                lea     object_datas,A1                move.w  #15999,D0play_game2:     move.w  (A0)+,(A1)+     ;Originalmaze wieder zurŸck                dbra    D0,play_game2                clr.l   last_time       ;Extras sofort ausgeben                bsr     redraw_desktop                clr.w   -16(A6)                clr.w   -18(A6)                clr.w   -20(A6)                clr.w   -26(A6)                clr.w   -28(A6)                clr.w   screen_flag                clr.w   hacker_flag     ;0 = sinnvoller Wert (nicht fŸr Hacker...)                bsr     switch_logbase  ;auf die andere Grafikseite                moveq   #15,D1play_game3:     move.w  #-1,-(SP)       ;Score auf Null zŠhlen                move.w  D1,-(SP)                bsr     update_score                addq.l  #4,SP                dbra    D1,play_game3                move.w  machines_online,all_players                moveq   #0,D2play_game9:     move.w  D2,D3                add.w   D3,D3           ;D3 = 2*D2                moveq   #3,D0                add.w   D2,D0                tst.w   screen_rez      ;Farbe?                bne.s   play_game110    ;Nein! =>                lea     color_ply_back(PC),A0                move.w  0(A0,D3.w),D0play_game110:   lea     color_cnv_back,A0                move.w  D0,0(A0,D3.w)                moveq   #0,D0                tst.w   screen_rez      ;Farbe?                bne.s   play_game130    ;Nein! =>                lea     color_ply_frame(PC),A0                move.w  0(A0,D3.w),D0play_game130:   lea     color_cnv_frame,A0                move.w  D0,0(A0,D3.w)                addq.w  #1,D2                cmp.w   all_players,D2                blo.s   play_game9                tst.w   team_flag       ;Teams?                beq.s   play_game26     ;Nein! =>                moveq   #0,D2play_game24:    move.w  D2,D1                add.w   D1,D1           ;Zeiger auf die Teamfarben                move.w  D2,D0                mulu    #ply_size,D0                lea     player_data,A0                move.w  ply_team(A0,D0.w),D0 ;die Teamnummer des Spielers holen                tst.w   screen_rez      ;Farbe?                bne.s   play_game6      ;Nein! =>                lea     color_ply_back(PC),A0                add.w   D0,D0           ;mal 2 (da Wortzeiger)                move.w  0(A0,D0.w),D0                bra.s   play_game7play_game6:     addq.w  #3,D0play_game7:     lea     color_cnv_back,A0                move.w  D0,0(A0,D1.w);                moveq   #0,D0;                tst.w   screen_rez      ;Farbe?;                bne.s   play_game1300   ;Nein! =>;                lea     color_ply_frame(PC),A0;                move.w  0(A0,D1.w),D0;play_game1300:  lea     color_cnv_frame,A0;                move.w  D0,0(A0,D1.w)                lea     color_cnv_frame,A0                clr.w   0(A0,D1.w)                addq.w  #1,D2                cmp.w   all_players,D2                blo.s   play_game24play_game26:                IF master_flag                tst.w   own_number      ;Slave?                bne.s   play_game12     ;Ja! =>                tst.w   8(A6)           ;SOLO?                bne.s   play_game11     ;Ja! =>                move.w  #$11,-(SP)      ;Zufallsbasis fŸr den Master setzen                trap    #14             ;Random()                addq.l  #2,SP                move.b  D0,_random_seed                bsr     send_midi                cmp.b   _random_seed,D0                bne     play_game_err                move.w  #$11,-(SP)                trap    #14             ;Random()                addq.l  #2,SP                move.b  D0,_random_seed+1 ;Zufallsbasis setzen                bsr     send_midi                cmp.b   _random_seed+1,D0 ;Zufallsbasis setzen                bne     play_game_err   ;MIDI-Fehler                SWITCH shareware                CASE 0                lea     object_datas,A0                cmpi.w  #hacker_date,last_date-object_datas+4(A0) ;Datum der letzten €nderung (22.12.90)                blo.s   play_game13     ;Maze ist Šlter als vom 22.12.90 (das mu§ so sein!)                move.w  #1,hacker_flag  ;schau, schau ein Hacker...                ENDS                bra.s   play_game13play_game11:    move.w  #$11,-(SP)      ;Zufallsbasis fŸr SOLO-Spieler setzen                trap    #14             ;Random()                addq.l  #2,SP                move.w  D0,_random_seed                bra.s   play_game13                ENDCplay_game12:    bsr     get_midi        ;Zufallsbasis fŸr Slave setzen                bmi     play_game_err                move.b  D0,_random_seed                bsr     send_midi                bmi     play_game_err   ;MIDI-Fehler                bsr     put_midi                move.b  D0,_random_seed+1 ;Zufallsbasis setzenplay_game13:    move.w  all_players,-(SP)                bsr     init_all_player ;Spieler zufŠllig verteilen                addq.l  #2,SP                bne.s   play_game14                moveq   #-3,D0          ;Maze too small                bra     play_game_errplay_game14:    tst.w   team_flag       ;Teamplay?                beq.s   play_game16     ;Nein! =>                moveq   #t_anz-1,D0                lea     team_scores,A0                lea     akt_score,A1play_game15:    clr.w   (A0)+           ;Score der einzelnen Teams lšschen                move.w  #-1,(A1)+                dbra    D0,play_game15play_game16:    bsr     update_smily                move.w  main_wind_off,D0                bsr     set_screen_offs                move.w  all_players,-(SP)                tst.w   team_flag       ;Teams?                beq.s   play_game17     ;Nein! =>                move.w  #t_anz,(SP)play_game17:    bsr     check_score                addq.l  #2,SP                move.w  main_wind_off,D0                bsr     set_screen_offs                moveq   #0,D0                bsr     draw_karte      ;die Karte zeichnen                bsr     switch_logbase                moveq   #0,D0                bsr     draw_karte      ;die Karte zeichnen (andere Seite)                bsr     switch_logbase                moveq   #0,D7play_game18:    move.w  D7,D0                mulu    #ply_size,D0                lea     player_data,A0                adda.w  D0,A0                move.l  ply_features(A0,D0.w),D0                btst    #f_midicam,D0   ;MIDICAM?                bne.s   play_game19     ;Ja! =>                move.w  D7,-(SP)                bsr     set_ply_karte   ;und die Spieler draufsetzen                addq.l  #2,SPplay_game19:    addq.w  #1,D7                cmp.w   all_players,D7                blo.s   play_game18                move.l  #$220007,D2     ;Zeile 7, Spalte 34                moveq   #0,D1                bsr     score3out                addq.w  #2,D2                bsr     score3out       ;alle Anzeigen lšschen                addq.w  #2,D2                bsr     score3out                addq.w  #2,D2                bsr     score3out                move.l  #100*3,D0                bsr     pause           ;3sek Pause, um die Karte zu sehen                tst.b   maus_or_joy     ;Maus?                bne.s   play_game20     ;Ja! =>                bsr     init_joystick                bra.s   play_game21play_game20:    bsr     init_mouseplay_game21:    bsr     clr_con         ;Tastaturbuffer lšschen                ENDPART                >PART 'play_game_loop'play_game_loop: lea     object_datas,A3obj_loop:       addq.l  #2,A3                move.w  (A3)+,D7                beq.s   all_objs        ;Ende der Liste =>                subq.w  #1,(A3)+        ;ZŠhler herabsetzen                bcc.s   next_obj        ;Unterlauf? Nein! =>                movem.l D0-A6,-(SP)                lea     player_data,A0  ;Zeiger auf das Spieler-Array                lea     funk_list(PC),A1 ;Zeiger auf Funktionen                lea     object_datas,A2 ;Zeiger auf den Anfang der Objektliste                move.w  own_number,D0   ;Nummer des Rechners vom Spieler                move.w  #ply_size,D1    ;Grš§e eines Spieler-Eintrags                move.w  all_players,D2  ;Anzahl der Spieler                tst.b   D7                bmi.s   ext_obj                move.w  D7,D3                lsr.w   #8,D3           ;oberes Byte vom Comanndo                and.w   #$FF,D7                subq.w  #1,D7                add.w   D7,D7                move.w  obj_list_fnk(PC,D7.w),D7                jsr     obj_list_fnk(PC,D7.w)more_obj:       movem.l (SP)+,D0-A6next_obj:       subq.l  #6,A3                adda.w  (A3),A3         ;zum nŠchsten Objekt                bra.s   obj_loopext_obj:        illegal                 ;externes Objekt                bra.s   more_obj                BASE DC.W,obj_list_fnkobj_list_fnk:   DC.W wand_anim                OPT O-,W-funk_list:      jmp     get_maze_datayx                jmp     put_maze_data                OPT O+,W+wand_anim:      tst.b   4(A3,D3.w)      ;Listenende erreicht?                bpl.s   wand_anim1      ;Nein! =>                moveq   #0,D3           ;Offset wieder auf den Anfang zurŸckwand_anim1:     move.w  6(A3,D3.w),-2(A3) ;neue Zeit                move.w  4(A3,D3.w),-(SP) ;neuer Eintrag                move.l  (A3),-(SP)      ;Position im Maze                jsr     6(A1)           ;Objekt ins Maze setzen                addq.l  #6,SP                addq.w  #4,D3           ;einen Eintrag weiter                move.b  D3,-4(A3)       ;neuen Offset merken                rtsall_objs:       ENDPART                >PART           ;Wurde der Spieler angeschossen?                lea     player_data,A0                move.w  own_number,D0                mulu    #ply_size,D0                adda.w  D0,A0                tst.w   ply_hitflag(A0) ;wurde der Spieler angeschossen?                beq     play_game64     ;Nein! =>                move.l  A0,-(SP)                move.w  ply_gunman(A0),D1                bsr     send_name_adr   ;Der beschie§t mich!                bsr     print_line                bsr     switch_logbase                movea.l (SP)+,A0                move.w  ply_gunman(A0),D1                bsr     send_name_adr   ;Der beschie§t mich! (2.Seite)                bsr     print_line                bsr     switch_logbase                pea     sound_2(PC)                move.w  #$20,-(SP)                trap    #14             ;Dosound() - Hit!!!                addq.l  #6,SP                tst.w   screen_rez      ;Farbe?                beq.s   play_game62     ;Ja! =>                move.w  #$25,-(SP)                trap    #14             ;Vsync()                addq.l  #2,SP                move.w  #1,-(SP)                clr.w   -(SP)                move.w  #7,-(SP)                trap    #14             ;Hintergrund wei§                addq.l  #6,SP                move.w  #1,-28(A6)                bra.s   play_game67play_game62:    move.w  own_number,D0                mulu    #ply_size,D0                lea     player_data,A0                adda.w  D0,A0                move.w  ply_gunman(A0),D0                add.w   D0,D0                lea     color_cnv_back,A0                move.w  0(A0,D0.w),D0                add.w   D0,D0                lea     color_palette(PC),A0                move.w  0(A0,D0.w),-(SP)                clr.w   -(SP)                move.w  #7,-(SP)                trap    #14             ;Rahmen in der Farbe des SchŸtzen                addq.l  #6,SP           ;flackern lassen                bra.s   play_game67play_game64:    tst.w   screen_rez      ;Farbe?                beq.s   play_game66     ;Ja! =>                tst.w   -28(A6)                beq.s   play_game67                clr.w   -28(A6)play_game66:    clr.l   -(SP)                move.w  #7,-(SP)                trap    #14             ;Hintergrund wieder normal                addq.l  #6,SP                ENDPART                >PART 'play_game67' ;Ist die Karte angeschaltet?play_game67:    move.w  own_number,D0                lea     player_data,A0                mulu    #ply_size,D0                move.l  ply_features(A0,D0.w),D1                btst    #f_karte_init,D1 ;Karte gekauft                beq.s   play_game74     ;Nein! =>                btst    #f_karte,D1     ;Karte an?                beq.s   play_game74     ;Nein! =>                move.l  D0,-(SP)                move.b  redraw_karte,D0                bsr     draw_karte      ;die Karte zeichnen                sf      redraw_karte                move.l  (SP)+,D0                tst.w   ply_lives(A0,D0.w) ;lebt der Spieler noch?                ble.s   play_game70     ;Nein! => er sieht alle Spieler =>                btst    #f_showplayer,D1 ;Mogeln erlaubt?                bne.s   play_game70     ;Ja! =>                move.w  own_number,-(SP)                bsr     set_ply_karte   ;nur den Spieler setzen                addq.l  #2,SP                bra.s   play_game73play_game70:    moveq   #0,D7           ;mit Spieler 0 geht's los...play_game71:    move.w  D7,D0                mulu    #ply_size,D0                tst.w   ply_lives(A0,D0.w) ;lebt der Spieler noch?                ble.s   play_game72     ;Nein! =>                cmp.w   own_number,D7   ;der eigene Spieler?                beq.s   play_game710    ;ja! => stets zeigen                move.l  ply_features(A0,D0.w),D0                btst    #f_hideplayer,D0 ;besseres Mogeln?                bne.s   play_game72     ;Ja! => Spieler versteckenplay_game710:   move.w  D7,-(SP)                bsr     set_ply_karte   ;sonst den Spieler zeichnen                addq.l  #2,SPplay_game72:    addq.w  #1,D7           ;der nŠchste Spieler                cmp.w   all_players,D7  ;schon alle Spieler?                blo.s   play_game71     ;Nein! =>play_game73:    bsr     switch_screens                bsr     set_all_player  ;Maze von allen Spielerdaten befreien                bra     play_game77                ENDPART                >PART 'play_game74' ;Lebt der Spieler noch?play_game74:    lea     player_data,A0                move.w  own_number,D0                mulu    #ply_size,D0                adda.w  D0,A0                tst.w   ply_lives(A0)   ;Anzahl der Leben<=0?                ble     player_dead     ;Dann "Game Over" =>                ENDPART                >PART           ;Maze zeichnen                move.w  ply_richtung(A0),-(SP)                move.w  ply_x(A0),-(SP)                move.w  ply_y(A0),-(SP)                bsr     make_draw_list  ;Das Maze berechnen                addq.l  #6,SP                bsr     draw_list       ;Das Maze zeichnen                ENDPART                >PART           ;und das Fadenkreuz draufsetzen                lea     player_data,A0                move.w  own_number,D0                mulu    #ply_size,D0                adda.w  D0,A0                tst.w   ply_reload(A0)  ;wird nachgeladen?                bne     play_game77     ;Ja! => kein Fadenkreuz                bsr     switch_logbase                tst.w   screen_rez      ;Farbe?                beq.s   play_game75     ;Ja! =>                clr.w   -(SP)           ;Das Fadenkreuz zeichnen                move.w  #width-2,-(SP)                move.w  #height+1,-(SP)                move.w  #height-1,-(SP)                bsr     dr_sw_vline                addq.l  #8,SP                clr.w   -(SP)                move.w  #width+2,-(SP)                move.w  #height+1,-(SP)                move.w  #height-1,-(SP)                bsr     dr_sw_vline                addq.l  #8,SP                clr.w   -(SP)                move.w  #height-2,-(SP)                move.w  #width+1,-(SP)                move.w  #width-1,-(SP)                bsr     dr_sw_hline                addq.l  #8,SP                clr.w   -(SP)                move.w  #height+2,-(SP)                move.w  #width+1,-(SP)                move.w  #width-1,-(SP)                bsr     dr_sw_hline                addq.l  #8,SP                bra.s   play_game76play_game75:    move.w  own_number,D1   ;Das Fadenkreuz zeichnen                add.w   D1,D1                lea     color_cnv_back,A0                move.w  0(A0,D1.w),D1                move.w  D1,-(SP)        ;Farbe                move.w  #width/2-2,-(SP) ;Y                move.w  #height/2+1,-(SP) ;X2                move.w  #height/2,-(SP) ;X1                bsr     dr_c_cvline                addq.l  #8,SP                move.w  D1,-(SP)                move.w  #width/2,-(SP)                move.w  #height/2+1,-(SP)                move.w  #height/2,-(SP)                bsr     dr_c_cvline                addq.l  #8,SP                move.w  D1,-(SP)                move.w  #width/2-1,-(SP)                move.w  #height/2-1,-(SP)                move.w  #height/2-1,-(SP)                bsr     dr_c_cvline                addq.l  #8,SP                move.w  D1,-(SP)                move.w  #width/2-1,-(SP)                move.w  #height/2+2,-(SP)                move.w  #height/2+2,-(SP)                bsr     dr_c_cvline                addq.l  #8,SPplay_game76:    bsr     switch_logbase                ENDPART                >PART 'play_game77' ;Extras ausgebenplay_game77:    movem.l D0-A6,-(SP)                bsr     get_hz200                cmp.l   last_time,D0    ;Zeit abgelaufen?                blo.s   play_game770    ;Nein! => Extras noch nicht ausgeben                lea     buffer,A0                bsr     f_out                move.l  A0,-(SP)                bsr     print_line                bsr     switch_logbase                movea.l (SP)+,A0                bsr     print_line                bsr     switch_logbaseplay_game770:   movem.l (SP)+,D0-A6                ENDPART                >PART           ;Maus bzw. Joystickabfrage                tst.b   maus_or_joy     ;Maus oder Joystick?                bne.s   play_game84     ;Maus! =>                bsr     ask_joystick    ;Joystick abfragen                bra.s   play_game85play_game84:    bsr     ask_mouse       ;Maus abfragenplay_game85:    move.w  own_number,D1                add.w   D1,D1                lea     player_joy_table,A0                move.w  D0,0(A0,D1.w)                ENDPART                >PART           ;Tastaturabfrage                move.l  #$010002,-(SP)                trap    #13             ;Bconstat(CON)                addq.l  #4,SP                tst.l   D0              ;Taste gedrŸckt?                beq.s   play_game96     ;Nein! =>                move.l  #$020002,-(SP)                trap    #13             ;Bconin(CON)                addq.l  #4,SP                swap    D0              ;den Scancode holen                and.w   #$FF,D0                bset    #7,D0           ;Bit zur Unterscheidung vom Joystick                move.w  own_number,D1                add.w   D1,D1                lea     player_joy_table,A0                move.w  D0,0(A0,D1.w)   ;Taste merken                bsr     clr_con         ;Tastaturbuffer lšschen                ENDPART                >PART           ;Joystickdaten bzw. Tastaturdaten Ÿber MIDI Ÿbertragenplay_game96:    tst.w   8(A6)           ;SOLO?                bne.s   play_game104    ;Ja! =>                move.w  own_number,D1play_game100:   lea     player_joy_table,A0                move.w  D1,D0                add.w   D0,D0                adda.w  D0,A0                move.w  (A0),D0         ;Joystickdatum holen                bsr     put_midi        ;und weitersenden                subq.w  #1,D1                bpl.s   play_game101                move.w  machines_online,D1                subq.w  #1,D1play_game101:   bsr     get_midi        ;Joystick des Vordermannes holen                bmi     play_game_err   ;MIDI-Fehler                lea     player_joy_table,A0                move.w  D1,D2                add.w   D2,D2                adda.w  D2,A0           ;Zeiger auf Joysticktabelle                cmp.w   own_number,D1   ;Ende (= eigener Spieler) erreicht?                beq.s   play_game103    ;Ja! =>                move.w  D0,(A0)         ;Joystickrichtung merken                bra.s   play_game100    ;und weiterplay_game103:   cmp.w   (A0),D0         ;Richtung fehlerfrei Ÿbertragen?                bne     play_game_err   ;Nein! => Fehler                ENDPART                >PART           ;Alle hitflags zurŸcksetzenplay_game104:   moveq   #15,D0                lea     player_data,A0play_game107:   clr.w   ply_hitflag(A0) ;alle hitflags lšschen                lea     ply_size(A0),A0                dbra    D0,play_game107                ENDPART                >PART           ;ABBRUCH durch den Master?                cmpi.w  #$81,player_joy_table ;Abbruch durch den Master?                bne     play_game121    ;Nein =>                clr.l   -(SP)                move.w  #7,-(SP)                trap    #14             ;Hintergrund schwarz                addq.l  #6,SP                tst.w   own_number      ;Nummer 0 = Master?                bne.s   play_game118    ;Nein! =>                bsr     switch_logbase                bsr     exit_joystick                bsr     exit_mouse                lea     suspended(PC),A0 ;Abbrechen?                bsr     small_alert                move.w  D0,-4(A6)                tst.b   maus_or_joy     ;Maus?                bne.s   play_game111    ;Ja! =>                bsr     init_joystick                bra.s   play_game112play_game111:   bsr     init_mouseplay_game112:   bsr     switch_logbase                tst.w   8(A6)           ;SOLO?                beq.s   play_game114    ;Nein! =>                tst.w   -4(A6)          ;Abbruch?                bne.s   play_game120    ;Nein! =>                moveq   #-2,D0          ;Terminated                bra     play_game_err   ;raus =>play_game114:   moveq   #$82,D0         ;Terminated                tst.w   -4(A6)          ;Abbruch?                beq.s   play_game116    ;Ja! =>                moveq   #$84,D0         ;Continueplay_game116:   bsr     send_midi                bmi     play_game_err                bra.s   play_game119play_game118:   bsr     copy_screen     ;Screen retten                lea     suspended_slave(PC),A0                bsr     print_line      ;Game suspended                move.l  #long_timeout*60,timeout ;langer Timeout                bsr     get_midi        ;auf Byte warten                move.l  #short_timeout,timeout ;kurzer Timeout                bsr     put_midi        ;Byte weitersenden                bsr     copy_screen     ;Screen zurŸck                bsr     switch_logbaseplay_game119:   cmpi.w  #$84,D0         ;Continue?                beq.s   play_game120    ;dann weiter                moveq   #-2,D0          ;Terminated                bra     play_game_err   ;sonst: Abbruchplay_game120:   bsr     redraw_small                clr.w   player_joy_table ;Joystick Spieler 0 (Master) lšschen                ENDPART                >PART           ;Spieler -16(A6) bearbeitenplay_game121:   move.w  -16(A6),D4      ;zu bearbeitender Spieler                move.w  D4,D5play_game122:   move.w  D4,D0                add.w   D0,D0                lea     player_joy_table,A0                move.w  0(A0,D0.w),-(SP) ;Joystickrichtungen                move.w  D4,-(SP)        ;Spielernummer                bsr     move_player                addq.l  #4,SP                tst.w   D0                bpl     play_game123                moveq   #-3,D0          ;Maze too small                bra     play_game_err                ENDPART                >PART 'player_dead' ;Der Spieler ist tot!player_dead:    move.w  own_number,D0                mulu    #ply_size,D0                lea     player_data,A0                adda.w  D0,A0                move.w  ply_gunman(A0),D3 ;Farbe/FŸllmuster                tst.w   screen_rez      ;Farbe?                beq.s   player_dead1    ;Ja! =>                move.w  #1,(SP)                move.w  #height*2+1,-(SP)                move.w  #width*2-1,-(SP)                clr.l   -(SP)                bsr     dr_sw_box       ;Hauptwindow lšschen                addq.l  #8,SP                move.w  D3,(SP)         ;Farbe                move.w  #100,-(SP)      ;Spritegrš§e                clr.w   -(SP)           ;Spritenummer                move.w  #64,-(SP)       ;Y                move.w  #96,-(SP)       ;X                bsr     set_shape                addq.l  #8,SP                bra.s   player_dead2player_dead1:   move.w  #7,(SP)                move.w  #height,-(SP)                move.w  #width-1,-(SP)                clr.l   -(SP)                bsr     dr_c_box        ;Hauptwindow lšschen                addq.l  #8,SP                move.w  D3,(SP)         ;Farbe                move.w  #50,-(SP)       ;Spritegrš§e                clr.w   -(SP)           ;Spritenummer                move.w  #32,-(SP)       ;Y                move.w  #48,-(SP)       ;X                bsr     set_shape                addq.l  #8,SPplayer_dead2:   move.w  D3,D1                bsr     send_name_adr                bsr     print_line                bsr     switch_screens                bsr     set_all_player  ;Maze updaten                bra     play_game77                ENDPART                >PART           ;Hat ein Spieler bzw. ein Team gewonnen?play_game123:   bsr     check_winner                bne     game_over                ENDPART                >PART           ;Den nŠchsten Spieler durchrechnen                subq.w  #1,D4                bpl.s   play_game124                move.w  all_players,D4                subq.w  #1,D4play_game124:   cmp.w   D5,D4           ;alle Spieler durch?                bne     play_game122    ;Nein! =>                addq.w  #1,D5           ;beim nŠchsten mal der nŠchste Spieler                cmp.w   all_players,D5  ;schon alle durch?                bne.s   play_game126    ;Nein! =>                moveq   #0,D5           ;dann wieder bei 0 anfangenplay_game126:   move.w  D5,-16(A6)                ENDPART                >PART           ;alle Scoreanzeigen updaten / Extras ausgeben                movem.l D0-A6,-(SP)                move.w  all_players,-(SP)                tst.w   team_flag       ;Teams?                beq.s   play_game69     ;Nein! =>                move.w  #t_anz,(SP)play_game69:    bsr     check_score     ;Die Scorezeile updaten                addq.l  #2,SP                lea     player_data,A0                move.w  own_number,D0                mulu    #ply_size,D0                adda.w  D0,A0                move.l  ply_features(A0),D0                btst    #f_kompass,D0   ;ein Kompass?                beq.s   play_game68     ;Nein! =>                move.l  #$030007,D2     ;Zeile 7, Spalte 3                bsr     set_cursor      ;Cursor setzen                move.w  ply_richtung(A0),D0 ;Die Blichrichtung                lsr.w   #5,D0           ;durch 32                add.w   D0,D0           ;mal 2 (Worttabelle)                move.w  kompass_tab(PC,D0.w),D0                bsr     rawcon_out                lsr.w   #8,D0                bsr     rawcon_out                bra.s   play_game68kompass_tab:    DC.B ' N','EN',' E','ES',' S','WS',' W','WN'play_game68:    move.l  #$030009,D2     ;Zeile 9, Spalte 3                bsr     set_cursor                moveq   #' ',D0                move.l  ply_features(A0),D1                btst    #f_shotwarn,D1  ;Warnung mšglich?                beq.s   play_game68a    ;Nein! =>                tst.w   ply_warnflag(A0) ;Schu§ in der Umgebung?                bmi.s   play_game68a    ;Nein! =>                subq.w  #1,ply_warnflag(A0)                moveq   #'S',D0play_game68a:   bsr     rawcon_out      ;Warnung!                move.w  ply_looser(A0),D7 ;ein Abschu§ zu verbuchen?                bpl.s   play_game78     ;Nein! =>                sf      ply_looser(A0)  ;Flag dafŸr lšschen                move.l  #$220007,D2     ;Zeile 7, Spalte 34                move.w  ply_killscore(A0),D1                bsr     score3out       ;Anzahl der AbschŸsse ausgeben                and.w   #$FF,D7                move.l  A0,-(SP)                move.w  D7,D1                bsr     send_name_adr   ;Den habe ich erlegt!                move.l  A0,-(SP)                bsr     print_line                bsr     switch_logbase                movea.l (SP)+,A0        ;Den habe ich erlegt! (2.Seite)                bsr     print_line                bsr     switch_logbase                movea.l (SP),A0                move.w  D7,-(SP)        ;Nummer des Loosers                move.w  ply_killscore(A0),-(SP)                bsr     add_one_smily   ;und wieder ein Smily mehr                addq.l  #4,SP                movea.l (SP)+,A0play_game78:    move.w  ply_hitscore(A0),D1                cmp.w   ply_shitscore(A0),D1 ;noch nix getroffen?                beq.s   play_game79     ;Ja! => raus                move.w  D1,ply_shitscore(A0)                move.l  #$220009,D2     ;Zeile 9, Spalte 34                bsr     score3out       ;Anzahl der "Hits" ausgeben                bsr.s   update_zahlenplay_game79:    movem.l (SP)+,D0-A6                bra     play_game_loop  ;*** HAUPTSCHLEIFE DURCHLAUFEN ***                ENDPART                >PART 'get_hz200'get_hz200:      movem.l D1-D3/A0-A2,-(SP)                clr.l   -(SP)                move.w  #$20,-(SP)                trap    #1                move.l  D0,2(SP)                move.l  $04BA.w,D3      ;200Hz-Timer auslesen                trap    #1                addq.l  #6,SP                move.l  D3,D0                movem.l (SP)+,D1-D3/A0-A2                rts                ENDPART                >PART 'update_zahlen' ;die neuen Anzeigen updatenupdate_zahlen:  movem.l D0-A6,-(SP)                lea     player_data,A1                move.w  own_number,D0                mulu    #ply_size,D0                adda.w  D0,A1           ;Struktur des eigenen Spielers                cmpa.l  A1,A0           ;ist es der gleiche Spieler?                bne.s   update_zahlen1  ;Nein! =>                move.w  ply_killscore(A0),D1                add.w   D1,D1                add.w   ply_hitscore(A0),D1                move.l  #$22000B,D2     ;Zeile 11, Spalte 34                bsr     score3out       ;Gesamt-Punkteanzahl ausgeben                move.w  ply_score(A0),D1                move.l  #$22000D,D2     ;Zeile 13, Spalte 34                bsr     score3out       ;Punkteanzahl ausgebenupdate_zahlen1: movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'f_out'   ;alle vorhandenen Features in der letzten Zeile ausgebenf_out:          movem.l D0-D3/A0-A1,-(SP)                lea     player_data,A1                move.w  own_number,D0                mulu    #ply_size,D0                adda.w  D0,A1                move.l  ply_features(A1),D1                lea     key_table(PC),A1                moveq   #f_anzahl-1,D3                moveq   #0,D2f_out1:         btst    D2,D1                beq.s   f_out2                move.b  0(A1,D2.w),(A0)+f_out2:         addq.w  #1,D2                dbra    D3,f_out1                clr.b   (A0)                movem.l (SP)+,D0-D3/A0-A1                rts                ENDPART                >PART 'check_winner' ;Hat jemand gewonnen?check_winner:   lea     player_data,A0                move.w  machines_online,D3 ;16 Spieler durchrechnen                subq.w  #1,D3                lea     team_scores,A1                moveq   #t_anz-1,D0check_winner1:  clr.w   (A1)+           ;Die Team-Scores lšschen                dbra    D0,check_winner1                moveq   #ply_score,D2                lea     team_scores,A1                tst.w   team_flag       ;Teams?                bne.s   check_winner3   ;Ja! =>check_winner2:  move.w  0(A0,D2.w),D0   ;Score eines Spielers holen                cmp.w   ply_winscore(A0),D0                lea     ply_size(A0),A0 ;Zeiger auf den nŠchsten Spieler                dbcc    D3,check_winner2                bhs.s   check_winner5   ;Es hat jemand gewonnen! =>                bra.s   check_winner4check_winner3:  move.w  ply_team(A0),D1 ;Teamnummer des Spielers                add.w   D1,D1                move.w  0(A0,D2.w),D0   ;Score des Spielers                add.w   D0,0(A1,D1.w)   ;Teamscore erhšhen                move.w  0(A1,D1.w),D0                cmp.w   ply_winscore(A0),D0 ;Score erreicht?                lea     ply_size(A0),A0 ;Zeiger auf den nŠchsten Spieler                dbcc    D3,check_winner3                bhs.s   check_winner5   ;Es hat jemand gewonnen! =>check_winner4:  moveq   #0,D0           ;noch hat keiner gewonnen!                rtscheck_winner5:  moveq   #-1,D0          ;es gibt einen Gewinner!                rts                ENDPART                >PART 'game_over' ;ein Spieler oder Team hat gewonnengame_over:      clr.l   -(SP)                move.w  #7,-(SP)                trap    #14             ;Hintergrund schwarz                addq.l  #6,SP                moveq   #15,D1          ;Den Gewinner suchen                lea     player_data,A0                lea     team_scores,A1game_over1:     tst.w   team_flag       ;Teams?                beq.s   game_over2      ;Nein =>                move.w  ply_team(A0),D0                add.w   D0,D0                move.w  0(A1,D0.w),D0   ;Score des Teams holen                bra.s   game_over3game_over2:     move.w  ply_score(A0),D0 ;Score des Einzelspielers holengame_over3:     move.w  ply_winscore(A0),D2                lea     ply_size(A0),A0                cmp.w   D2,D0           ;Gewinnscore erreicht?                dbcc    D1,game_over1                sub.w   #15,D1                neg.w   D1                move.w  D1,-4(A6)       ;Der Gewinner!                move.w  own_number,D0                tst.w   team_flag       ;Teams?                beq.s   game_over5      ;Nein! =>                mulu    #ply_size,D0                lea     player_data,A0                adda.w  D0,A0                move.w  ply_team(A0),D0 ;eigene Teamnummer holen                lea     player_data,A1                mulu    #ply_size,D1                adda.w  D1,A1                cmp.w   ply_team(A1),D0 ;mit der Teamnummer des Gewinners vergleichen                beq.s   game_over6      ;Gewinner =>game_over4:     moveq   #0,D0           ;Verlierer                bra.s   game_over7game_over5:     cmp.w   D1,D0           ;hat mein Spieler gewonnen?                bne.s   game_over4      ;Nein! =>game_over6:     moveq   #1,D0           ;Gewinnergame_over7:     move.w  D0,-6(A6)       ;Flag, ob 1=gewonnen oder 0=verloren                moveq   #0,D3                lea     lose_anim(PC),A3 ;Looseranimation                tst.w   -6(A6)          ;Gewonnen?                beq.s   game_over8      ;Nein! =>                lea     winner_anim(PC),A3 ;Gewinneranimationgame_over8:     tst.w   screen_rez      ;Farbe?                beq.s   game_over10     ;Ja! =>                move.w  #1,-(SP)                move.w  #201,-(SP)                move.w  #319,-(SP)                clr.l   -(SP)                bsr     dr_sw_box       ;Wei§e Box                lea     10(SP),SP                move.w  -4(A6),-(SP)                move.w  #100,-(SP)      ;Spritegrš§e                move.w  (A3)+,-(SP)     ;Spritenummer                move.w  #64,-(SP)                move.w  #96,-(SP)                bsr     set_shape                lea     10(SP),SP                bra.s   game_over12game_over10:    move.w  #7,-(SP)                move.w  #100,-(SP)                move.w  #159,-(SP)                clr.l   -(SP)                bsr     dr_c_box                lea     10(SP),SP                move.w  -4(A6),-(SP)                move.w  #50,-(SP)       ;Spritegrš§e                move.w  (A3)+,-(SP)     ;Spritenummer                move.w  #32,-(SP)                move.w  #48,-(SP)                bsr     set_shape                lea     10(SP),SPgame_over12:                tst.w   team_flag       ;Teams?                beq.s   game_over14     ;Nein! =>                lea     your_team_win(PC),A0                tst.w   -6(A6)                bne.s   game_over13                lea     your_team_lose(PC),A0game_over13:    bsr     print_line                bra.s   game_over15game_over14:    lea     you_win(PC),A0  ;"You win!"                tst.w   -6(A6)                bne.s   game_over13                move.w  -4(A6),D1                bsr     send_name_adr                bsr     print_line                lea     wins(PC),A0                bsr     string_outgame_over15:    bsr     switch_screens                movem.l D0-D2/A0-A2,-(SP)                move.w  #$25,-(SP)                trap    #14             ;Vsync()                addq.l  #2,SP                movem.l (SP)+,D0-D2/A0-A2                addq.w  #1,D3                cmp.w   #29,D3                blo     game_over8                moveq   #120,D0                bsr     pause           ;0.6s Pause                move.w  -4(A6),D0       ;Nummer des Gewinners                tst.w   team_flag       ;Teams?                beq.s   game_over17     ;Nein! =>                mulu    #ply_size,D0                lea     player_data,A0                move.w  ply_team(A0,D0.w),D0 ;Nummer des Teamsgame_over17:    lea     score_table,A0                add.w   D0,D0                adda.w  D0,A0                move.w  (A0),D0                cmp.w   #999,D0         ;999 ist Maximum!                beq.s   game_over18     ;dann gibt's nix mehr!                addq.w  #1,(A0)         ;ein Punkt dazugame_over18:    bsr     switch_logbase                tst.w   -6(A6)          ;Gewinner?                beq     game_over23     ;Nein! =>                move.w  -4(A6),D0       ;Farbe des Gewinners (meine Farbe)                add.w   D0,D0                lea     color_cnv_back,A0                move.w  0(A0,D0.w),-(SP)                tst.w   screen_rez      ;Gewinner!                beq.s   game_over19                move.w  #97,-(SP)                move.w  #189,-(SP)                move.w  #58,-(SP)                move.w  #170,-(SP)                bsr     dr_sw_box                lea     10(SP),SP                move.w  -4(A6),D0                add.w   D0,D0                lea     color_cnv_frame,A0                move.w  0(A0,D0.w),D0                add.w   D0,D0                add.w   D0,D0                lea     sw_farbfŸll_tab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  #6,-(SP)                move.w  #2,-(SP)                move.l  blinzshape_ptr,-(SP)                addi.l  #24,(SP)                move.w  #86,-(SP)                move.w  #164,-(SP)                bsr     dr_sw_shape                lea     16(SP),SP                bra.s   game_over20game_over19:    move.w  #48,-(SP)                move.w  #94,-(SP)                move.w  #29,-(SP)                move.w  #85,-(SP)                bsr     dr_c_box                addq.l  #8,SP                move.w  -4(A6),D0                add.w   D0,D0                lea     color_cnv_frame,A0                move.w  0(A0,D0.w),D0                add.w   D0,D0                add.w   D0,D0                lea     col_farb_jmptab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  #6,-(SP)                move.w  #1,-(SP)                move.l  blinzshape_ptr,-(SP)                addi.l  #12,(SP)                move.w  #43,-(SP)                move.w  #82,-(SP)                bsr     dr_c_shape                lea     16(SP),SPgame_over20:    bsr     switch_logbase                moveq   #40,D0          ;0.2ms Pause                bsr     pause                tst.w   screen_rez                beq.s   game_over21                move.w  -4(A6),-(SP)                move.w  #100,-(SP)      ;Spritegrš§e                clr.w   -(SP)           ;Spritenummer                move.w  #64,-(SP)                move.w  #96,-(SP)                bsr     set_shape                lea     10(SP),SP                bra.s   game_over22game_over21:    move.w  -4(A6),-(SP)                move.w  #50,-(SP)       ;Spritegrš§e                clr.w   -(SP)           ;Spritenummer                move.w  #32,-(SP)                move.w  #48,-(SP)                bsr     set_shape                lea     10(SP),SPgame_over22:    bsr     switch_screens                bra.s   play_game_endgame_over23:    tst.w   screen_rez      ;Verlierer!                beq.s   game_over24                move.l  sw_fŸllmuster(PC),-(SP)                move.w  #9,-(SP)                move.w  #4,-(SP)                move.l  loosershape_ptr,-(SP)                addi.l  #72,(SP)                move.w  #145,-(SP)                move.w  #142,-(SP)                bsr     dr_sw_shape                lea     16(SP),SP                bra.s   game_over25game_over24:    move.l  col_farb2jmptab(PC),-(SP)                move.w  #9,-(SP)                move.w  #2,-(SP)                move.l  loosershape_ptr,-(SP)                addi.l  #36,(SP)                move.w  #72,-(SP)                move.w  #71,-(SP)                bsr     dr_c_shape                lea     16(SP),SPgame_over25:    bsr     switch_logbaseplay_game_end:  move.l  #200*3,D0                bsr     pause           ;3sek Pause                bsr     set_akt_score                bsr     clr_con                moveq   #0,D0           ;alles ok, Endeplay_game_err:  unlk    A6                rts                ENDPART                >PART 'update_smily' ;das Gesicht (Lebensanzahl) updatenupdate_smily:   movem.l D0-A6,-(SP)                move.w  own_number,D0                mulu    #ply_size,D0                add.l   #player_data,D0                movea.l D0,A0                move.w  ply_lives(A0),D6                cmp.w   #3,D6                bls.s   update_smily0   ;0 bis 3: die Lebensenergie                moveq   #3,D6update_smily0:  move.w  D6,D0                move.w  #160,D1                mulu    #40,D0                sub.w   D0,D1                add.w   D1,D1                tst.w   screen_rez                beq.s   update_smily1                add.w   D1,D1update_smily1:  ext.l   D1                add.l   live_shape_ptr,D1                movea.l D1,A5           ;Zeiger auf das Gesicht vom Smily                move.w  live_wind_off,D0                bsr     set_screen_offs ;aktives Window wechseln                moveq   #0,D7update_smily2:  move.w  own_number,D0                add.w   D0,D0                lea     color_cnv_back,A0                move.w  0(A0,D0.w),D0   ;Spielerfarbe holen                add.w   D0,D0                add.w   D0,D0                move.w  set_shape_tab5+24,D1                ext.l   D1                add.l   D1,D1                add.l   shape_face_ptr,D1                tst.w   screen_rez      ;Farbe?                beq.s   update_smily3   ;Ja! =>                lea     sw_farbfŸll_tab(PC),A0                move.l  0(A0,D0.w),-(SP) ;Zeiger auf das FŸllmuster                move.w  #20,-(SP)                move.w  #4,-(SP)                move.l  D1,-(SP)                move.w  #38,-(SP)       ;Y                move.w  #4,-(SP)        ;X                bsr     dr_sw_shape     ;Shape-Hintergrund zeichnen                lea     16(SP),SP                move.l  sw_farbfŸll_tab(PC),-(SP) ;in Schwarz fŸllen                move.w  #20,-(SP)                move.w  #4,-(SP)                move.l  A5,-(SP)                move.w  #38,-(SP)       ;Y                move.w  #4,-(SP)        ;X                bsr     dr_sw_shape     ;Shape-Gesicht zeichnen                lea     16(SP),SP                bra.s   update_smily4update_smily3:  lea     col_farb_jmptab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  #20,-(SP)                move.w  #2,-(SP)                move.l  D1,-(SP)                move.w  #19,-(SP)                move.w  #2,-(SP)                bsr     dr_c_shape      ;Shape-Hintergrund zeichnen                lea     16(SP),SP                move.w  own_number,D0                add.w   D0,D0                lea     color_cnv_frame,A0                move.w  0(A0,D0.w),D0                add.w   D0,D0                add.w   D0,D0                lea     col_farb_jmptab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  #20,-(SP)                move.w  #2,-(SP)                move.l  A5,-(SP)                move.w  #19,-(SP)                move.w  #2,-(SP)                bsr     dr_c_shape      ;Shape-Gesicht zeichnen                lea     16(SP),SPupdate_smily4:  tst.w   D6              ;Energie = 0?                bne.s   update_smily6   ;Nein! =>                movea.l live_shape_ptr,A0                tst.w   screen_rez      ;Farbe?                beq.s   update_smily5   ;Ja! =>                move.l  sw_fŸllmuster(PC),-(SP)                move.w  #20,-(SP)                move.w  #4,-(SP)                pea     800(A0)                move.w  #38,-(SP)                move.w  #4,-(SP)                bsr     dr_sw_shape     ;Smily durchsteichen                lea     16(SP),SP                bra.s   update_smily6update_smily5:  move.l  col_farb2jmptab(PC),-(SP)                move.w  #20,-(SP)                move.w  #2,-(SP)                pea     400(A0)                move.w  #19,-(SP)                move.w  #2,-(SP)                bsr     dr_c_shape      ;Smily durchsteichen                lea     16(SP),SPupdate_smily6:  bsr     switch_logbase                addq.w  #1,D7                cmp.w   #2,D7                bne     update_smily2                move.w  main_wind_off,D0                bsr     set_screen_offs ;aktives Window wieder zurŸck                movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'add_one_smily' ;einen Abschu§ mehr (Anzahl,Looser)add_one_smily:  link    A6,#-18                move.w  8(A6),D0                bmi     add_one_smily12                moveq   #17,D1                cmp.w   #6,D0           ;mehr als 6 Treffer?                bhi.s   add_one_smily1  ;Ja! =>                moveq   #0,D1add_one_smily1: cmp.w   #12,D0                bls.s   add_one_smily0                moveq   #12,D0          ;max.12 AbschŸsse anzeigenadd_one_smily0: subq.w  #1,D0                divu    #6,D0           ;(Anzahl-1) MOD 6)*25+1                swap    D0                mulu    #25,D0                addq.w  #8,D0                tst.w   screen_rez      ;Farbe?                beq.s   add_one_smily2  ;Ja! =>                add.w   D0,D0                add.w   D1,D1           ;fŸr S/W mal 2add_one_smily2: move.w  D0,-2(A6)       ;X-Position                move.w  D1,-4(A6)       ;Y-Position merken                move.w  #16,8(A6)       ;Anzahl=16                moveq   #1,D0                tst.w   screen_rez      ;Farbe?                beq.s   add_one_smily4  ;Ja! =>                moveq   #2,D0add_one_smily4: move.w  D0,-8(A6)                move.w  set_shape_tab4+32,-10(A6)                move.w  set_shape_tab5+32,D0                move.w  D0,-6(A6)                add.w   D0,D0                add.l   shape_face_ptr,D0                move.l  D0,-14(A6)                move.w  pscore_wind_off,D0 ;Fenster der 10 Smilys                bsr     set_screen_offs                move.w  10(A6),D0       ;Farbe des Loosers                add.w   D0,D0                lea     color_cnv_back,A0                move.w  0(A0,D0.w),D0   ;FŸllmuster                add.w   D0,D0                add.w   D0,D0           ;mal 4 (Offset auf Long-Tabelle)                tst.w   screen_rez      ;Farbe?                beq.s   add_one_smily5  ;Ja! =>                lea     sw_farbfŸll_tab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.l  0(A0,D0.w),-(SP)                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -14(A6),-(SP)                move.w  -4(A6),-(SP)                move.w  -2(A6),-(SP)                bsr     dr_sw_shape     ;1.Seite                lea     16(SP),SP                bsr     switch_logbase                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -14(A6),-(SP)                move.w  -4(A6),-(SP)                move.w  -2(A6),-(SP)                bsr     dr_sw_shape     ;2.Seite                lea     16(SP),SP                bra.s   add_one_smily8add_one_smily5: lea     col_farb_jmptab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.l  0(A0,D0.w),-(SP)                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -14(A6),-(SP)                move.w  -4(A6),-(SP)                move.w  -2(A6),-(SP)                bsr     dr_c_shape      ;1.Seite                lea     16(SP),SP                bsr     switch_logbase                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -14(A6),-(SP)                move.w  -4(A6),-(SP)                move.w  -2(A6),-(SP)                bsr     dr_c_shape      ;2.Seite                lea     16(SP),SPadd_one_smily8: move.w  8(A6),D0                add.w   D0,D0                add.w   D0,D0                lea     set_shape_tab6,A0                move.l  0(A0,D0.w),D0                add.l   D0,D0                add.l   shape_ptr,D0                move.l  D0,-14(A6)                move.w  10(A6),D0       ;Der Looser!                add.w   D0,D0                lea     color_cnv_frame,A0                move.w  0(A0,D0.w),D0                add.w   D0,D0                add.w   D0,D0                tst.w   screen_rez      ;Farbe?                beq.s   add_one_smily9  ;Ja! =>                bsr.s   add_one_sub_sw                bsr     switch_logbase                bsr.s   add_one_sub_sw                bra.s   add_one_smily12add_one_smily9: bsr.s   add_one_sub_col                bsr     switch_logbase                bsr.s   add_one_sub_coladd_one_smily12:move.w  main_wind_off,D0                bsr     set_screen_offs                unlk    A6                rtsadd_one_sub_sw: move.w  D0,-(SP)                lea     sw_farbfŸll_tab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -14(A6),-(SP)                move.w  -4(A6),-(SP)                move.w  -2(A6),-(SP)                bsr     dr_sw_shape     ;die Augen zeichnen                lea     16(SP),SP                move.l  sw_fŸllmuster(PC),-(SP)                move.w  #15,-(SP)                move.w  #4,-(SP)                move.l  crossedsmil_ptr,-(SP)                moveq   #120,D0                add.l   D0,(SP)                move.w  -4(A6),-(SP)                addq.w  #2,(SP)                move.w  -2(A6),-(SP)                subq.w  #2,(SP)                bsr     dr_sw_shape                lea     16(SP),SP                move.w  (SP)+,D0                rtsadd_one_sub_col:move.w  D0,-(SP)                lea     col_farb_jmptab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -14(A6),-(SP)                move.w  -4(A6),-(SP)                move.w  -2(A6),-(SP)                bsr     dr_c_shape                lea     16(SP),SP                move.l  col_farb2jmptab(PC),-(SP)                move.w  #15,-(SP)                move.w  #2,-(SP)                move.l  crossedsmil_ptr,-(SP)                moveq   #60,D0                add.l   D0,(SP)                move.w  -4(A6),-(SP)                addq.w  #1,(SP)                move.w  -2(A6),-(SP)                subq.w  #1,(SP)                bsr     dr_c_shape                lea     16(SP),SP                move.w  (SP)+,D0                rts                ENDPART                >PART 'update_score' ;GesamtscorezŠhler updaten (player,newscore)update_score:   movem.l D0-A1,-(SP)                moveq   #2,D2           ;Zeile 2                move.w  10*4+4(SP),D0   ;Spielernummer                cmp.w   #8,D0                blo.s   update_score0                moveq   #3,D2           ;Zeile 3update_score0:  swap    D2                move.w  #7,D2                and.w   D0,D2           ;Spieler 0-7 und 8-15 in einer Zeile                add.w   D2,D2                add.w   D2,D2           ;mal 4                addq.w  #7,D2                swap    D2                lea     akt_score,A0                add.w   D0,D0                adda.w  D0,A0                moveq   #0,D1                move.w  10*4+6(SP),D1   ;Den Score holen                bpl.s   update_score2   ;Positiv? Ja! =>                moveq   #0,D1           ;sonst den Score lšschenupdate_score2:  move.w  D1,(A0)         ;den Score merken                bsr     score3out                movem.l (SP)+,D0-A1                rts                ENDPART                >PART 'check_score' ;ScorezŠhler aller Spieler updatencheck_score:    movem.l D0-A6,-(SP)                moveq   #0,D7           ;akt.Spielernummer                moveq   #0,D6           ;ZŠhler in 2er Schrittencheck_score1:   lea     akt_score,A1                tst.w   team_flag       ;Teamplay?                beq.s   check_score2    ;Nein! =>                lea     team_scores,A0                move.w  0(A0,D6.w),D0                cmp.w   0(A1,D6.w),D0   ;ist der Score noch gleich?                beq.s   check_score3    ;Ja! =>                move.w  0(A0,D6.w),-(SP) ;Der Score                move.w  D7,-(SP)        ;Die Spielernummer                bsr.s   update_score    ;den ScorezŠhler updaten                addq.l  #4,SP                bra.s   check_score3check_score2:   lea     player_data,A0                move.w  D7,D0                mulu    #ply_size,D0                adda.w  D0,A0                move.w  ply_score(A0),D0                cmp.w   0(A1,D6.w),D0   ;ist der Score noch gleich?                beq.s   check_score3    ;Ja! =>                move.w  ply_score(A0),-(SP) ;Der Score                move.w  D7,-(SP)                bsr     update_score    ;den ScorezŠhler updaten                addq.l  #4,SPcheck_score3:   addq.w  #2,D6                addq.w  #1,D7                cmp.w   60+4(SP),D7     ;schon alle Spieler durch?                blo.s   check_score1    ;Nein! =>                movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'set_akt_score' ;ScorezŠhler zum Gesamtpunktestand bewegenset_akt_score:  moveq   #0,D3           ;keinen Score verŠndert                moveq   #0,D2set_akt_score2: move.w  D2,D0           ;akt.Spielernummer                add.w   D0,D0           ;mal 2 (Wortzeiger)                lea     akt_score,A0                move.w  0(A0,D0.w),D1   ;aktuellen Score holen                lea     score_table,A0                cmp.w   0(A0,D0.w),D1   ;Gesamtpunkte                beq.s   set_akt_score4                ble.s   set_akt_score3                subq.w  #1,D1                bra.s   set_akt_score5set_akt_score3: addq.w  #1,D1set_akt_score5: move.w  D1,-(SP)        ;neuer Score                move.w  D2,-(SP)        ;akt.Spieler                bsr     update_score                addq.l  #4,SP                move.w  #1,D3           ;Score wurde verŠndertset_akt_score4: addq.w  #1,D2           ;nŠchster Spieler                move.w  all_players,D0                tst.w   team_flag       ;Teams?                beq.s   set_akt_score6  ;Nein! =>                moveq   #t_anz,D0set_akt_score6: cmp.w   D0,D2           ;schon alle durch?                blo.s   set_akt_score2  ;Nein! =>                tst.w   D3              ;keinen Score mehr bewegt?                beq.s   set_akt_score8  ;Nein! =>                moveq   #2,D0                bsr     pause           ;25ms Pause                bra.s   set_akt_score   ;weiter geht's =>set_akt_score8: rts                ENDPART                >PART 'draw_karte' ;Level im Window zeichnendraw_karte:     movem.l D0-A6,-(SP)     ;Karte in Farbe zeichnen                movea.l screen_offs_adr,A1                lea     scr_buffer,A0                moveq   #0,D2                moveq   #80,D3                tst.w   screen_rez      ;S/W?                bne     draw_sw_karte   ;Ja! =>                tst.b   D0                bne     draw_karte7     ;Karte nicht geŠndert => nur kopieren                move.w  #7,-(SP)                move.w  #100,-(SP)                move.w  #159,-(SP)                clr.l   -(SP)                bsr     dr_c_box                lea     10(SP),SP                moveq   #0,D3draw_karte1:    moveq   #1,D2draw_karte2:    move.w  D2,-(SP)                move.w  D3,-(SP)                bsr     get_maze_datayx                addq.l  #4,SP                move.w  D0,D7                bmi.s   draw_karte4     ;Eine Wand? Nein =>                addq.w  #1,D7                cmp.w   #4,D7                bls.s   draw_karte3                moveq   #1,D7draw_karte3:                moveq   #94,D4                mulu    D3,D4                divu    maze_size,D4                addq.w  #3,D4                move.w  D2,D5                subq.w  #1,D5                mulu    #153,D5                divu    maze_size,D5                addq.w  #3,D5                move.w  D2,D6                addq.w  #1,D6                mulu    #153,D6                divu    maze_size,D6                addq.w  #3,D6                move.w  D7,-(SP)                move.w  D4,-(SP)                move.w  D6,-(SP)                move.w  D5,-(SP)                bsr     dr_c_cline                addq.l  #8,SPdraw_karte4:    move.w  D3,-(SP)                move.w  D2,-(SP)                bsr     get_maze_datayx                addq.l  #4,SP                move.w  D0,D7                bmi.s   draw_karte6     ;Eine Wand? Nein =>                addq.w  #1,D7                cmp.w   #4,D7                bls.s   draw_karte5                moveq   #1,D7draw_karte5:                move.w  #153,D4                mulu    D3,D4                divu    maze_size,D4                addq.w  #3,D4                move.w  D2,D5                subq.w  #1,D5                mulu    #94,D5                divu    maze_size,D5                addq.w  #3,D5                move.w  D2,D6                addq.w  #1,D6                mulu    #94,D6                divu    maze_size,D6                addq.w  #3,D6                move.w  D7,-(SP)                move.w  D4,-(SP)                move.w  D6,-(SP)                move.w  D5,-(SP)                bsr     dr_c_cvline                addq.l  #8,SPdraw_karte6:    addq.w  #2,D2                cmp.w   maze_size,D2                blo     draw_karte2                addq.w  #2,D3                cmp.w   maze_size,D3                bls     draw_karte1                movea.l screen_offs_adr,A0                lea     scr_buffer,A1                moveq   #80,D2                moveq   #0,D3draw_karte7:    moveq   #99,D1draw_karte8:    moveq   #19,D0draw_karte9:    move.l  (A0)+,(A1)+                dbra    D0,draw_karte9                adda.w  D2,A0                adda.w  D3,A1                dbra    D1,draw_karte8                movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'draw_sw_karte' ;Karte in S/W zeichnendraw_sw_karte:  asr.w   #1,D3                tst.b   D0                bne     draw_sw_karte7  ;Karte nicht geŠndert => nur kopieren                move.w  #1,-(SP)        ;wei§                move.w  #201,-(SP)                move.w  #320,-(SP)                clr.l   -(SP)                bsr     dr_sw_box       ;Das Fenster lšschen                lea     10(SP),SP                moveq   #0,D3           ;Ydraw_sw_karte1: move.w  #1,D2           ;Xdraw_sw_karte2: move.w  D2,-(SP)        ;X                move.w  D3,-(SP)        ;Y                bsr     get_maze_datayx                addq.l  #4,SP                tst.w   D0                bmi.s   draw_sw_karte4  ;Ein Wand? Nein! =>                moveq   #12,D7                cmp.w   #3,D0           ;eine TŸr?                beq.s   draw_sw_karte3  ;Ja! =>                moveq   #2,D7                cmp.w   #2,D0                beq.s   draw_sw_karte3                moveq   #0,D7           ;sonstige Wanddraw_sw_karte3: move.w  #188,D4                mulu    D3,D4			;Y                divu    maze_size,D4                addq.w  #6,D4           ;Y-Position                move.w  D2,D5 	       	;X                subq.w  #1,D5                mulu    #307,D5                divu    maze_size,D5                addq.w  #6,D5           ;X1                move.w  D2,D6        	;X                addq.w  #1,D6                mulu    #307,D6                divu    maze_size,D6                addq.w  #6,D6           ;X2                move.w  D7,-(SP)        ;FŸllmuster                move.w  D4,-(SP)        ;Y                move.w  D6,-(SP)        ;X2                move.w  D5,-(SP)        ;X1                bsr     dr_sw_hline     ;HLine                addq.l  #8,SPdraw_sw_karte4: move.w  D3,-(SP)        ;X                move.w  D2,-(SP)        ;Y                bsr     get_maze_datayx                addq.l  #4,SP                tst.w   D0                bmi.s   draw_sw_karte6  ;Ein Wand? Nein! =>                moveq   #12,D7                cmp.w   #3,D0                beq.s   draw_sw_karte5                moveq   #2,D7                cmp.w   #2,D0                beq.s   draw_sw_karte5                moveq   #0,D7draw_sw_karte5: move.w  #307,D4                mulu    D3,D4                divu    maze_size,D4                addq.w  #6,D4           ;X                move.w  D2,D5                subq.w  #1,D5                mulu    #188,D5                divu    maze_size,D5                addq.w  #6,D5           ;Y1                move.w  #188,D0                move.w  D2,D6                addq.w  #1,D6                mulu    #188,D6                divu    maze_size,D6                addq.w  #6,D6           ;Y2                move.w  D7,-(SP)        ;FŸllmuster                move.w  D4,-(SP)        ;X                move.w  D6,-(SP)        ;Y2                move.w  D5,-(SP)        ;Y1                bsr     dr_sw_vline     ;VLine                addq.l  #8,SPdraw_sw_karte6: addq.w  #2,D2                cmp.w   maze_size,D2                blo     draw_sw_karte2                addq.w  #2,D3                cmp.w   maze_size,D3                bls     draw_sw_karte1                movea.l screen_offs_adr,A0                lea     scr_buffer,A1                moveq   #40,D2                moveq   #0,D3draw_sw_karte7: move.w  #199,D1draw_sw_karte8: moveq   #9,D0draw_sw_karte9: move.l  (A0)+,(A1)+                dbra    D0,draw_sw_karte9                adda.w  D2,A0                adda.w  D3,A1                dbra    D1,draw_sw_karte8                movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'set_ply_karte' ;Spieler 8(A6) in die Karte setzenset_ply_karte:  tst.w   screen_rez      ;S/W?                bne     set_ply_swkarte ;Ja! =>                movem.l D0-A6,-(SP)                move.w  4+15*4(SP),D0                mulu    #ply_size,D0                lea     player_data,A0                adda.w  D0,A0           ;Zeiger auf den Spieler                move.w  ply_y(A0),D3                move.w  ply_x(A0),D4                move.w  maze_size,D1                lsl.w   #7,D1                mulu    #153,D4                divs    D1,D4                bmi     set_ply_karte1                cmp.w   #153,D4                bhs     set_ply_karte1                addq.w  #1,D4           ;X-Koordinate                mulu    #94,D3                divs    D1,D3                bmi     set_ply_karte1                cmp.w   #94,D3                bhs.s   set_ply_karte1                addq.w  #5,D3           ;Y-Koordinate                move.w  4+15*4(SP),D0                add.w   D0,D0                lea     color_cnv_back,A0                move.w  0(A0,D0.w),D0                add.w   D0,D0                add.w   D0,D0                lea     col_farb_jmptab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  #5,-(SP)                move.w  #1,-(SP)                move.l  mapsmily_ptr,-(SP)                addi.l  #10,(SP)                move.w  D3,-(SP)                move.w  D4,-(SP)                bsr     dr_c_shape                lea     16(SP),SP                move.w  8(A6),D0                add.w   D0,D0                lea     color_cnv_frame,A0                move.w  0(A0,D0.w),D0                add.w   D0,D0                add.w   D0,D0                lea     col_farb_jmptab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  #5,-(SP)                move.w  #1,-(SP)                move.l  mapsmily2_ptr,-(SP)                addi.l  #10,(SP)                move.w  D3,-(SP)                move.w  D4,-(SP)                bsr     dr_c_shape                lea     16(SP),SPset_ply_karte1: movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'set_ply_swkarte' ;Spieler 8(A6) in die S/W-Karte setzenset_ply_swkarte:movem.l D0-A6,-(SP)                move.w  4+15*4(SP),D0                mulu    #ply_size,D0                lea     player_data,A0                adda.w  D0,A0           ;Zeiger auf den Spieler                move.w  ply_y(A0),D3                move.w  ply_x(A0),D4                move.w  maze_size,D0                lsl.w   #7,D0                move.w  #307,D1                mulu    D4,D1                divs    D0,D1                bmi.s   set_ply_karte1                cmp.w   #307,D1                bhs.s   set_ply_karte1                addq.w  #1,D1           ;X-Koordinate                move.w  #188,D2                mulu    D3,D2                divs    D0,D2                bmi.s   set_ply_karte1                cmp.w   #188,D2                bhs.s   set_ply_karte1                add.w   #9,D2           ;Y-Koordinate                move.w  4+15*4(SP),D0                add.w   D0,D0                lea     color_cnv_back,A0                move.w  0(A0,D0.w),D0                lsl.w   #2,D0                lea     sw_farbfŸll_tab(PC),A0                move.l  0(A0,D0.w),-(SP)                move.w  #5,-(SP)                move.w  #2,-(SP)                move.l  mapsmily_ptr,-(SP)                addi.l  #20,(SP)                move.w  D2,-(SP)                move.w  D1,-(SP)                bsr     dr_sw_shape                lea     16(SP),SP                movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'set_screen_offs' ;neuen Screen-Offset setzenset_screen_offs:movem.l D0-D1/A0,-(SP)                ext.l   D0              ;neuen Screen-Offset                move.w  D0,screen_offset ;merken                lea     screen_1,A0                move.w  screen_flag,D1                lsl.w   #2,D1                add.l   0(A0,D1.w),D0   ;+ Adr der aktuellen Grafikseite                move.l  D0,screen_offs_adr ;merken                movem.l (SP)+,D0-D1/A0                rts                ENDPART                >PART 'switch_screens' ;Bildschirmseiten umschaltenswitch_screens: movem.l D0-D2/A0-A2,-(SP)                move.w  screen_flag,D0                eori.w  #1,D0           ;Flag toggeln                move.w  D0,screen_flag                add.w   D0,D0                add.w   D0,D0                lea     screen_1,A0                move.w  screen_offset,D1                ext.l   D1                add.l   0(A0,D0.w),D1                move.l  D1,screen_offs_adr                move.w  #-1,-(SP)       ;Auflšsung beibehalten                bchg    #2,D0                move.l  0(A0,D0.w),-(SP)                bchg    #2,D0                move.l  0(A0,D0.w),-(SP)                move.w  #5,-(SP)                trap    #14             ;Setscreen()                lea     12(SP),SP                movem.l (SP)+,D0-D2/A0-A2                rts                ENDPART                >PART 'switch_logbase' ;logbase setzenswitch_logbase: movem.l D0-D2/A0-A2,-(SP)                move.w  screen_flag,D0                eori.w  #1,D0                move.w  D0,screen_flag                add.w   D0,D0                add.w   D0,D0                lea     screen_1,A0                move.w  screen_offset,D1                ext.l   D1                add.l   0(A0,D0.w),D1                move.l  D1,screen_offs_adr                moveq   #-1,D1                move.w  D1,-(SP)        ;Auflšsung nicht Šndern                move.l  D1,-(SP)        ;Physbase nicht Šndern                move.l  0(A0,D0.w),-(SP) ;logbase setzen                move.w  #5,-(SP)                trap    #14             ;Setscreen                lea     12(SP),SP                movem.l (SP)+,D0-D2/A0-A2                rts                ENDPART                >PART 'switch_org_scr' ;auf den Originalscreen zurŸckschaltenswitch_org_scr: movem.l D0-D2/A0-A2,-(SP)                move.w  #-1,-(SP)                move.l  screen_2,-(SP)                move.l  screen_2,-(SP)                move.w  #5,-(SP)                trap    #14             ;Setscreen()                lea     12(SP),SP                clr.w   screen_flag                movem.l (SP)+,D0-D2/A0-A2                rts                ENDPART                >PART 'copy_screen' ;Screen auf die andere Seite kopierencopy_screen:    movem.l D0-D2/A0-A2,-(SP)                move.w  screen_flag,D0                add.w   D0,D0                add.w   D0,D0                lea     screen_1,A0                movea.l 0(A0,D0.w),A1                bchg    #2,D0                movea.l 0(A0,D0.w),A2                move.w  #7999,D0copy_screen1:   move.l  (A2)+,(A1)+                dbra    D0,copy_screen1                bsr.s   switch_org_scr                tst.w   screen_flag                bne.s   copy_screen2                bsr     switch_logbasecopy_screen2:   movem.l (SP)+,D0-D2/A0-A2                rts                ENDPART                >PART 'reset_screen' ;VT52-Emulator zurŸcksetzenreset_screen:   clr.l   -(SP)                move.w  #7,-(SP)                trap    #14             ;Hintergrundfarbe zurŸcksetzen                addq.l  #6,SP                bra.s   copy_screen     ;Originalscreen                ENDPART                >PART 'redraw_desktop' ;den Hintergrund zurŸckkopierenredraw_desktop: movem.l D0-A6,-(SP)                lea     save_page,A2                movea.l screen_1,A0                movea.l screen_2,A1                move.w  #7999,D0redraw_desktop1:move.l  (A2),(A0)+      ;Grafik auf 2.Seite kopieren                move.l  (A2)+,(A1)+                dbra    D0,redraw_desktop1                movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'redraw_small' ;die letzte Zeile neu ausgebenredraw_small:   movem.l D0-A6,-(SP)                lea     save_page,A2                movea.l screen_1,A0                movea.l screen_2,A1                lea     1280*24(A2),A2                lea     1280*24(A0),A0                lea     1280*24(A1),A1                move.w  #319,D0redraw_small1:  move.l  (A2),(A0)+      ;Grafik auf 2.Seite kopieren                move.l  (A2)+,(A1)+                dbra    D0,redraw_small1                movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'check_con' ;Taste gedrŸckt? Z=1, wenn nichtcheck_con:      move.l  #$010002,-(SP)                trap    #13             ;Bconstat()                addq.l  #4,SP                tst.w   D0              ;eine Taste?                beq.s   check_con1      ;Nein =>                move.l  #$020002,-(SP)                trap    #13             ;Bconin()                addq.l  #4,SP                tst.l   D0check_con1:     rts                ENDPART                >PART 'clr_con' ;Tastaturbuffer lšschenclr_con:        bra.s   clr_con2clr_con1:       move.l  #$020002,-(SP)                trap    #13             ;Bconin(CON)                addq.l  #4,SPclr_con2:       move.l  #$010002,-(SP)                trap    #13             ;Bconstat(CON)                addq.l  #4,SP                tst.l   D0                bne.s   clr_con1                rts                ENDPART                >PART 'clr_midi' ;MIDI-Buffer lšschenclr_midi:       bra.s   clr_midi_buffe2clr_midi_buffe1:move.l  #$020003,-(SP)                trap    #13             ;Bconin(MIDI)                addq.l  #4,SPclr_midi_buffe2:move.l  #$010003,-(SP)                trap    #13             ;Bconstat(MIDI)                addq.l  #4,SP                tst.l   D0                bne.s   clr_midi_buffe1                rts                ENDPART                >PART 'send_midi' ;Byte D0 auf MIDI ausgeben und wieder erwartensend_midi:      bsr.s   put_midi                bra.s   get_midi                ENDPART                >PART 'put_midi' ;Byte D0 auf MIDI ausgebenput_midi:       movem.l D0-D2/A0-A2,-(SP)                and.w   #$FF,D0                move.w  D0,-(SP)                move.l  #$030003,-(SP)                trap    #13             ;Bconout(MIDI)                addq.l  #6,SP                movem.l (SP)+,D0-D2/A0-A2                rts                ENDPART                >PART 'get_midi' ;MIDI-Byte mit Timeout holenget_midi:       movem.l D1-D3/A0-A2,-(SP)                bsr     get_hz200                move.l  timeout,D3                add.l   D0,D3get_midi1:      move.l  #$010003,-(SP)                trap    #13             ;Bconstat(MIDI)                addq.l  #4,SP                tst.l   D0                beq.s   get_midi2                move.l  #$020003,-(SP)                trap    #13             ;Bconin(MIDI)                addq.l  #4,SP                and.w   #$FF,D0                movem.l (SP)+,D1-D3/A0-A2                rtsget_midi2:      bsr     get_hz200                cmp.l   D3,D0           ;Endzeit erreicht?                blo.s   get_midi1       ;Nein! => weiter warten                moveq   #-1,D0          ;Timeout!                movem.l (SP)+,D1-D3/A0-A2                rts                ENDPART                >PART 'pause'   ;D0 200Hz-Ticks Pausepause:          movem.l D0-D3/A0-A2,-(SP)                move.l  D0,D3                bsr     get_hz200       ;Startzeit zur Dauer addieren                add.l   D0,D3pause1:         bsr     get_hz200       ;Endzeit erreicht?                cmp.l   D3,D0                blo.s   pause1          ;sonst warten...                movem.l (SP)+,D0-D3/A0-A2                rts                ENDPART                >PART 'dez_out' ;3stellige Dezimalzahl in D0 miot FŸhrungsspace ausgebendez_out:        move.l  A0,-(SP)                lea     allg_buffer,A0                bsr.s   dez_a0                moveq   #' ',D0                bsr     rawcon_out                move.b  (A0)+,D0        ;3 Ziffern ausgeben                bsr     rawcon_out                move.b  (A0)+,D0                bsr     rawcon_out                move.b  (A0),D0                bsr     rawcon_out                movea.l (SP)+,A0                rts                ENDPART                >PART 'dez_a0'  ;3stellige Dezimalzahl in D0 nach A0dez_a0:         move.l  D1,-(SP)                moveq   #0,D1                move.w  D0,D1                divu    #100,D1                or.b    #'0',D1                move.b  D1,(A0)                clr.w   D1                swap    D1                divu    #10,D1                or.l    #' 0 0',D1                move.b  D1,1(A0)                swap    D1                move.b  D1,2(A0)                move.l  (SP)+,D1                rts                ENDPART                >PART 'num_out' ;Zahl D0 als Buchstaben A-Z ausgebennum_out:        and.l   #$FFFF,D0                divu    #10,D0          ;10 Schritte = 1 Buchstabe                add.w   #'A',D0                bra.s   rawcon_out                ENDPART                >PART 'score3out' ;3stellige Zahl in D1 an D2 ausgebenscore3out:      move.l  A0,-(SP)                lea     buffer,A0                clr.l   (A0)                bsr.s   set_cursor                move.w  D1,D0                bsr.s   dez_a0                bsr.s   string_out                bsr     switch_logbase  ;auf beiden Planes ausgeben                bsr.s   set_cursor                move.w  D1,D0                bsr.s   dez_a0                bsr.s   string_out                bsr     switch_logbase                movea.l (SP)+,A0                rts                ENDPART                >PART 'set_cursor' ;Cursor nach D2 setzen (High-Res-Umrechnung)set_cursor:     moveq   #'Y',D0         ;Cursor setzen                bsr.s   esc_code                move.w  D2,D0           ;Zeile im unteren Wort                add.w   #32,D0                bsr.s   con_out                swap    D2                move.w  D2,D0           ;Spalte im oberen Wort                swap    D2                tst.w   screen_rez                beq.s   set_cursor1                add.w   D0,D0set_cursor1:    add.w   #32,D0                bsr.s   con_out                rts                ENDPART                >PART 'rawcon_out' ;Zeichen in D0 ohne Steuerzeichen ausgebenrawcon_out:     movem.l D0-D2/A0-A2,-(SP)                and.w   #$FF,D0                move.w  D0,-(SP)                move.l  #$030005,-(SP)                trap    #13                addq.l  #6,SP                movem.l (SP)+,D0-D2/A0-A2                rts                ENDPART                >PART 'string_out' ;String ohne Steuerzeichen ausgebenstring_out:     movem.l D0/A0,-(SP)string_out1:    moveq   #0,D0                move.b  (A0)+,D0                beq.s   string_out2     ;Nullbyte=Ende                bsr.s   rawcon_out                bra.s   string_out1string_out2:    movem.l (SP)+,D0/A0                rts                ENDPART                >PART 'print_a0' ;String A0 mit Steuerzeichen ausgebenprint_a0:       movem.l D0/A0,-(SP)print_a01:      moveq   #0,D0                move.b  (A0)+,D0                beq.s   print_a02       ;Nullbyte=Ende                bsr.s   con_out                bra.s   print_a01print_a02:      movem.l (SP)+,D0/A0                rts                ENDPART                >PART 'esc_code'esc_code:       move.w  D0,-(SP)                moveq   #27,D0                bsr.s   con_out         ;ESC ausgeben                move.w  (SP)+,D0        ;und das Steuerzeichen ausgeben                ENDPART                >PART 'con_out' ;Zeichen in D0 mit Steuerzeichen ausgebencon_out:        movem.l D0-D2/A0-A2,-(SP)                and.w   #$FF,D0                move.w  D0,-(SP)                move.l  #$030002,-(SP)                trap    #13                addq.l  #6,SP                movem.l (SP)+,D0-D2/A0-A2                rts                ENDPART                IF master_flag                >PART 'master_loop' ;master_loop(flag) - flag=1:SOLO, flag=0:MASTERmaster_loop:    link    A6,#-12                lea     master_text(PC),A0                tst.w   8(A6)                beq.s   master_loop1                lea     solo_text(PC),A0master_loop1:   bsr     print_line      ;SLAVE                clr.w   own_number      ;Der Master hat Nummber 0                lea     maze_path,A3                move.w  #$19,-(SP)                trap    #1                addq.l  #2,SP                add.b   #'A',D0                move.b  D0,(A3)+                move.b  #':',(A3)+                sub.b   #'@',D0                move.w  D0,-(SP)                move.l  A3,-(SP)                move.w  #$47,-(SP)                trap    #1                addq.l  #8,SPmaster_loop5:   tst.b   (A3)+                bne.s   master_loop5                subq.l  #1,A3                move.b  #'\',(A3)+                move.b  #'*',(A3)+                move.b  #'.',(A3)+                move.b  #'M',(A3)+                move.b  #'Z',(A3)+                move.b  #'E',(A3)+                clr.b   (A3)+                tst.b   maze_loaded_flag ;MAZE geladen?                bne.s   master_loop7    ;Ja! =>                pea     midimaze_maz(PC)                pea     midimaze_maz(PC)                bsr     LoadMaze        ;MIDIMAZE.MZE laden                addq.l  #8,SP                tst.w   D0                bmi.s   master_loop7                st      maze_loaded_flagmaster_loop7:   tst.b   maze_loaded_flag ;Maze geladen                beq.s   master_loop7a   ;Nein! =>                bsr     switch_logbase                move.w  main_wind_off,D0                bsr     set_screen_offs                moveq   #0,D0                bsr     draw_karte      ;akt.Maze anzeigen                bsr     switch_org_scrmaster_loop7a:  st      -6(A6)          ;Hauptschleife nicht verlassenmaster_loop8:   bsr     clr_con         ;Tastatur-Buffer lšschenmaster_loop9:   move.l  #$010002,-(SP)                trap    #13             ;Zeichen an CON?                addq.l  #4,SP                tst.l   D0                beq.s   master_loop9    ;Nein! =>                move.l  #$020002,-(SP)                trap    #13             ;Zeichen holen                addq.l  #4,SP                swap    D0              ;Scancode nehmen                lea     master_keytab_a(PC),A0                lea     master_keytab_b(PC),A1master_loop10:  move.w  (A0)+,D1        ;Ende der Liste?                beq.s   master_loop8    ;=> Taste nicht gefunden                addq.l  #2,A1                cmp.w   D1,D0                bne.s   master_loop10                adda.w  -(A1),A1                bsr     redraw_small    ;untere Zeile lšschen                jsr     (A1)            ;Unterprogramm aufrufen                tst.w   -6(A6)          ;Exit?                bne.s   master_loop8    ;Nein! =>                move.w  -8(A6),D0       ;Exit-Status                unlk    A6                rtsmaster_keytab_a:DC.W $0832,$0824,$0813,$081F,$0810,$1C                DC.W $3B,$3C,$3D,$3E,0                BASE DC.W,*master_keytab_b:DC.W mn_mouse_on,mn_joystick_on,mn_mastertest,mn_slave,mn_quit                DC.W mn_start_game                DC.W mn_infobox,mn_load_maze,m_reset_scores,m_namesmn_mouse_on:    st      maus_or_joy     ;Maus an                lea     mouse_on(PC),A0                bra     print_linemn_joystick_on: sf      maus_or_joy     ;Joystick an                lea     joystick_on(PC),A0                bra     print_linemn_mastertest:  move.w  #3,-8(A6)       ;Master abtesten                clr.w   -6(A6)                rtsmn_slave:       move.w  #1,-8(A6)       ;auf Slave schalten                clr.w   -6(A6)                rtsmn_quit:        lea     quit_alert(PC),A0                bsr     small_alert                beq.s   mn_quit1                move.w  #-1,-8(A6)      ;Ende-Flag setzen                clr.w   -6(A6)mn_quit1:       rtsmn_infobox:     tst.w   8(A6)           ;SOLO?                bne.s   mn_infobox1     ;Ja! =>                bsr     clr_midi                moveq   #$85,D0                bsr     send_midi       ;INFO angeklickt                cmp.b   #$85,D0                bne     midi_ring_boomn_infobox1:    lea     info_text(PC),A0                bra     print_line      ;Infotextmn_load_maze:   move.l  #appl_init,D0                bsr     aes             ;Programm als GEM-Applikation anmelden                lea     addr_in,A0                lea     maze_path,A1    ;Der Pfad                move.l  A1,(A0)+                lea     maze_filename,A1 ;Der Filename                move.l  A1,(A0)+                lea     load_text(PC),A1                move.l  A1,(A0)                clr.l   -(SP)                move.w  #$20,-(SP)                trap    #1              ;Super(0L)                move.l  D0,2(SP)                movea.l $04F2.w,A3      ;_sysbase holen                trap    #1              ;Super(OldSSP)                addq.l  #6,SP                linea   #9 [ Showm ]                move.l  #fsel_input,D0                move.w  2(A3),D1        ;TOS-Version holen                cmp.w   #$0104,D1                blo.s   mn_load_maze0                move.l  #fsel_exinput,D0mn_load_maze0:  bsr     aes                move.w  int_out+2,D1    ;OK oder ABBRUCH?                linea   #10 [ Hidem ]                move.l  #appl_exit,D0                bsr     aes             ;Applikation wieder abmelden                bsr     redraw_desktop                tst.w   D1                beq.s   mn_load_maze5   ;ABBRUCH=0 => raus                lea     maze_path,A3                lea     maze_path2,A4                moveq   #-1,D0mn_load_maze1:  addq.w  #1,D0           ;Den Pfad kopieren                move.b  (A3)+,0(A4,D0.w)                bne.s   mn_load_maze1mn_load_maze2:  subq.w  #1,D0           ;Das Ende des Pfades suchen                bmi.s   mn_load_maze3                cmpi.b  #'\',0(A4,D0.w)                bne.s   mn_load_maze2mn_load_maze3:  lea     maze_filename,A0mn_load_maze4:  addq.w  #1,D0           ;und den Filenamen dranhŠngen                move.b  (A0)+,0(A4,D0.w)                bne.s   mn_load_maze4                pea     maze_filename   ;Der Filename                move.l  A4,-(SP)        ;Der Pfad+Filename                bsr     LoadMaze                addq.l  #8,SP                sf      maze_loaded_flag ;Fehler beim Laden                tst.w   D0                bmi.s   mn_load_maze5                st      maze_loaded_flag ;Maze geladen                bsr     switch_logbase                move.w  main_wind_off,D0                bsr     set_screen_offs                moveq   #0,D0                bsr     draw_karte                bsr     switch_org_scrmn_load_maze5:  rtsm_reset_scores: tst.w   8(A6)           ;SOLO?                bne.s   m_reset_scores1                bsr     clr_midi                moveq   #$81,D0                bsr     send_midi                cmp.b   #$81,D0                bne.s   midi_ring_boom_reset_scores1:moveq   #7,D0                lea     score_table,A0m_reset_scores2:clr.l   (A0)+           ;alle Scores lšschen                dbra    D0,m_reset_scores2                bsr     set_akt_score                bra     switch_org_scrm_names:        tst.w   8(A6)           ;SOLO?                bne.s   m_names3        ;Ja! =>                bsr     clr_midi                moveq   #$86,D0                bsr     send_midi                cmp.b   #$86,D0                beq.s   m_names2midi_ring_boo:  lea     midi_booboo(PC),A0 ;MIDI-Ring boo-boo                bra     print_linem_names2:       bsr.s   mn_get_computer ;Anzahl der Rechner holen                bra.s   m_names4m_names3:       move.w  #1,machines_online ;SOLO: nur ein Rechnerm_names4:       move.w  8(A6),-(SP)                bsr     name_input                addq.l  #2,SP                tst.w   D0                bmi.s   midi_ring_boo                rtsmn_get_computer:lea     machines_online,A0 ;Anzahl der Rechner holen                moveq   #1,D0           ;1 fŸr einen Rechner online senden                bsr     send_midi       ;Byte senden und empfangen                bmi.s   mn_get_compute2 ;Timeout =>                move.w  D0,(A0)         ;Anzahl der angeschlossenen Computer                bsr     send_midi       ;ebenfalls herumsenden                cmp.w   (A0),D0         ;Byte verfŠscht worden?                bne.s   mn_get_compute2 ;Ja! =>                moveq   #0,D0           ;Ok!, kein Fehler                cmpi.w  #16,(A0)        ;16 oder weniger Spieler?                ble.s   mn_get_compute1 ;Ja! =>                lea     too_many(PC),A0                bsr     print_line      ;zu viele Rechnermn_get_compute2:moveq   #-1,D0          ;Fehler!mn_get_compute1:tst.w   D0                rtsmn_start_game:  tst.b   maze_loaded_flag                bne.s   mn_start_game1                lea     no_maze(PC),A0                bra     print_linemn_start_game1: tst.w   8(A6)           ;SOLO?                bne.s   mn_start_game2  ;Ja! =>                bsr     clr_midi                moveq   #$80,D0                bsr     send_midi                cmp.b   #$80,D0                bne.s   midi_ring_boo                bsr.s   mn_get_computer ;Anzahl der Rechner holen                bmi.s   midi_ring_boo                bra.s   mn_start_game3mn_start_game2: move.w  #default_players,machines_online ;SOLO: nur ein Rechnermn_start_game3: bsr     master_dialog                lea     player_data,A0                lea     player_data2,A1                lea     player_data3,A2master_dianeu4: move.b  (A0)+,(A1)+     ;Spielerdaten sichern                cmpa.l  A2,A1                bne.s   master_dianeu4                tst.w   D0              ;Spielstart?                bpl.s   mn_start_game4  ;Ja! =>                rtsmn_start_game4: tst.w   8(A6)           ;SOLO?                bne.s   mn_start_game5  ;Ja! =>                moveq   #$84,D0                bsr     send_midi       ;Los geht's                cmp.b   #$84,D0                bne     midi_ring_boo                bsr     send_datas                bmi     midi_ring_boomn_start_game5: move.w  8(A6),-(SP)     ;SOLO/MASTER-Flag                bsr     play_game       ;auf geht's                move.w  D0,(SP)         ;Abbruchstatus merken                bsr     clr_con                bsr     copy_screen                bsr     exit_joystick                bsr     exit_mouse                move.w  (SP)+,D0        ;Abbruchstatus                bpl.s   mn_start_game11 ;alles ok! =>                addq.w  #1,D0                bne.s   mn_start_game9                lea     time_out(PC),A0 ;-1 = Timeout                bsr     print_line                bra.s   mn_start_game11mn_start_game9: addq.w  #1,D0                bne.s   mn_start_game10                lea     terminated(PC),A0 ;-2 = Game terminated                bsr     print_line                bra.s   mn_start_game11mn_start_game10:lea     maze_too_small(PC),A0                bsr     print_line      ;-3 = Maze too smallmn_start_game11:bsr     set_akt_score                bra     switch_org_scr                ENDPART                >PART 'master_dialog' ;Einstellungen des Mastersmaster_dialog:  tst.w   screen_rez      ;Farbe?                bne.s   master_dialog1  ;Nein! =>                move.w  #1,-(SP)                moveq   #-1,D0                move.l  D0,-(SP)                move.l  D0,-(SP)                move.w  #5,-(SP)                trap    #14             ;mittlere Auflšsung ein                lea     12(SP),SPmaster_dialog1: lea     edit_page2(PC),A0                move.w  machines_online,D0                bsr     dez_a0                moveq   #'s',D1         ;Players                subq.w  #1,D0                bne.s   master_dialog2                moveq   #' ',D1         ;Playermaster_dialog2: move.b  D1,10(A0)                lea     edit_page1(PC),A0                bsr     print_a0                bsr     master_redraw   ;alle Spieler ausgeben                moveq   #0,D7           ;Cursor auf Spieler 0master_d_loop:  moveq   #'p',D0         ;Spieler D7 ausgeben                bsr     esc_code        ;Invers an                bsr     ply_d7_out                moveq   #'q',D0                bsr     esc_code        ;Invers aus                move.w  #7,-(SP)                trap    #1              ;Was Šndern?                addq.l  #2,SP                tst.b   D0              ;kein ASCII-Code vorhanden?                bne.s   master_d_loop1  ;doch =>                swap    D0                or.b    #$80,D0         ;sonst Bit 7 setzenmaster_d_loop1: lea     master_diatab1(PC),A0                lea     master_diatab3-1(PC),A2                lea     master_diatab2-2(PC),A1master_d_loop2: move.b  (A0)+,D1        ;Ende der Tastentabelle?                beq.s   master_d_loop   ;Ja! => Taste ignorieren                addq.l  #1,A2                addq.l  #2,A1           ;Sprungtabellenzeiger erhšhen                cmp.b   D1,D0           ;Taste gefunden?                bne.s   master_d_loop2  ;nein! =>                moveq   #0,D0                move.b  (A2),D0         ;Bitnummer, Offset, ...                adda.w  (A1),A1                jsr     (A1)            ;Funktion ausfŸhren                beq.s   master_d_loop   ;weiter? Ja! =>                tst.w   screen_rez      ;Farbe?                bne.s   master_d_loop3  ;Nein! =>                movem.l D0-D2/A0-A2,-(SP)                clr.w   -(SP)                moveq   #-1,D0                move.l  D0,-(SP)                move.l  D0,-(SP)                move.w  #5,-(SP)                trap    #14             ;geringe Auflšsung wieder an                lea     12(SP),SP                movem.l (SP)+,D0-D2/A0-A2master_d_loop3: bsr     master_redraw                bra     redraw_desktop  ;Desktop neu zeichnen                BASE DC.W,*master_diatab2: DC.W md_winscrsub,md_winscore,md_team,md_reload,md_reload                DC.W md_reload,md_revive,md_reload,md_features,md_features                DC.W md_features,md_features,md_features,md_features                DC.W md_features,md_features,md_features,md_features                DC.W md_features,md_features,md_features,md_features                DC.W md_features,md_features,md_features,md_features                DC.W md_features,md_features,md_features,md_features                DC.W md_features,md_features,md_features,md_features                DC.W md_features,md_features,md_features                DC.W md_copy,md_copy_all                DC.W md_select,md_select,md_select,md_select,md_select                DC.W master_undo,master_esc,master_cr                DC.W master_up,master_down,master_homemaster_diatab3: DC.B 0,0,0,ply_reload_t,ply_refresh_t,ply_regen_t                DC.B ply_revive_live,ply_swioffset                DC.B f_invis,f_swalls,f_hideplayer,f_sfastshoot,f_autoanswer                DC.B f_sradius,f_showplayer,f_fastplayer                DC.B f_sreflective,f_absdeadly,f_noabsdeadly,f_got_you                DC.B f_no_got_you,f_noface,f_friendly,f_deadly,f_kompass                DC.B f_karte,f_onejump,f_nowand,f_luft,f_turn180                DC.B f_karte_init,f_shotwarn,f_noshot,f_key,f_turnslow,f_turnfast                DC.B f_nocolor,0,0,0,1,2,3,4                DC.B 0,0,0,0,0                EVENmaster_diatab4: DC.W master_diatab5,master_diatab6,master_diatab7                DC.W master_diatab8,master_diatab9                EVENmaster_diatab5: DC.W 50         ;Original-MIDIMAZE                DC.B f_karte_init,-1,f_karte_init,f_karte,-1,-1                EVENmaster_diatab6: DC.W 50         ;normale Extras                DC.B -1,-1,f_turn180,f_karte_init,f_deadly,f_friendly,f_kompass                DC.B f_sreflective,f_luft,f_showplayer,f_noface,f_shotwarn,f_turnfast                DC.B f_got_you,f_no_got_you,f_absdeadly,f_noabsdeadly                DC.B f_onejump,f_key,f_turnslow,f_karte,-1                EVENmaster_diatab7: DC.W 100        ;alles ist mšglich                DC.B -1,f_invis,f_swalls,f_hideplayer,f_sfastshoot,f_autoanswer                DC.B f_sradius,f_showplayer,f_fastplayer,f_turnfast                DC.B f_sreflective,f_absdeadly,f_noabsdeadly,f_got_you                DC.B f_no_got_you,f_noface,f_friendly,f_deadly,f_kompass                DC.B f_karte,f_onejump,f_nowand,f_luft,f_turn180,f_key                DC.B f_karte_init,f_shotwarn,f_turnslow,f_nocolor,-1,-1                EVENmaster_diatab8: DC.W 100        ;erweiterte Extras                DC.B -1,-1,f_turn180,f_karte_init,f_deadly,f_friendly,f_kompass                DC.B f_hideplayer,f_sfastshoot,f_autoanswer,f_sradius                DC.B f_fastplayer                DC.B f_sreflective,f_luft,f_showplayer,f_noface,f_shotwarn,f_turnfast                DC.B f_got_you,f_no_got_you,f_absdeadly,f_noabsdeadly                DC.B f_onejump,f_key,f_turnslow,f_karte,f_nocolor,-1                EVENmaster_diatab9: DC.W 100        ;MIDICAM                DC.B f_midicam,f_invis,f_hideplayer,f_showplayer,f_kompass                DC.B f_luft,f_karte_init,f_noshot,f_key,-1                DC.B f_midicam,f_invis,f_hideplayer,f_showplayer,f_kompass                DC.B f_luft,f_karte_init,f_noshot,f_key,f_karte,-1,-1                EVENmaster_home:    tst.w   D7                beq.s   master_up1                bsr     ply_d7_out                moveq   #0,D7                bra.s   master_up1master_up:      tst.w   D7                ble.s   master_up1                bsr     ply_d7_outmaster_up0:     subq.w  #1,D7master_up1:     cmp.b   D0,D0                rtsmaster_down:    addq.w  #1,D7                cmp.w   machines_online,D7                bhs.s   master_up0                subq.w  #1,D7                bsr     ply_d7_out                addq.w  #1,D7                bra.s   master_up1master_esc:     moveq   #-1,D0          ;Abbruch                rtsmaster_cr:      moveq   #1,D0           ;Spielstart                rtsmaster_undo:    lea     player_data,A2                lea     player_data2,A0                lea     player_data3,A1master_undo1:   move.b  (A0)+,(A2)+     ;Spielerdaten zurŸckschreiben                cmpa.l  A1,A0                bne.s   master_undo1                bsr     master_redraw   ;Spielerdaten neu ausgeben                cmp.w   D0,D0           ;alles ok!                rtsmd_select:      lea     master_diatab4(PC),A0                add.w   D0,D0                adda.w  D0,A0                adda.w  (A0),A0         ;Zeiger auf vorprogrammierten Spieler                lea     ply_features(A5),A1                clr.l   (A1)                clr.l   4(A1)           ;Alle Spielerdaten lšschen                clr.l   8(A1)                move.w  (A0)+,ply_winscore(A5)                moveq   #2,D1           ;3 Langwšrtermd_select1:     move.b  (A0)+,D0                bmi.s   md_select2                move.l  (A1),D2                bset    D0,D2           ;das Bit setzen                move.l  D2,(A1)                bra.s   md_select1md_select2:     addq.l  #4,A1           ;auf zum nŠchsten Langwort                dbra    D1,md_select1                cmp.w   D0,D0           ;alles ok!                rtsmd_copy:        move.w  #7,-(SP)                trap    #1                addq.l  #2,SPmd_copy_it:     movem.l D0-A6,-(SP)                move.w  D0,D6                bclr    #5,D6                sub.b   #'A',D6         ;Buchstabe zu klein?                bmi.s   md_copy2        ;Ja! => raus                cmp.w   machines_online,D6 ;zu gro§?                bhs.s   md_copy2        ;Ja! => auch raus                move.w  D6,D0                mulu    #ply_size,D0                lea     player_data+ply_reload_t,A0                movea.l A0,A1                adda.w  D0,A0           ;Destination-Daten                move.w  D7,D1                mulu    #ply_size,D1                adda.w  D1,A1           ;Source-Daten                moveq   #ply_name-ply_reload_t-1,D0md_copy1:       move.b  (A1)+,(A0)+                dbra    D0,md_copy1                moveq   #4,D2                add.w   D6,D2                bsr     set_cursor      ;Cursor setzen                move.w  D6,D0                bsr     ply_data_out    ;Spieler invers ausgebenmd_copy2:       movem.l (SP)+,D0-A6                cmp.w   D0,D0           ;alles ok!                rtsmd_copy_all:    moveq   #15,D1                moveq   #'A',D0         ;Spieler auf alle kopierenmd_copy_all1:   bsr.s   md_copy_it                addq.w  #1,D0                dbra    D1,md_copy_all1                cmp.w   D0,D0           ;alles ok!                rtsmd_features:    movem.l ply_features(A5),D1-D3                moveq   #0,D4                bclr    D0,D1                beq.s   md_features1                moveq   #1,D4md_features1:   add.w   D4,D4                bclr    D0,D2                beq.s   md_features2                or.w    #1,D4md_features2:   add.w   D4,D4                bclr    D0,D3                beq.s   md_features3                or.w    #1,D4md_features3:   move.b  md_featur_tab(PC,D4.w),D4                btst    #0,D4                beq.s   md_features4                bset    D0,D3md_features4:   btst    #1,D4                beq.s   md_features5                bset    D0,D2md_features5:   btst    #2,D4                beq.s   md_features6                bset    D0,D1md_features6:   movem.l D1-D3,ply_features(A5)                cmp.w   D0,D0           ;alles ok!                rtsmd_featur_tab:  DC.B 1,5,6,0,0,2,0,0md_winscore:    move.w  ply_winscore(A5),D0                add.w   #10,D0                cmp.w   #999,D0         ;Winscore hochsetzen                bls.s   md_winscore1                moveq   #10,D0md_winscore1:   move.w  D0,ply_winscore(A5)                cmp.w   D0,D0           ;alles ok!                rtsmd_winscrsub:   move.w  ply_winscore(A5),D0                sub.w   #10,D0                bne.s   md_winscore1    ;Winscore runtersetzen                move.w  #990,D0                bra.s   md_winscore1md_team:        move.w  ply_team(A5),D0 ;das Team erhšhen                addq.w  #1,D0                cmp.w   #t_anz,D0                blo.s   md_team1                moveq   #0,D0md_team1:       move.w  D0,ply_team(A5)                cmp.w   D0,D0           ;alles ok!                rtsmd_reload:      move.w  0(A5,D0.w),D1                add.w   #10,D1                cmp.w   #199,D1                bls.s   md_reload1      ;Reload/Regen/etc.-Time                moveq   #0,D1md_reload1:     move.w  D1,0(A5,D0.w)                cmp.w   D0,D0           ;alles ok!                rtsmd_revive:      move.w  ply_revive_live(A5),D0                addq.w  #1,D0                cmp.w   #9,D0                bls.s   md_revive1      ;Revive-lives                moveq   #0,D0md_revive1:     move.w  D0,ply_revive_live(A5)                cmp.w   D0,D0           ;alles ok!                rtsply_d7_out:     moveq   #4,D2                add.w   D7,D2                bsr     set_cursor      ;Cursor setzen                move.w  D7,D0                bra     ply_data_out    ;Spieler invers ausgebenmaster_redraw:  movem.l D0-D2/A0,-(SP)                moveq   #4,D2           ;Zeile 4, Spalte 0                bsr     set_cursor      ;Cursor setzen                moveq   #0,D0           ;Mit Spieler 0 gehts losmaster_redraw1: bsr     ply_data_out                move.w  D0,D1                moveq   #10,D0                bsr     con_out         ;LF ausgeben                move.w  D1,D0                addq.w  #1,D0                cmp.w   machines_online,D0                bne.s   master_redraw1                clr.w   team_flag       ;keine Teams                move.w  machines_online,D1                subq.w  #2,D1                lea     player_data,A0                move.w  ply_team(A0),D0 ;Team des 1.Spielersmaster_redraw3: lea     ply_size(A0),A0                cmp.w   ply_team(A0),D0                dbne    D1,master_redraw3                beq.s   master_redraw4  ;Keine Teams! =>                move.w  #1,team_flag    ;es gibt doch Teams!master_redraw4: movem.l (SP)+,D0-D2/A0                rts                ENDPART                ENDC                >PARTmaster_diatab1: DC.B 'WTLFGVZ'key_table:      DC.B 'iwhfas7qrdngb8435 0~6129#k<>c'                DC.B 'CA'                DC.B $BB,$BC,$BD,$BE,$BF ;F1 bis F5                DC.B $61,27,13  ;UNDO,ESC,RETURN                DC.B $C8,$D0,$C7 ;Cursor hoch, runter, Home                DC.B 0                EVEN                ENDPART                >PART 'Defaults' ;Preise, etc.block_start:f_key_tab:      DC.B $39,$70,$3B,$3C,$3D,$3E,$3F,$40,$41,$42,$43,$44,$72,$13                DC.B $10,$17,$11,$23,$21,$1E                DC.B $1F,$20,$31,$22,$30,$2B                DC.B $4B,$4D    ;Cursortasten                DC.B $2E        ;no Color                DC.B $25        ;Kf_key_tab2:                DS.B 64-(f_key_tab2-f_key_tab)f_pkt_tab:      DC.B 0,0,0,2,2,3,6,15,12,15,5,5,5,25 ;Kostentabelle                DC.B 25,250,40,10,25,25                DC.B 25,35,10,25,10,250                DC.B 0,0        ;Kosten: 1 Pkt                DC.B 75                DC.B 1f_pkt_tab2:                DS.B 64-(f_pkt_tab2-f_pkt_tab)f_bit_tab:      DC.B f_karte    ;SPACE 0 - Karte                DC.B f_turn180  ;0     0                DC.B f_turn180  ;F1    0                DC.B f_karte_init ;F2  2                DC.B f_deadly   ;F3    2                DC.B f_friendly ;F4    5                DC.B f_kompass  ;F5    6                DC.B f_luft     ;F6    15                DC.B f_showplayer ;F7  10                DC.B f_noface   ;F8    15                DC.B f_shotwarn ;F9    5                DC.B f_onejump  ;F10   5                DC.B f_onejump  ;Enter 5                DC.B f_sreflective ;R  25                DC.B f_fastplayer ;q  20                DC.B f_invis    ;I    250                DC.B f_swalls   ;W    40                DC.B f_hideplayer ;H  15                DC.B f_sfastshoot ;F  20                DC.B f_autoanswer ;A  25                DC.B f_sradius  ;S    25                DC.B f_absdeadly ;D   35                DC.B f_noabsdeadly ;N 10                DC.B f_got_you  ;G    25                DC.B f_no_got_you ;B(ack) 10                DC.B f_nowand   ;~    250                DC.B f_turnslow ;langsames Drehen 0                DC.B f_turnfast ;schnelles Drehen 0                DC.B f_nocolor  ;c    75                DC.B f_key      ;der SchlŸssel 1f_bit_tab2:                DS.B 64-(f_bit_tab2-f_bit_tab)block_end:      EVEN                ENDPART                IF master_flag                >PART 'ply_data_out' ;Spielerdaten zu Spieler D0 ausgebenply_data_out:   movem.l D0-A4,-(SP)                lea     rawcon_out(PC),A4                move.w  D0,D1                add.w   #'A',D0         ;Buchstabe des Spielers                jsr     (A4)                lea     player_data,A5  ;Zeiger auf die Daten des Spielers                mulu    #ply_size,D1                adda.w  D1,A5           ;Zeiger auf den Spieler                moveq   #'-',D0                jsr     (A4)                lea     ply_name(A5),A0 ;Zeiger auf den Spielernamen                movem.l D0-D1/A0,-(SP)                moveq   #30,D1ply_data_out1:  moveq   #0,D0                move.b  (A0)+,D0                bne.s   ply_data_out2   ;Nullbyte=Ende                subq.l  #1,A0           ;Zeiger auf 0 zurŸck                moveq   #' ',D0ply_data_out2:  bsr     rawcon_out                dbra    D1,ply_data_out1                movem.l (SP)+,D0-D1/A0                move.w  ply_winscore(A5),D0                bsr     dez_out         ;nštiger Score zum Gewinnen                moveq   #' ',D0                jsr     (A4)                move.w  ply_team(A5),D0                add.w   #'A',D0                jsr     (A4)            ;Teamzuteilung                move.w  ply_reload_t(A5),D0                bsr     num_out         ;Reload-Time                move.w  ply_refresh_t(A5),D0                bsr     num_out         ;Refresh-Time                move.w  ply_regen_t(A5),D0                bsr     num_out         ;Regen-Time                move.w  ply_revive_live(A5),D0                add.b   #'0',D0                jsr     (A4)            ;Revive-Lives                moveq   #' ',D0                jsr     (A4)                move.w  ply_swioffset(A5),D0                bpl.s   ply_data_out3                neg.w   D0                move.w  D0,ply_swioffset(A5)ply_data_out3:  bsr     num_out         ;Zig-Zag-Winkel                move.l  ply_features_(A5),D1                move.l  ply_features_b(A5),D2                move.l  ply_features(A5),D3                moveq   #f_anzahl-1,D4  ;Anzahl der Featuresply_data_out4:  moveq   #'_',D0         ;gibt's nicht                lsr.l   #1,D2                bcc.s   ply_data_out5                moveq   #'k',D0         ;kaufbarply_data_out5:  lsr.l   #1,D1                bcc.s   ply_data_out6                moveq   #'m',D0         ;mšglichply_data_out6:  lsr.l   #1,D3                bcc.s   ply_data_out7                bclr    #5,D0ply_data_out7:  jsr     (A4)                dbra    D4,ply_data_out4                moveq   #13,D0                bsr     con_out         ;CR ausgeben                movem.l (SP)+,D0-A4                rts                ENDPART                ENDC                >PART 'slave_subroutine' ;Der Slaveslave_subroutine:link   A6,#-20                lea     slave_text(PC),A0                bsr     print_line      ;SLAVEslave_loop:     bsr     clr_midi                bsr     clr_conslave_loopb:    move.l  #$010003,-(SP)                trap    #13             ;Zeichen an MIDI?                addq.l  #4,SP                tst.l   D0                beq.s   slave_sub1      ;Nein! =>                bsr     get_midi        ;Zeichen holen                bmi.s   slave_sub1      ;Timeout =>                bsr     put_midi        ;Byte weitersenden                move.w  D0,-4(A6)       ;Zeichen merken                bne     slave_sub9      ;und auswertenslave_sub1:     move.l  #$010002,-(SP)                trap    #13             ;Zeichen an CON?                addq.l  #4,SP                tst.l   D0                beq.s   slave_loopb     ;Nein! =>                move.l  #$020002,-(SP)                trap    #13             ;Zeichen holen                addq.l  #4,SP                swap    D0                cmp.w   #$0832,D0       ;ALT-M                bne.s   slave_sub2                st      maus_or_joy                lea     mouse_on(PC),A0                bra.s   slave_sub3slave_sub2:     cmp.w   #$0824,D0       ;ALT-J                bne.s   slave_sub4                sf      maus_or_joy     ;Joystick                lea     joystick_on(PC),A0slave_sub3:     bsr     print_line      ;Joystick / Maus                bra.s   slave_loopbslave_sub4:     cmp.w   #$0810,D0       ;ALT-Q                bne.s   slave_sub5                move.w  #-1,-12(A6)     ;Quit                bra.s   slave_sub8slave_sub5:     cmp.w   #$0813,D0       ;ALT-R                bne.s   slave_sub6                move.w  #3,-12(A6)      ;Master (mit Test)                bra.s   slave_sub8slave_sub6:     cmp.w   #$082B,D0       ;ALT-~                bne.s   slave_sub7                clr.w   -12(A6)         ;Master (OHNE Test)                bra.s   slave_sub8slave_sub7:     cmp.w   #$081F,D0       ;ALT-S                bne     slave_loopb                move.w  #2,-12(A6)      ;SOLOslave_sub8:     bsr     redraw_small                move.w  -12(A6),D0                unlk    A6                rtsslave_sub9:     bsr     redraw_small                move.w  -4(A6),D0       ;†ber MIDI empfangenes Zeichen holen                cmp.w   #$85,D0         ;Info                bne.s   slave_sub10     ;Nein! =>                lea     info_text(PC),A0                bsr     print_line      ;Infotext                bra     slave_loopslave_sub10:    cmp.w   #$81,D0         ;Reset Scores                bne.s   slave_sub13     ;Nein! =>                moveq   #7,D0                lea     score_table,A0slave_sub11:    clr.l   (A0)+           ;alle Scores lšschen                dbra    D0,slave_sub11                bsr     redraw_small                bsr     set_akt_score   ;Scoreanzeige updaten                bsr     switch_org_scr                bra     slave_loopslave_sub13:    cmp.w   #$80,D0                bne.s   slave_sub14                bsr     get_midi        ;auf die Nummer warten                bmi     slave_loop      ;Timeout =>                move.w  D0,own_number   ;eigene Nummer                addq.w  #1,D0           ;Anzahl+1                bsr     send_midi       ;und auch versenden                bmi     slave_loop      ;Timeout =>                move.w  D0,machines_online ;Gesamtanzahl                bsr     put_midi        ;auch senden                bra     slave_loopslave_sub14:    cmp.w   #$84,D0         ;†bertragung beginnen                bne.s   slave_sub21                bsr     receive_datas   ;Daten empfangen                bmi     slave_loop                clr.w   -(SP)           ;SLAVE                bsr     play_game                addq.l  #2,SP                move.w  D0,D7           ;RŸckgabewert des Spiels                bsr     reset_screen                bsr     exit_joystick                bsr     exit_mouse                tst.w   D7              ;Fehlernummer                bpl.s   slave_sub19     ;kein Fehler =>                lea     time_out(PC),A0 ;MIDI-Ring boo-boo                addq.w  #1,D7                beq.s   slave_sub18a    ;-1  Timeout                lea     terminated(PC),A0                addq.w  #1,D7                beq.s   slave_sub18a    ;-2  Terminated                lea     maze_too_small(PC),A0slave_sub18a:   bsr     print_line      ;-3  Maze too smallslave_sub19:    bsr     set_akt_score                bsr     switch_org_scr                bra     slave_loopslave_sub21:    cmp.w   #$86,D0         ;Names?                bne     slave_loop      ;Nein! =>                bsr     get_midi        ;auf eigene Nummer warten                bmi     slave_loop      ;†bertragungsfehler =>                move.w  D0,own_number   ;eigene Nummer                addq.w  #1,D0           ;Anzahl erhšhen                bsr     send_midi       ;und weitersenden                bmi     slave_loop      ;†bertragungsfehler                move.w  D0,machines_online ;Anzahl aller Rechner                bsr     put_midi        ;auch weitersenden                clr.w   -(SP)           ;kein SOLO-Spieler                bsr.s   name_input      ;Namenseingabe                addq.l  #2,SP                bra     slave_loop                ENDPART                >PART 'name_input' ;Die Namenseingabename_input:     bsr     redraw_desktop                lea     player_data,A0                move.w  own_number,D0                mulu    #ply_size,D0                lea     ply_name(A0,D0.w),A3 ;Zeiger auf den Namenname_input1:    moveq   #0,D7           ;Cursorposition im Namenname_input2:    moveq   #'f',D0                bsr     esc_code        ;Cursor aus                bsr     name_print      ;Namen ausgebenname_input3:    bsr     name_cursor                moveq   #'e',D0                bsr     esc_code        ;Cursor anname_input4:    bsr     check_con       ;Taste gedrŸckt?                beq.s   name_input4     ;Nein! => warten                tst.b   D0              ;ASCII-Code vorhanden?                bne.s   name_input6     ;Nein! => Taste ignorieren                swap    D0                cmp.b   #$47,D0         ;Home?                beq.s   name_input1     ;=> Cursor auf das erste Zeichen                cmp.b   #$4B,D0         ;Cursor links                beq.s   name_input5                cmp.b   #$4D,D0         ;Cursor rechts                bne.s   name_input4     ;unbekannter Scancode =>                tst.b   0(A3,D7.w)                beq.s   name_input4     ;bereits am Ende =>                addq.w  #1,D7                bra.s   name_input3     ;Cursor neu setzenname_input5:    subq.w  #1,D7                bpl.s   name_input3     ;Cursor neu setzen                bra.s   name_input1name_input6:    cmp.b   #13,D0          ;Return?                beq.s   name_input15    ;=> Eingabe zuende                cmp.b   #27,D0          ;ESC?                beq.s   name_input10    ;=> Eingabe lšschen                cmp.b   #127,D0         ;Delete?                beq.s   name_input8     ;=>                cmp.b   #8,D0           ;Backspace?                bne.s   name_input12    ;Nein!                tst.w   D7              ;Position = 0?                beq.s   name_input4     ;dann ignorieren =>                move.w  D7,D0name_input7:    addq.w  #1,D0                move.b  -1(A3,D0.w),-2(A3,D0.w)                bne.s   name_input7                subq.w  #1,D7                bra.s   name_input2     ;Namen neu ausgebenname_input8:    tst.b   0(A3,D7.w)      ;Cursor auf dem Ende?                beq.s   name_input4     ;Ja! => Delete ignorieren                move.w  D7,D0name_input9:    addq.w  #1,D0                move.b  0(A3,D0.w),-1(A3,D0.w)                bne.s   name_input9                bra     name_input2     ;Namen neu ausgebenname_input10:   moveq   #ply_name_len,D0                movea.l A3,A0name_input11:   clr.b   (A0)+           ;Eingabefeld lšschen                dbra    D0,name_input11                bra     name_input1name_input12:   cmp.w   #ply_name_len,D7 ;max.LŠnge erreicht?                beq     name_input4     ;Ja! =>                moveq   #ply_name_len-1,D1name_input13:   cmp.w   D7,D1                beq.s   name_input14                move.b  -1(A3,D1.w),0(A3,D1.w)                subq.w  #1,D1           ;einfŸgen                bra.s   name_input13name_input14:   move.b  D0,0(A3,D7.w)   ;Zeichen merken                addq.w  #1,D7           ;LŠnge+1                bra     name_input2name_input15:   moveq   #'f',D0                bsr     esc_code        ;Cursor aus                bsr     redraw_small                tst.w   4(SP)           ;SOLO?                bne.s   name_input17    ;Ja! => Keine Namen senden!                lea     waiting(PC),A0                bsr     print_line                move.l  #long_timeout,timeout ;langer Timeout                moveq   #0,D1name_input16:   moveq   #0,D0                bsr     send_midi                addq.w  #1,D1                cmp.w   machines_online,D1                blo.s   name_input16                move.l  #short_timeout,timeout ;kurzer Timeout                bsr.s   send_namesname_input17:   lea     all_names(PC),A0                bra     print_line      ;" Names completed"name_print:     lea     name_text(PC),A0                bsr     print_a0        ;"?:"                movea.l A3,A0                bsr     string_out      ;Spielernamen ausgeben                moveq   #'K',D0                bsr     esc_code                moveq   #'Y',D0                bsr     esc_code                moveq   #$20+24,D0                bsr     con_out         ;Y                moveq   #$22+ply_name_len,D0                bsr     con_out         ;X                moveq   #'<',D0                bra     rawcon_outname_cursor:    moveq   #'Y',D0         ;Cursor in den Namen neu setzen                bsr     esc_code                moveq   #$20+24,D0                bsr     con_out         ;Y                moveq   #$22,D0                add.w   D7,D0                bra     con_out         ;X                ENDPART                >PART 'send_names' ;Alle Namen sendensend_names:     movem.l D1-A6,-(SP)                moveq   #$8F,D0         ;Header-Byte senden                bsr     send_midi                bmi.s   send_names3                cmp.w   #$8F,D0         ;Ist's auch wieder angekommen?                bne.s   send_names3     ;Nein! =>                move.w  own_number,D1send_names1:    bsr.s   send_name_adr   ;Adresse des Spielernamens D1 ermittelnsend_names2:    move.b  (A0),D0         ;einen Namen bis zum Nullbyte senden                bsr     put_midi        ;(Nullbyte inklusive)                cmp.b   (A0),D0                bne.s   send_names3     ;Fehler bei der †bertragung                tst.b   (A0)+           ;das Ende erreicht?                bne.s   send_names2     ;Nein! =>                subq.w  #1,D1                bpl.s   send_names4                move.w  machines_online,D1                subq.w  #1,D1send_names4:    bsr.s   send_name_adr   ;Adresse des Spielernamens D1 ermittelnsend_names5:    bsr     get_midi        ;(Nullbyte inklusive)                bmi.s   send_names3     ;Timeout! =>                move.b  D0,(A0)+                bne.s   send_names5     ;Name noch nicht zuende =>                cmp.w   own_number,D1                bne.s   send_names1                moveq   #0,D0           ;Alles ok!                movem.l (SP)+,D1-A6                rtssend_names3:    moveq   #-1,D0          ;Fehler bei der †bertragung                movem.l (SP)+,D1-A6                rts                ENDPART                >PART 'send_name_adr' ;Namen von Spieler D1 ermitteln (nach A0)send_name_adr:  lea     player_data,A0                move.w  D1,D0                mulu    #ply_size,D0                lea     ply_name(A0,D0.w),A0 ;Zeiger auf den Namen                rts                ENDPART                IF master_flag                >PART 'send_datas' ;Datenpaket Ÿber MIDI sendensend_datas:     movem.l D1-A6,-(SP)                bsr     init_maze       ;Maze von Spielerdaten befreien                lea     sending_str(PC),A0                bsr     print_line                bsr     clr_midi        ;MIDI-Ring leeren                moveq   #$83,D0         ;Header-Byte senden                bsr     send_midi                bmi     send_datas11                cmp.b   #$83,D0         ;Ist's auch wieder angekommen?                bne     send_datas11    ;Nein! =>                lea     block_start(PC),A1                lea     block_end(PC),A2send_datas1:    move.b  (A1),D0                bsr     send_midi       ;Byte senden um wieder empfangen                bmi     send_datas11    ;Timeout! =>                cmp.b   (A1)+,D0        ;stimmts noch?                bne     send_datas11    ;Nein! => Fehler                cmpa.l  A2,A1           ;alle Daten eines Spielers gesendet?                blo.s   send_datas1     ;Nein! =>                move.w  team_flag,D0    ;Teams?                bsr     send_midi                cmp.w   team_flag,D0                bne     send_datas11                lea     player_data,A0  ;Datenblock der Spieler senden                moveq   #15,D1          ;Daten von 16 Spielernsend_datas2:    lea     ply_send_start(A0),A1 ;Ab hier wird gesendet                lea     ply_send_ende(A0),A2 ;Bis hier wird gesendetsend_datas3:    move.b  (A1),D0                bsr     send_midi       ;Byte senden um wieder empfangen                bmi     send_datas11    ;Timeout! =>                cmp.b   (A1)+,D0        ;stimmts noch?                bne     send_datas11    ;Nein! => Fehler                cmpa.l  A2,A1           ;alle Daten eines Spielers gesendet?                blo.s   send_datas3     ;Nein! =>                lea     ply_size(A0),A0 ;nŠchster Spieler                dbra    D1,send_datas2                lea     _maze_datas,A0                move.w  #4095,D1                moveq   #0,D0send_datas4:    add.b   (A0)+,D0        ;PrŸfsumme Ÿber das Maze                dbra    D1,send_datas4                move.w  D0,D1                bsr     send_midi       ;die PrŸfsumme rumsenden                cmp.w   D1,D0           ;PrŸfsumme gleich?                bne     send_datas11    ;Fehler in der †bertragung                moveq   #$8F,D0         ;"PrŸfsumme ok?" rumsenden                bsr     send_midi                cmp.w   #$8F,D0         ;war Ÿberall die PrŸfsumme ok?                bne.s   send_datas5     ;Nein! => Maze Ÿbertragen                moveq   #$8A,D0         ;"PrŸfsumme ok!" senden                bsr     send_midi                cmp.w   #$8A,D0                bne     send_datas11    ;Timeout! oder Fehler!                bra.s   send_datas10    ;†bertragung war ok!send_datas5:    cmp.w   #$8E,D0         ;"PrŸfsumme nicht ok!" angekommen?                bne.s   send_datas11    ;Nein! => Fehler oder Timeout! =>                moveq   #$8B,D0         ;"Maze wird Ÿbertragen" senden                bsr     send_midi                cmp.w   #$8B,D0                bne.s   send_datas11    ;Timeout! oder Fehler!                move.w  maze_size,D0    ;Die Mazegrš§e                bsr     send_midi                cmp.w   maze_size,D0                bne.s   send_datas11                moveq   #1,D1                add.w   D0,D1                lsl.w   #6,D1           ;stets ein gepacktes 64*y Maze empfangen                subq.w  #1,D1                lea     _maze_datas,A0send_datas6:    move.b  (A0)+,D0                bsr     send_midi       ;senden und wieder empfangen                bmi.s   send_datas11    ;Timeout =>                dbra    D1,send_datas6  ;schon alle Bytes? Nein! =>                lea     _object_datas,A0                movea.l A0,A1send_datas7:    tst.w   2(A1)                beq.s   send_datas8                adda.w  (A1),A1         ;einmal durch die Objektdaten hangeln                bra.s   send_datas7send_datas8:    move.l  A1,D0                sub.l   A0,D0           ;LŠnge der Objektdaten                move.w  D0,D1                move.w  D0,D2                bsr     send_midi       ;unteres Byte Ÿbertragen                bmi.s   send_datas11    ;=> Fehler                cmp.b   D1,D0                bne.s   send_datas11    ;=> Fehler                lsr.w   #8,D1                move.w  D1,D0                bsr     send_midi       ;oberes Byte Ÿbertragen                bmi.s   send_datas11    ;=> Fehler                cmp.b   D1,D0                bne.s   send_datas11    ;=> Fehlersend_datas9:    move.b  (A0)+,D0                bsr     send_midi                bmi.s   send_datas11    ;Objektdaten senden                dbra    D2,send_datas9send_datas10:   moveq   #0,D0           ;Kein Fehler                bra.s   send_datas12send_datas11:   moveq   #-1,D0          ;†bertragungsfehler!send_datas12:   movem.l (SP)+,D1-A6                rts                ENDPART                ENDC                >PART 'receive_datas' ;Datenpaket Ÿber MIDI empfangenreceive_datas:  movem.l D1-A6,-(SP)                bsr     init_maze       ;Maze von Spielerdaten befreien                lea     receiving_str(PC),A0                bsr     print_line                bsr     get_midi        ;Header holen                cmp.w   #$83,D0         ;Stimmts?                bne     receive_datas10 ;Nein! => Fehler                bsr     put_midi        ;Header weiterreichen                lea     block_start(PC),A1                lea     block_end(PC),A2receive_datas1: bsr     get_midi        ;Byte empfangen                bmi     receive_datas10 ;Timeout =>                bsr     put_midi        ;und Byte weitersenden                move.b  D0,(A1)+        ;stimmts noch?                cmpa.l  A2,A1           ;alle Daten eines Spielers gesendet?                blo.s   receive_datas1  ;Nein! =>                bsr     get_midi                move.w  D0,team_flag    ;Teams?                bmi     receive_datas10                bsr     put_midi                lea     player_data,A0  ;Datenblock der Spieler senden                moveq   #15,D1receive_datas2: lea     ply_send_start(A0),A1 ;Ab hier wird gesendet                lea     ply_send_ende(A0),A2 ;Bis hier wird gesendetreceive_datas3: bsr     get_midi        ;Byte empfangen                bmi     receive_datas10 ;Timeout =>                bsr     put_midi        ;und Byte weitersenden                move.b  D0,(A1)+        ;stimmts noch?                cmpa.l  A2,A1           ;alle Daten eines Spielers gesendet?                blo.s   receive_datas3  ;Nein! =>                lea     ply_size(A0),A0 ;nŠchster Spieler                dbra    D1,receive_datas2                lea     _maze_datas,A0                move.w  #4095,D1                moveq   #0,D0receive_datas4: add.b   (A0)+,D0        ;PrŸfsumme Ÿber das Maze                dbra    D1,receive_datas4                move.w  D0,D1           ;PrŸfsumme merken                bsr     get_midi        ;richtige PrŸfsumme empfangen                move.w  D0,D2           ;die PrŸfsumme merken                bmi     receive_datas10 ;Timeout! =>                bsr     put_midi        ;das Byte gleich weitersenden                bsr     get_midi        ;Frage vom Master:                cmp.w   #$8F,D0         ;"PrŸfsumme ok?"                beq.s   receive_datas5                cmp.w   #$8E,D0         ;"PrŸfsumme nicht ok!"                bne     receive_datas10 ;Fehler oder Timeout! =>receive_datas5: cmp.w   D1,D2           ;die PrŸfsumme des Mazes ist ok?                beq.s   receive_datas6  ;Ja! =>                moveq   #$8E,D0         ;sonst Fehler sendenreceive_datas6: bsr     put_midi        ;und weitermelden                bsr     get_midi        ;Zusammenfassung des Master erwarten                bmi     receive_datas10 ;Timeout! =>                bsr     put_midi        ;gleich weitersenden                cmp.w   #$8A,D0         ;PrŸfsumme ok!                beq     receive_datas9  ;Ja! => Maze wird nicht Ÿbertragen                cmp.w   #$8B,D0         ;Maze soll Ÿbertagen werden?                bne     receive_datas10 ;Fehler! =>                bsr     get_midi                move.w  D0,maze_size    ;Die Maze-Grš§e                bmi.s   receive_datas10 ;Timeout! =>                bsr     put_midi                moveq   #1,D3                add.w   D0,D3           ;Maze-Grš§e + 1                lsl.w   #6,D3           ;stets ein gepacktes 64*y Maze empfangen                subq.w  #1,D3                lea     maze_datas,A0                lea     _maze_datas,A1receive_datas7: bsr     get_midi        ;Byte vom Ring holen                bmi.s   receive_datas10 ;Timeout =>                bsr     put_midi        ;Byte weitersenden                move.b  D0,(A0)+                move.b  D0,(A1)+                dbra    D3,receive_datas7                clr.l   object_datas    ;animierte Objekte lšschen                clr.l   _object_datas                bsr     get_midi        ;Byte vom Ring holen                bmi.s   receive_datas10 ;Timeout =>                move.b  D0,D3                bsr     put_midi        ;Byte weitersenden                bsr     get_midi        ;Byte vom Ring holen                bmi.s   receive_datas10 ;Timeout =>                lsl.w   #8,D3                move.b  D0,D3                bsr     put_midi        ;Byte weitersenden                ror.w   #8,D3                lea     object_datas,A0                lea     _object_datas,A1receive_datas8: bsr     get_midi        ;Byte vom Ring holen                bmi.s   receive_datas10 ;Timeout =>                bsr     put_midi        ;Byte weitersenden                move.b  D0,(A0)+                move.b  D0,(A1)+                dbra    D3,receive_datas8receive_datas9: moveq   #0,D0           ;Alles ok!                bra.s   receive_datas11receive_datas10:moveq   #-1,D0          ;†bertragungsfehler!receive_datas11:movem.l (SP)+,D1-A6                rts                ENDPART                >PART 'print_line' ;String ab A0 in der letzten Zeile ausgebenprint_line:     moveq   #'Y',D0         ;Cursor setzen                bsr     esc_code                moveq   #$20+24,D0                bsr     con_out                moveq   #$20,D0                bsr     con_out                moveq   #' ',D0                bsr     rawcon_out      ;ein Space ausgeben                movea.l A0,A1print_line1:    tst.b   (A1)+                bne.s   print_line1                subq.l  #1,A1print_line2:    cmpi.b  #' ',-(A1)                beq.s   print_line2                addq.l  #1,A1                move.b  (A1),D0                clr.b   (A1)                bsr     string_out                move.b  D0,(A1)                bsr     get_hz200                add.l   #300,D0         ;1.5 Sekunden lang anzeigen                move.l  D0,last_time                moveq   #'K',D0         ;Zeilenrest lšschen                bra     esc_code                ENDPART                >PART 'small_alert' ;String ab A0 mit Abfrage ausgebensmall_alert:    movem.l D1-D2/A0-A2,-(SP)                bsr.s   print_linesmall_alert0:   move.w  #7,-(SP)                trap    #1                addq.l  #2,SP                and.b   #$DF,D0                cmp.b   #'N',D0                beq.s   small_alert1                cmp.b   #'Y',D0                bne.s   small_alert0small_alert1:   cmp.b   #'Y',D0                seq     D0                ext.w   D0                movem.l (SP)+,D1-D2/A0-A2                rts                ENDPART                IF master_flag                >PART 'LoadMaze' ;loadmaze(filename) - neues Maze ladenLoadMaze:       movem.l D1-A6,-(SP)                lea     allg_buffer,A3                clr.w   -(SP)                move.l  60+2(SP),-(SP)  ;Der Filename                move.w  #$3D,-(SP)                trap    #1              ;Fopen()                addq.l  #8,SP                move.w  D0,D3           ;fhandle                bge.s   LoadMaze4                movea.l A3,A1                lea     cant_open_error(PC),A0LoadMaze1:      move.b  (A0)+,(A1)+                bne.s   LoadMaze1                subq.l  #1,A1                movea.l 60+4(SP),A0LoadMaze2:      move.b  (A0)+,(A1)+                bne.s   LoadMaze2                subq.l  #1,A1                lea     cant_opn2_error(PC),A0LoadMaze3:      move.b  (A0)+,(A1)+                bne.s   LoadMaze3                movea.l A3,A0                bsr     print_line      ;File not found!                moveq   #-1,D0                bra     LoadMaze_exitLoadMaze4:      move.l  A3,-(SP)                pea     8192.w          ;gesamte Datei einlesen                move.w  D3,-(SP)                move.w  #$3F,-(SP)                trap    #1              ;Fread()                lea     12(SP),SP                move.l  D0,D6                move.w  D3,-(SP)                move.w  #$3E,-(SP)                trap    #1              ;Fclose()                addq.l  #4,SP                tst.l   D6              ;Lesefehler?                ble     LoadMaze_rderr  ;Ja! => raus                clr.l   object_datas    ;animierte Objekte lšschen                clr.l   _object_datas                move.l  (A3)+,D0                cmp.l   #'äMZE',D0      ;gepacktes Format?                bne     LoadMaze_rderr  ;Ja! =>                move.w  (A3)+,D2        ;Version testen                SWITCH shareware                CASE 1                cmp.w   #2,D2                beq.s   LoadMaze50                ENDS                cmp.w   #1,D2           ;nur 1 oder 2 erlaubt                bne     LoadMaze_illvers ;Header boo-booLoadMaze50:     move.l  (A3)+,random_base                movea.l A3,A0                move.w  D6,D1                subq.w  #1,D1LoadMaze5:      bsr     random          ;Maze dekodieren                eor.w   D0,(A0)+                dbra    D1,LoadMaze5                move.w  (A3)+,maze_size ;Grš§e des MazesLoadMaze_loop:  movem.w (A3)+,D5-D6     ;Segment-Typ, SegmentlŠnge                cmp.w   #5,D5           ;unbekannter Segmenttyp?                bhi.s   LoadMaze_next   ;Segment ignorieren =>                add.w   D5,D5                move.w  LoadMaze_tab(PC,D5.w),D5                jsr     LoadMaze_tab(PC,D5.w)LoadMaze_next:  adda.w  D6,A3                bra.s   LoadMaze_loop                BASE DC.W,LoadMaze_tabLoadMaze_tab:   DC.W LoadMaze_typ0,LoadMaze_typ1,LoadMaze_typ2                DC.W LoadMaze_typ3,LoadMaze_typ4,LoadMaze_typ5                EVENLoadMaze_typ1:  lea     maze_designer,A1 ;Designername                bra.s   LoadMaze_typ01LoadMaze_typ0:  lea     maze_name,A1LoadMaze_typ01: movea.l A3,A0                move.w  D6,D0                bra.s   LoadMaze_typ03LoadMaze_typ02: move.b  (A0)+,(A1)+     ;Namen des Mazes kopierenLoadMaze_typ03: dbra    D0,LoadMaze_typ02                clr.b   (A1)            ;mit Nullbyte abschlie§en                movem.l D0-D2/A0-A2,-(SP)                lea     maze_name,A0                bsr     print_line      ;Mazenamen anzeigen                movem.l (SP)+,D0-D2/A0-A2                rts                     ;Datum und Uhrzeit ignorierenLoadMaze_typ4:  movea.l A3,A0                lea     last_date,A1                move.l  (A0)+,(A1)+     ;Erstellungsdatum                move.l  (A0),(A1)       ;Datum der letzten €nderung                rtsLoadMaze_typ2:  lea     maze_datas,A0                lea     _maze_datas,A2                movea.l A3,A1                move.w  #2047,D0                moveq   #0,D1LoadMaze_typ21: move.b  (A1),D1         ;Mazedaten umkonvertieren                lsr.w   #4,D1                move.b  LoadMaze_typ22(PC,D1.w),(A0)+                move.b  LoadMaze_typ22(PC,D1.w),(A2)+                moveq   #$0F,D1                and.b   (A1)+,D1                move.b  LoadMaze_typ22(PC,D1.w),(A0)+                move.b  LoadMaze_typ22(PC,D1.w),(A2)+                dbra    D0,LoadMaze_typ21                rtsLoadMaze_typ22: DC.B 0,1,2,3,4,5,6,7,-8,-7,-6,-5,-4,-3,-2,-1LoadMaze_typ5:  lea     object_datas,A0 ;Liste der animierten Objekte                lea     _object_datas,A2                movea.l A3,A1                move.w  D6,D0                subq.w  #1,D0LoadMaze_typ51: move.b  (A1),(A0)+      ;Liste Ÿbertragen                move.b  (A1)+,(A2)+                dbra    D0,LoadMaze_typ51                clr.l   (A0)            ;Liste abschlie§en                clr.l   (A2)                rtsLoadMaze_typ3:  addq.l  #4,SP           ;vor hier gibt es keinen Weg zurŸck...                moveq   #0,D0                bra.s   LoadMaze_exitLoadMaze_rderr: lea     read_error(PC),A0                bsr     print_line                moveq   #-2,D0                bra.s   LoadMaze_exitLoadMaze_illvers:lea    mze_err_text1(PC),A0                bsr     print_line      ;Falsche Version                moveq   #-3,D0LoadMaze_exit:  movem.l (SP)+,D1-A6                rts                ENDPART                >PART 'random'  ;GGUBS-Zufallszahl gemŠ§ random_base nach D0;*******************************************************************************;* Zufallszahlen-Algorithmus "GGUBS" (Guter Algorithmus mit sehr langer Periode);* Er ergibt Interger im Bereich von 1 bis 2^31-2                              *;* Die mittlere AusfŸhrungszeit liegt bei 178æs                                *;* Wenn alles stimmt wird RAND(0)=1 bei RAND(1000)=522329230                   *;*******************************************************************************random:         movem.l D2-D6,-(SP)                move.l  random_base,D0                bne.s   random1                moveq   #1,D0           ;Neue Zufallsbasis setzen (Hier stets 1)random1:        move.l  D0,D6                move.l  #127773,D2                add.l   D6,D6                moveq   #0,D4                moveq   #14,D3                move.w  D6,D5                clr.w   D6                swap    D6random2:        add.w   D4,D4                add.w   D5,D5                addx.l  D6,D6                cmp.l   D2,D6                bmi.s   random3                sub.l   D2,D6                addq.w  #1,D4random3:        dbra    D3,random2                move.l  D4,D5                muls    #-2836,D5                mulu    #42591,D4                move.l  D4,D6                add.l   D4,D4                add.l   D6,D4                sub.l   D4,D0                moveq   #4,D4random4:        move.l  D0,D6                lsl.l   #3,D0                sub.l   D6,D0                dbra    D4,random4                add.l   D5,D0                bpl.s   random5                add.l   #$7FFFFFFF,D0random5:        move.l  D0,random_base                movem.l (SP)+,D2-D6                rts                ENDPART                ENDC                >PART '_random' ;_random() - 16Bit-Zufallszahl nach D0_random:        move.w  _random_seed,D0                muls    #6907,D0                add.l   #130253,D0                move.w  D0,_random_seed                rts                ENDPART                >PART '_rnd'    ;Zufallszahl im Wertebereich 0..8(A6) holen_rnd:           movem.w D1-D2,-(SP)                move.w  8(SP),D2                move.l  #$0100,D0                divs    D2,D0                muls    D2,D0                move.w  D0,D1_rnd1:          bsr.s   _random                asr.w   #4,D0                and.l   #$FF,D0                cmp.w   D1,D0                bge.s   _rnd1                divs    D2,D0                swap    D0                movem.w (SP)+,D1-D2                rts                ENDPART                >PART 'init_joystick' ;Joystick aninit_joystick:  move.w  #$22,-(SP)                trap    #14                addq.l  #2,SP                move.l  D0,ikbd_base                movea.l D0,A0                move.l  16(A0),save_mousevec                move.l  24(A0),save_joyvec                move.l  #own_joyvec,24(A0)                move.w  #$15,-(SP)      ;Set joystick interrogation mode                move.l  #$030004,-(SP)                trap    #13             ;Bconout()                addq.l  #6,SP                clr.w   joystick_flag                st      init_joy_flag                rts                ENDPART                >PART 'exit_joystick' ;Joystick ausexit_joystick:  tst.b   init_joy_flag                beq.s   exit_joystick1                sf      init_joy_flag                move.w  #$1A,-(SP)      ;Disable joysticks                move.l  #$030004,-(SP)                trap    #13             ;Bconout(IKBD)                addq.l  #6,SP                movea.l ikbd_base,A0                move.l  save_joyvec,24(A0)                move.l  16(A0),-(SP)                pea     mouse_defaults(PC)                move.w  #1,-(SP)                clr.w   -(SP)                trap    #14             ;Initmous()                lea     12(SP),SPexit_joystick1: rts                ENDPART                >PART 'ask_joystick' ;Joystick in Port B abfragenask_joystick:   movem.l D1-D2/A0-A2,-(SP)                move.w  #$16,-(SP)      ;Joystick interrogation                move.l  #$030004,-(SP)                trap    #13             ;Bconout(IKBD)                addq.l  #6,SPask_joystick1:  tst.w   joystick_flag   ;auf den Joystick warten                beq.s   ask_joystick1                clr.w   joystick_flag   ;das Flag wieder lšschen                moveq   #0,D0                move.b  joystick,D0     ;Port B auslesen                bclr    #7,D0           ;Feuertaste gedrŸckt?                beq.s   ask_joystick2   ;Nein =>                bset    #4,D0           ;Feuertastenbit 7 nach Bit 4ask_joystick2:  movem.l (SP)+,D1-D2/A0-A2                rts                ENDPART                >PART 'own_joyvec' ;eigener Joystickvektorown_joyvec:     tst.b   joystick_flag                bne.s   own_joyvec3                move.b  1(A0),joystick  ;Port B auslesen                st      joystick_flagown_joyvec3:    rts                ENDPART                >PART 'init_mouse' ;Maussteuerung aninit_mouse:     move.w  #$22,-(SP)                trap    #14                addq.l  #2,SP                move.l  D0,ikbd_base                movea.l D0,A0                move.l  16(A0),save_mousevec                move.l  24(A0),save_joyvec                move.l  #own_mousevec,16(A0)                clr.w   mouse_dy                clr.w   mouse_dx                st      init_mouse_flag                rts                ENDPART                >PART 'exit_mouse' ;Maussteuerung ausexit_mouse:     tst.b   init_mouse_flag                beq.s   exit_mouse1                sf      init_mouse_flag                movea.l ikbd_base,A0                move.l  save_mousevec,D0                move.l  D0,16(A0)                move.l  D0,-(SP)        ;Alter Mausvektor                pea     mouse_defaults(PC) ;param-Struct                move.w  #1,-(SP)        ;Maus an, relativer Mode                clr.w   -(SP)           ;Dummy                trap    #14             ;Initmous()                lea     12(SP),SPexit_mouse1:    rtsmouse_defaults: DC.B 0,0,1,1    ;Defaultwerte                ENDPART                >PART 'ask_mouse' ;die Maus abfragenask_mouse:      movem.l D1-D2,-(SP)                moveq   #0,D2           ;umgerechnete Joystickauswertung                move.w  mouse_dx,D1     ;Drehrichtung                move.w  mouse_dy,D0                add.w   D0,mouse_dy2    ;Geschwindigkeit                clr.w   mouse_dy                clr.w   mouse_dx                cmp.w   #5,D1                ble.s   ask_mouse1                or.w    #8,D2           ;Rechts                bra.s   ask_mouse2ask_mouse1:     cmp.w   #-5,D1                bge.s   ask_mouse2                or.w    #4,D2           ;Linksask_mouse2:     cmpi.w  #$FFFB,mouse_button ;rechte Maustaste?                beq.s   ask_mouse3                cmpi.w  #$FFF9,mouse_button ;linke Maustaste?                bne.s   ask_mouse4ask_mouse3:     clr.w   mouse_dy2       ;Maustaste? => keine Geschwindigkeitask_mouse4:     cmpi.w  #100,mouse_dy2                ble.s   ask_mouse5                move.w  #100,mouse_dy2  ;†berlauf verhindern                bra.s   ask_mouse6ask_mouse5:     cmpi.w  #-100,mouse_dy2                bge.s   ask_mouse6                move.w  #-100,mouse_dy2ask_mouse6:     cmpi.w  #20,mouse_dy2                ble.s   ask_mouse7                or.w    #2,D2           ;Unten                bra.s   ask_mouse8ask_mouse7:     cmpi.w  #-20,mouse_dy2                bge.s   ask_mouse8                or.w    #1,D2           ;Obenask_mouse8:     cmpi.w  #$FFFB,mouse_button                beq.s   ask_mouse9                cmpi.w  #$FFFA,mouse_button                bne.s   ask_mouse10ask_mouse9:     or.w    #$10,D2         ;Feuertaste gedrŸcktask_mouse10:    move.w  D2,D0                movem.l (SP)+,D1-D2                rts                ENDPART                >PART 'own_mousevec' ;eigener Mausvektorown_mousevec:   move.l  A1,-(SP)                lea     mouse_button,A1                move.b  (A0)+,D0                ext.w   D0                move.w  D0,(A1)+                move.b  (A0)+,D0                ext.w   D0                add.w   D0,(A1)+                move.b  (A0)+,D0                ext.w   D0                add.w   D0,(A1)+                movea.l (SP)+,A1                rts                ENDPART                >PART 'draw_3d_ply' ;alle Spieler bzw. SchŸsse auf ein Feld im 3D-Maze setzendraw_3d_ply:    link    A6,#-86                clr.w   -16(A6)         ;Anzahl der Objekte auf dem Feld                move.w  12(A6),-(SP)                move.w  10(A6),-(SP)                move.w  8(A6),-(SP)                bsr     get_maze_data   ;erstes Objekt auf dem Feld holen                addq.l  #6,SP                move.w  D0,-14(A6)      ;merken                bra     draw_3d_ply4    ;und testen =>draw_3d_ply1:   move.w  -14(A6),D0      ;Ein Spieler                cmp.w   #16,D0          ;Ein Schu§?                bge.s   draw_3d_ply2    ;Ja! =>                mulu    #ply_size,D0                add.l   #player_data,D0                movea.l D0,A0                move.w  ply_y(A0),-8(A6) ;Y-Koordinate                move.w  ply_x(A0),-10(A6) ;X-Koordinate                move.w  ply_plist(A0),-18(A6) ;Zeiger auf das nŠchste Objekt                bra.s   draw_3d_ply3draw_3d_ply2:   sub.w   #16,D0          ;Ein Schu§                mulu    #ply_size,D0                add.l   #player_data,D0                movea.l D0,A0                move.w  ply_shooty(A0),-8(A6) ;Y-Koordinate                move.w  ply_shootx(A0),-10(A6) ;X-Koordinate                move.w  ply_slist(A0),-18(A6) ;Zeiger auf das nŠchste Objektdraw_3d_ply3:   move.w  -8(A6),D0                sub.w   var_y_koord,D0  ;Koordinate des akt.Spielers                move.w  D0,-2(A6)       ;dY                move.w  -10(A6),D0                sub.w   var_x_koord,D0  ;Koordinate des akt.Spielers                move.w  D0,-4(A6)       ;dX                move.w  var_richtung,-(SP) ;Winkel der Blickrichtung                pea     -4(A6)          ;dX                pea     -2(A6)          ;dY                bsr     sincos                lea     10(SP),SP                move.w  -16(A6),D0                muls    #6,D0                move.w  -2(A6),-82(A6,D0.w) ;dY*COS(Winkel)-dX*SIN(Winkel)                move.w  -4(A6),-80(A6,D0.w) ;dX*COS(Winkel)+dY*SIN(Winkel)                move.w  -14(A6),-78(A6,D0.w) ;Nummer des Objektes                addq.w  #1,-16(A6)      ;Objektanzahl auf dem Feld mitzŠhlen                cmpi.w  #10,-16(A6)     ;schon 10 Objekte?                bhs.s   draw_3d_ply5    ;das reicht! =>                move.w  -18(A6),-14(A6) ;Nummer des nŠchsten Objektesdraw_3d_ply4:   tst.w   -14(A6)         ;Objektliste zuende?                bpl     draw_3d_ply1    ;Nein! =>draw_3d_ply5:   move.w  -16(A6),D0                subq.w  #1,D0                move.w  D0,-20(A6)      ;Anzahl der Objekte auf dem Feld-1                bra.s   draw_3d_ply10draw_3d_ply6:   clr.w   -22(A6)         ;Ab hier: die Liste sortieren                bra.s   draw_3d_ply9draw_3d_ply7:   move.w  -22(A6),D0                muls    #6,D0                add.l   A6,D0                movea.l D0,A0           ;Zeiger auf das 1.Objekt                move.w  -22(A6),D1                addq.w  #1,D1           ;+1                muls    #6,D1                add.l   A6,D1                movea.l D1,A1           ;Zeiger auf das 2.Objekt                move.w  -82(A0),D0      ;Entfernung 1                cmp.w   -82(A1),D0      ;< Entfernung 2?                ble.s   draw_3d_ply8    ;das ist gut =>                movem.w -82(A0),D0-D2                move.w  -82(A1),-82(A0) ;Entfernungen tauschen                move.w  -80(A1),-80(A0) ;Abstand von der Blickrichtung tauschen                move.w  -78(A1),-78(A0) ;Objektnummer tauschen                movem.w D0-D2,-82(A1)draw_3d_ply8:   addq.w  #1,-22(A6)draw_3d_ply9:   move.w  -22(A6),D0                cmp.w   -20(A6),D0                blt.s   draw_3d_ply7                subq.w  #1,-20(A6)      ;Anzahl der Objekte-1draw_3d_ply10:  tst.w   -20(A6)         ;schon alle sortiert?                bgt.s   draw_3d_ply6    ;Nein! =>                bra     draw_3d_ply24   ;Objekte in die Liste Ÿbernehmendraw_3d_ply11:  subq.w  #1,-16(A6)                move.w  -16(A6),D0      ;Zeiger auf das nŠchste Objekt                muls    #6,D0                move.w  -78(A6,D0.w),-14(A6) ;Objektnummer                move.w  -82(A6,D0.w),-2(A6) ;dY*COS(Winkel)-dX*SIN(Winkel)                move.w  -80(A6,D0.w),-4(A6) ;dX*COS(Winkel)+dY*SIN(Winkel)                cmpi.w  #16,-14(A6)     ;ein Schu§?                bge     draw_3d_ply18   ;Ja! =>                move.w  -14(A6),D0                cmp.w   own_number,D0   ;der eigene Spieler?                beq     draw_3d_ply17   ;Ja! => den nicht zeichnen                tst.w   -2(A6)          ;steht der Spieler hinter einem?                bge     draw_3d_ply17   ;=> nicht zeichnen                move.l  #-4000,D0                divs    -2(A6),D0       ;durch die Entfernung Spieler<->Spieler                IF no_protect=0                lea     f_key_tab(PC),A0                lea     serial-f_key_tab(A0),A0                move.l  (A0)+,D2                move.l  (A0),D1                eor.l   D2,D1                swap    D1                cmp.w   #$5A92,D1       ;stimmt die Seriennummer?                beq.s   draw_3d_ply12a  ;Nein! => Spieler maximal gro§...                moveq   #32,D1                sub.w   D0,D1                move.w  D1,D0                ENDCdraw_3d_ply12a: tst.w   D0                bgt.s   draw_3d_ply12                moveq   #1,D0           ;min.Konstantedraw_3d_ply12:  cmp.w   #32,D0                ble.s   draw_3d_ply13                moveq   #32,D0          ;max.Konstantedraw_3d_ply13:  tst.w   screen_rez      ;Farbe?                beq.s   draw_3d_ply14   ;Ja! =>                add.w   D0,D0draw_3d_ply14:  move.w  D0,-6(A6)       ;Y-Koordinate berechnet                move.w  window_width,D1                move.w  -4(A6),D0       ;Abstand von der Blickrichtung                muls    D1,D0                divs    -2(A6),D0       ;Entfernung                sub.w   D0,D1                move.w  D1,-8(A6)       ;A berechnet (A-Y=X)                move.w  D1,D2                add.w   -6(A6),D2                subq.w  #1,D2           ;(A+Y)-1                sub.w   -6(A6),D1       ;(A-Y)=X                bsr     chk_obj_visibl                tst.w   D0                bne     draw_3d_ply17                lea     player_data,A0                move.w  -14(A6),D0      ;Spielernummer                mulu    #ply_size,D0                move.w  ply_richtung(A0,D0.w),D0 ;seine Blickrichtung                sub.w   #128,D0         ;alle Himmelsrichtungen umdrehen                sub.w   var_richtung,D0                move.w  -4(A6),D1       ;Abstand von der Blickrichtung                asl.w   #5,D1                ext.l   D1                divs    -2(A6),D1       ;Entfernung                add.w   D1,D0                lsr.w   #2,D0                and.w   #$3E,D0                lea     face_shape_tab(PC),A0                move.w  0(A0,D0.w),-12(A6) ;Blickrichtungsshape des Spielers                move.w  window_height,D0 ;50 oder 100 (Farbe oder S/W)                addq.w  #1,D0                move.w  word_per_line,D1                asl.w   #8,D1                ext.l   D1                divs    -2(A6),D1       ;Entfernung                sub.w   D1,D0                move.w  D0,-10(A6)      ;Spritegrš§e                lea     player_data,A0                move.w  -14(A6),D0                muls    #ply_size,D0                adda.w  D0,A0                move.w  -14(A6),-(SP)   ;Farbe                tst.w   ply_hitflag(A0) ;Spieler angeschossen?                beq.s   draw_3d_ply16   ;Nein! =>                move.w  ply_gunman(A0),(SP)draw_3d_ply16:  move.w  -6(A6),-(SP)    ;Y                move.w  -10(A6),-(SP)   ;Spritegrš§e                move.w  -8(A6),-(SP)    ;X                move.w  -6(A6),D0                sub.w   D0,(SP)                move.w  -12(A6),-(SP)   ;???                move.w  #2,-(SP)        ;Spieler mit Gesicht darstellen                move.l  ply_features(A0),D0                btst    #f_nocolor,D0   ;keine Farbe?                beq.s   draw_3d_ply1b   ;doch =>                bset    #7,1(SP)        ;Flag fŸr kein Gesichtdraw_3d_ply1b:  btst    #f_noface,D0    ;kein Gesicht?                beq.s   draw_3d_ply1a   ;Doch, doch =>                addq.w  #1,(SP)         ;ohne Gesicht darstellen (als Schu§)draw_3d_ply1a:  bsr     to_draw_list    ;Spieler                lea     12(SP),SPdraw_3d_ply17:  bra     draw_3d_ply24draw_3d_ply18:                subi.w  #16,-14(A6)     ;einen Schu§ darstellen                lea     player_data,A0                move.w  -14(A6),D0      ;Nummer des Schu§es (Spielernummer)                muls    #ply_size,D0                adda.w  D0,A0                move.w  ply_shooty(A0),D0                sub.w   var_y_koord,D0                move.w  D0,-2(A6)       ;dY                move.w  ply_shootx(A0),D0                sub.w   var_x_koord,D0                move.w  D0,-4(A6)       ;dX                move.w  var_richtung,-(SP)                pea     -4(A6)                pea     -2(A6)                bsr     sincos                lea     10(SP),SP                tst.w   -2(A6)          ;Entfernung                bge     draw_3d_ply24   ;Ja! =>                tst.w   -4(A6)          ;Abstand von der Blickrichtung                blt.s   draw_3d_ply19                move.w  -2(A6),D0                neg.w   D0                cmp.w   -4(A6),D0                bge.s   draw_3d_ply20draw_3d_ply19:  tst.w   -4(A6)          ;Abstand von der Blickrichtung                bge     draw_3d_ply24                move.w  -2(A6),D0                cmp.w   -4(A6),D0                bgt     draw_3d_ply24draw_3d_ply20:  move.l  #-1000,D0                divs    -2(A6),D0       ;Entfernung                bgt.s   draw_3d_ply21                moveq   #1,D0draw_3d_ply21:  cmp.w   #32,D0                ble.s   draw_3d_ply22                moveq   #32,D0draw_3d_ply22:  tst.w   screen_rez                beq.s   draw_3d_ply23                add.w   D0,D0draw_3d_ply23:  move.w  D0,-6(A6)       ;Y-Koordinate des Schu§es                move.w  window_width,D1                move.w  -4(A6),D0       ;Abstand von der Blickrichtung                muls    D1,D0                divs    -2(A6),D0       ;Entfernung                sub.w   D0,D1                move.w  D1,-8(A6)                move.w  window_height,D0                addq.w  #1,D0                move.w  word_per_line,D1                asl.w   #8,D1                ext.l   D1                divs    -2(A6),D1       ;Entfernung                sub.w   D1,D0                move.w  D0,-10(A6)                move.w  -8(A6),D2                add.w   -6(A6),D2                subq.w  #1,D2                move.w  -8(A6),D1                sub.w   -6(A6),D1                bsr     chk_obj_visibl                tst.w   D0                bne.s   draw_3d_ply24                move.w  -14(A6),(SP)    ;Farbe                move.w  -6(A6),-(SP)    ;Y                move.w  -10(A6),-(SP)   ;Spritenummer                move.w  -8(A6),-(SP)                move.w  -6(A6),D0                sub.w   D0,(SP)         ;X                clr.w   -(SP)           ;Dummy                move.w  #3,-(SP)        ;Schu§                lea     player_data,A0                move.w  -14(A6),D0                muls    #ply_size,D0                move.l  ply_features(A0,D0.w),D0                btst    #f_nocolor,D0   ;keine Farbe?                beq.s   draw_3d_ply230  ;doch =>                bset    #7,1(SP)        ;Flag fŸr kein Gesichtdraw_3d_ply230: bsr     to_draw_list    ;in die Liste Ÿbernehmen                lea     10(SP),SPdraw_3d_ply24:  tst.w   -16(A6)         ;alle Objekte gesetzt?                bgt     draw_3d_ply11   ;Nein! =>                unlk    A6                rts                ENDPART                >PART 'make_draw_list'make_draw_list: link    A6,#-6                move.w  8(A6),var_y_koord ;Y                move.w  10(A6),var_x_koord ;X                move.w  12(A6),var_richtung ;Richtung                move.w  12(A6),D0                lsr.w   #5,D0                and.w   #7,D0                move.w  D0,-2(A6)       ;0-7: Richtung                lea     richtung_table(PC),A0                mulu    #14,D0                adda.w  D0,A0                move.w  12(A6),-(SP)    ;22: Richtung                move.w  12(A0),-(SP)    ;20: ???                move.w  6(A0),-(SP)     ;18: ???                move.w  4(A0),-(SP)     ;16: ???                move.w  2(A0),-(SP)     ;14: ???                move.w  0(A0),-(SP)     ;12: ???                move.w  10(A6),-(SP)    ;10: X                clr.b   (SP)                move.w  8(A6),-(SP)     ; 8: Y                clr.b   (SP)                bsr     dm_calc_blick   ;Hier wird nur gerechnet!                lea     16(SP),SP                bsr     set_all_player  ;alle Spieler neu setzen                move.w  -2(A6),D0                move.w  D0,-(SP)                andi.w  #1,(SP)         ;Diagonal-Flag                lea     richtung_table(PC),A0                mulu    #14,D0                adda.w  D0,A0                move.w  12(A0),-(SP)                move.w  10(A0),-(SP)                move.w  8(A0),-(SP)                move.w  10(A6),-(SP)    ;X                move.w  8(A6),-(SP)     ;Y                bsr.s   draw_mazes_d                lea     12(SP),SP                unlk    A6                rts                ENDPART                >PART 'draw_mazes_d'draw_mazes_d:   link    A6,#-8                movem.l D3-D7,-(SP)                clr.w   table_size                clr.w   draw_elem_count                move.w  8(A6),D0        ;Y                asr.w   #7,D0                or.w    #1,D0           ;X-Koordinate im Maze                move.w  10(A6),D7       ;X                asr.w   #7,D7                or.w    #1,D7           ;Y-Koordinate im Maze                tst.w   16(A6)          ;12(A0) - Blick nach NO,O,SW,W?                bne.s   draw_mazes_d1   ;Ja! =>                exg     D0,D7           ;Koordinaten vertauschendraw_mazes_d1:  move.w  D0,-8(A6)                moveq   #7,D5           ;Sichtweite (von hinten angefangen)draw_mazes_d3:  moveq   #7,D4           ;Breite des Sichtfensters                move.w  -8(A6),D6draw_mazes_d4:  move.w  16(A6),-(SP)    ;12(A0) - dir                move.w  D6,-(SP)        ;X oder Y                move.w  D7,-(SP)        ;Y oder X                bsr     draw_3d_ply     ;Spieler und SchŸsse auf das Feld setzen                addq.l  #6,SP                sub.w   14(A6),D6       ;10(A0)                move.w  16(A6),-(SP)    ;12(A0)                move.w  D6,-(SP)                move.w  D7,-(SP)                bsr     get_maze_data                addq.l  #6,SP                bmi.s   draw_mazes_d5   ;Eine Wand? Nein! =>                move.w  16(A6),D1                subq.w  #2,D0           ;eine invisible Wand?                beq.s   draw_mazes_d5   ;Ja! =>                bmi.s   draw_mazes_d4a  ;normale Wand =>                or.w    #2,D1draw_mazes_d4a: move.w  18(A6),D0                eori.w  #1,D0                move.w  D0,(SP)                move.w  D1,-(SP)        ;die Farbe!                move.w  D4,-(SP)                move.w  D5,-(SP)                addq.w  #1,(SP)                move.w  D4,-(SP)                move.w  D5,-(SP)                bsr     draw_mazes_f                lea     10(SP),SP                tst.w   D0                bne.s   draw_mazes_d6draw_mazes_d5:  bsr     check_full_obj                tst.w   D0                bne.s   draw_mazes_d6                sub.w   14(A6),D6                dbra    D4,draw_mazes_d4draw_mazes_d6:  moveq   #8,D4                move.w  -8(A6),D6                add.w   14(A6),D6draw_mazes_d7:  move.w  16(A6),-(SP)                move.w  D6,-(SP)                move.w  D7,-(SP)                bsr     get_maze_data                addq.l  #6,SP                bmi.s   draw_mazes_d8   ;Eine Wand? Nein! =>                move.w  16(A6),D1       ;die Farbe!                subq.w  #2,D0           ;eine invisible Wand?                beq.s   draw_mazes_d8   ;Ja! =>                bmi.s   draw_mazes_d7a  ;normale Wand =>                or.w    #2,D1draw_mazes_d7a: move.w  18(A6),(SP)     ;die Farbe!                move.w  D1,-(SP)                move.w  D4,-(SP)                move.w  D5,-(SP)                addq.w  #1,(SP)                move.w  D4,-(SP)                move.w  D5,-(SP)                bsr     draw_mazes_f                lea     10(SP),SP                tst.w   D0                bne.s   draw_mazes_d9draw_mazes_d8:  bsr     check_full_obj                tst.w   D0                bne.s   draw_mazes_d9                cmp.w   #16,D4                beq.s   draw_mazes_d9                add.w   14(A6),D6                move.w  16(A6),-(SP)    ;dir                move.w  D6,-(SP)        ;X oder Y                move.w  D7,-(SP)        ;Y oder X                bsr     draw_3d_ply     ;Spieler und SchŸsse auf das Feld setzen                addq.l  #6,SP                add.w   14(A6),D6                addq.w  #1,D4                bra.s   draw_mazes_d7draw_mazes_d9:  add.w   12(A6),D7                move.w  -8(A6),D6                moveq   #7,D4draw_mazes_d10: move.w  16(A6),-(SP)                move.w  D6,-(SP)                move.w  D7,-(SP)                bsr     get_maze_data                addq.l  #6,SP                bmi.s   draw_mazes_d11  ;eine Wand? Nein! =>                move.w  16(A6),D1                subq.w  #2,D0           ;eine invisible Wand?                beq.s   draw_mazes_d11  ;Ja! =>                bmi.s   draw_mazes_d10a ;normale Wand =>                or.w    #2,D1draw_mazes_d10a:move.w  18(A6),D0                eori.w  #1,D0                move.w  D0,(SP)                eori.w  #1,D1           ;die Farbe!                move.w  D1,-(SP)                move.w  D4,-(SP)                addq.w  #1,(SP)                move.w  D5,-(SP)                move.w  D4,-(SP)                move.w  D5,-(SP)                bsr     draw_mazes_f                lea     10(SP),SP                tst.w   D0                bne.s   draw_mazes_d13draw_mazes_d11: bsr     check_full_obj                tst.w   D0                bne.s   draw_mazes_d13                move.w  14(A6),D0                add.w   14(A6),D0                sub.w   D0,D6                dbra    D4,draw_mazes_d10draw_mazes_d13: move.w  -8(A6),D6                add.w   14(A6),D6                add.w   14(A6),D6                moveq   #8,D4draw_mazes_d14: move.w  16(A6),-(SP)                move.w  D6,-(SP)                move.w  D7,-(SP)                bsr     get_maze_data                addq.l  #6,SP                bmi.s   draw_mazes_d15  ;Eine Wand? Nein! =>                move.w  16(A6),D1                subq.w  #2,D0           ;eine invisible Wand?                beq.s   draw_mazes_d15  ;Ja! =>                bmi.s   draw_mazes_d14a ;normale Wand =>                or.w    #2,D1draw_mazes_d14a:move.w  18(A6),(SP)                eori.w  #1,D1           ;die Farbe                move.w  D1,-(SP)                move.w  D4,-(SP)                addq.w  #1,(SP)                move.w  D5,-(SP)                move.w  D4,-(SP)                move.w  D5,-(SP)                bsr.s   draw_mazes_f                lea     10(SP),SP                tst.w   D0                bne.s   draw_mazes_d17draw_mazes_d15: bsr     check_full_obj                tst.w   D0                bne.s   draw_mazes_d17                move.w  14(A6),D0                add.w   D0,D0                add.w   D0,D6                addq.w  #1,D4                cmp.w   #16,D4                blt.s   draw_mazes_d14draw_mazes_d17: add.w   12(A6),D7                bsr     check_full_obj                tst.w   D0                bne.s   draw_mazes_d19                dbra    D5,draw_mazes_d3draw_mazes_d19: tst.l   (SP)+                movem.l (SP)+,D4-D7                unlk    A6                rts                ENDPART                >PART 'draw_mazes_f'draw_mazes_f:   link    A6,#-12                lea     calc_tab,A0                movem.w 8(A6),D0-D1                add.w   D0,D1                asl.w   #4,D0           ;D0 mal 17                add.w   D1,D0                add.w   D0,D0                add.w   D0,D0                move.w  0(A0,D0.w),-2(A6)                move.w  2(A0,D0.w),-4(A6)                movem.w 12(A6),D0-D1                add.w   D0,D1                asl.w   #4,D0           ;D0 mal 17                add.w   D1,D0                add.w   D0,D0                add.w   D0,D0                move.w  0(A0,D0.w),-6(A6)                move.w  2(A0,D0.w),-8(A6)                pea     -8(A6)                pea     -6(A6)                pea     -4(A6)                pea     -2(A6)                bsr     L08DD                lea     16(SP),SP                tst.w   D0              ;Wand nicht zeichnen?                beq.s   draw_mazes_f1   ;genau =>                lea     -4(A6),A1       ;H1                lea     -2(A6),A0       ;X1                bsr     calc_to_koord   ;in Koordinaten umrechnen                lea     -8(A6),A1       ;H2                lea     -6(A6),A0       ;X2                bsr     calc_to_koord   ;in Koordinaten umrechnen                move.w  18(A6),-(SP)    ;Helligkeit der Wand                move.w  16(A6),-(SP)    ;Farbe                move.w  -8(A6),-(SP)    ;H2                move.w  -6(A6),-(SP)    ;X2                move.w  -4(A6),-(SP)    ;H1                move.w  -2(A6),-(SP)    ;X1                bsr.s   set_wand                lea     12(SP),SP                bra.s   draw_mazes_f2draw_mazes_f1:  moveq   #1,D0           ;Wand wurde nicht gezeichnetdraw_mazes_f2:  unlk    A6                rts                ENDPART                >PART 'set_wand'set_wand:       link    A6,#-10                move.w  8(A6),D0                move.w  12(A6),D1                cmp.w   D1,D0                bgt.s   set_wand1                exg     D0,D1set_wand1:      movem.w D0-D1,-6(A6)                tst.w   18(A6)                beq.s   set_wand4                move.w  -6(A6),D2                moveq   #0,D1                bsr.s   chk_obj_visibl                tst.w   D0                beq.s   set_wand5                moveq   #1,D0                bra.s   set_wand7set_wand4:      move.w  window_width,D2                add.w   D2,D2                move.w  -4(A6),D1                bsr.s   chk_obj_visibl                tst.w   D0                beq.s   set_wand5                moveq   #1,D0                bra.s   set_wand7set_wand5:      move.w  -6(A6),D2                move.w  -4(A6),D1                bsr.s   chk_obj_visibl                tst.w   D0                bne.s   set_wand6                move.w  -6(A6),-(SP)                move.w  -4(A6),-(SP)                bsr     to_obj_table                addq.l  #4,SP                move.w  14(A6),-(SP)    ;H2                move.w  12(A6),-(SP)    ;X2                move.w  10(A6),-(SP)    ;H1                move.w  8(A6),-(SP)     ;X1                move.w  16(A6),-(SP)    ;Farbe                move.w  #1,-(SP)        ;Nummer fŸr Typ: WAND !!!                bsr     to_draw_list    ;Wand                lea     12(SP),SPset_wand6:      moveq   #0,D0set_wand7:      unlk    A6                rts                ENDPART                >PART 'chk_obj_visibl' ;testen, ob das Objekt (X1,X2) sichtbar ist (D0<>0)chk_obj_visibl: move.w  window_width,D0 ;D1:X-links, D2:X-rechts                add.w   D0,D0                subq.w  #1,D0           ;maximale rechte Koordinate merken                tst.w   D2              ;rechte X-Koordinate negativ?                bge.s   chk_obj_visibl1 ;Nein! =>                moveq   #1,D0           ;nicht sichtbar                rtschk_obj_visibl1:cmp.w   D0,D1           ;linke X-Koordinate kleiner als Xmax                ble.s   chk_obj_visibl2 ;Ja! =>                moveq   #1,D0           ;nicht sichtbar                rtschk_obj_visibl2:tst.w   D1              ;X-links negativ?                bpl.s   chk_obj_visibl3 ;Nein! =>                moveq   #0,D1           ;auf das Window clippenchk_obj_visibl3:cmp.w   D0,D2           ;X-rechts zu gro§?                ble.s   chk_obj_visibl4 ;Nein! =>                move.w  D0,D2           ;auf das Window clippenchk_obj_visibl4:moveq   #0,D0           ;bei Objekt 0 geht die Suche los                lea     table_list,A0   ;Zeiger auf die Objekttabelle                bra.s   chk_obj_visibl7chk_obj_visibl5:cmp.w   (A0),D1         ;linke Koordinate zu klein?                blt.s   chk_obj_visibl6 ;Ja! => weiter beim nŠchsten Eintrag                cmp.w   2(A0),D2        ;rechte Koordinate zu gro§?                bgt.s   chk_obj_visibl6 ;Ja! => weiter beim nŠchsten Eintrag                moveq   #1,D0           ;nicht sichtbar                rtschk_obj_visibl6:addq.l  #4,A0           ;Tabellenindex hochsetzen                addq.w  #1,D0           ;Objektnummer erhšhenchk_obj_visibl7:cmp.w   table_size,D0   ;Tabellenende erreicht?                blo.s   chk_obj_visibl5 ;Nein! => weiter suchen                moveq   #0,D0           ;Objekt ist sichtbar                rts                ENDPART                >PART 'check_full_obj' ;tut durch einen Bug gar nixcheck_full_obj: cmpi.w  #1,table_size   ;nur ein Element in der Liste?                bne.s   check_full_obj1 ;Nein! => raus                tst.w   table_list      ;erstes Element startet bei X = 0?                bne.s   check_full_obj1 ;Nein! =>                move.w  window_width,D0                add.w   D0,D0           ;!!! Fehler (Clipping: WW*2-1!!!)                cmp.w   table_list+2,D0 ;und endet bei X = Windowbreite                beq.s   check_full_obj2 ;Ja! =>check_full_obj1:moveq   #0,D0           ;es ist mehr sichtbar                rtscheck_full_obj2:moveq   #1,D0           ;Screen ist voll!!!                rts                ENDPART                >PART 'hunt_obj_pos'hunt_obj_pos:   move.w  D0,D2           ;Tabellenstartposition                add.w   D2,D2                add.w   D2,D2                lea     table_list,A0   ;Zeiger auf die Tabelle                adda.w  D2,A0                move.w  hacker_flag,D2  ;alten Eintrag nicht splitten (wenn kein Hacker...)                bra.s   hunt_obj_pos4hunt_obj_pos1:  cmp.w   (A0)+,D1        ;Koordinate kleiner?                ble.s   hunt_obj_pos2   ;Ja! => dann bereits einen Eintrag zu weit                cmp.w   (A0)+,D1        ;Koordinate zu gro§?                bgt.s   hunt_obj_pos3   ;Ja! => weiter suchen                moveq   #1,D2           ;Eintrag splittenhunt_obj_pos2:  rtshunt_obj_pos3:  addq.w  #1,D0hunt_obj_pos4:  cmp.w   table_size,D0   ;Tabellenende erreicht?                blo.s   hunt_obj_pos1   ;Nein! => weiter                rts                ENDPART                >PART 'to_obj_table' ;Objekt (Wand) in die Liste aufnehmento_obj_table:   movea.l SP,A0                movem.w D0-D7,-(SP)                movem.w 4(A0),D3-D4     ;linke und rechte X-Koordinate                moveq   #0,D0           ;ab Tabellenanfang suchen                move.w  D3,D1           ;linke X-Koordinate                bsr.s   hunt_obj_pos    ;in der Tabelle suchen                move.w  D0,D5           ;gefundene min.Obj-Position merken                move.w  D2,D6           ;Split-Flag (1=Eintrag splitten)                move.w  D4,D1           ;neue rechte X-Koordinate                bsr.s   hunt_obj_pos    ;in der Tabelle suchen                move.w  D0,D7           ;gefundene max.Obj-Position merken                tst.w   D6              ;hinter einer existierenden Wand?                beq.s   to_obj_table1   ;Nein! =>                move.w  D5,D0                add.w   D0,D0                add.w   D0,D0                lea     table_list,A0                move.w  0(A0,D0.w),D3   ;neue linke X-Koordinateto_obj_table1:                tst.w   D2              ;Splittet die rechte Koordinate auch was?                beq.s   to_obj_table2   ;Nein! =>                move.w  D7,D0                add.w   D0,D0                add.w   D0,D0                lea     table_list,A0                move.w  2(A0,D0.w),D4   ;neue rechte X-Koordinate                move.w  D7,D1                subq.w  #1,D1                move.w  D5,D0                bsr.s   ins_obj_table                bra.s   to_obj_table3to_obj_table2:  move.w  D7,D1                subq.w  #1,D1                move.w  D5,D0                addq.w  #1,D0                bsr.s   ins_obj_tableto_obj_table3:  move.w  D5,D0                add.w   D0,D0           ;Nummer des Eintrags                add.w   D0,D0                lea     table_list,A0                movem.w D3-D4,0(A0,D0.w) ;linke/rechte X-Koordinate                movem.w (SP)+,D0-D7                rts                ENDPART                >PART 'ins_obj_table'ins_obj_table:  movem.w D2-D3,-(SP)                move.w  D0,D2           ;unterer Index                move.w  D1,D3           ;oberer Index                lea     table_list,A0                move.w  D3,D0                sub.w   D2,D0                addq.w  #1,D0                beq.s   ins_obj_table6  ;nix => raus                blt.s   ins_obj_table3  ;Eintrag einfŸgen =>                addq.w  #1,D3                move.w  D2,D0                add.w   D0,D0                add.w   D0,D0                lea     0(A0,D0.w),A1   ;Zeiger auf den unteren Eintrag                move.w  D3,D0                add.w   D0,D0                add.w   D0,D0                adda.w  D0,A0           ;Zeiger auf den oberen Eintrag                bra.s   ins_obj_table2ins_obj_table1: move.l  (A0)+,(A1)+     ;EintrŠge entfernen                addq.w  #1,D2                addq.w  #1,D3ins_obj_table2: cmp.w   table_size,D3   ;Tabellenende erreicht?                blt.s   ins_obj_table1  ;Nein! =>                move.w  D2,table_size                movem.w (SP)+,D2-D3                rtsins_obj_table3: move.w  table_size,D1   ;letzten Eintrag + 1 holen                move.w  D1,D0                add.w   D0,D0                add.w   D0,D0                lea     0(A0,D0.w),A0   ;Ptr auf das Ende der Liste                bra.s   ins_obj_table5ins_obj_table4: move.l  -(A0),4(A0)     ;Liste nach oben schieben                subq.w  #1,D1ins_obj_table5: cmp.w   D2,D1                bhs.s   ins_obj_table4                addq.w  #1,table_size   ;ein Eintrag mehrins_obj_table6: movem.w (SP)+,D2-D3                rts                ENDPART                >PART 'L08C3'L08C3:          link    A6,#0                movem.l D3-D7,-(SP)                move.w  8(A6),D6                sub.w   12(A6),D6                move.w  14(A6),D7                sub.w   10(A6),D7                move.w  8(A6),D0                muls    D7,D0                move.l  D0,D4                move.w  10(A6),D0                muls    D6,D0                add.l   D0,D4                cmpi.w  #1,16(A6)                bne.s   L08C5                move.w  D7,D5                add.w   D6,D5                beq.s   L08C4                move.l  D4,D0                divs    D5,D0                ext.l   D0                movea.l 22(A6),A1                move.w  D0,(A1)                movea.l 18(A6),A1                move.w  D0,(A1)                moveq   #1,D0                bra.s   L08C9L08C4:          bra.s   L08C8L08C5:          cmpi.w  #-1,16(A6)                bne.s   L08C7                move.w  D6,D5                sub.w   D7,D5                beq.s   L08C6                move.l  D4,D0                divs    D5,D0                ext.l   D0                movea.l 22(A6),A1                move.w  D0,(A1)                neg.w   D0                movea.l 18(A6),A1                move.w  D0,(A1)                moveq   #1,D0                bra.s   L08C9L08C6:          bra.s   L08C8L08C7:          tst.w   D7                beq.s   L08C8                move.l  D4,D0                divs    D7,D0                ext.l   D0                movea.l 18(A6),A1                move.w  D0,(A1)                moveq   #1,D0                bra.s   L08C9L08C8:          clr.w   D0L08C9:          tst.l   (SP)+                movem.l (SP)+,D4-D7                unlk    A6                rts                ENDPART                >PART 'L08CA'L08CA:          link    A6,#-8                move.w  8(A6),D0                cmp.w   16(A6),D0                bgt.s   L08CE                move.w  8(A6),D0                cmp.w   12(A6),D0                bgt.s   L08CB                move.w  12(A6),D0                cmp.w   16(A6),D0                ble.s   L08CCL08CB:          clr.w   D0                bra.s   L08CDL08CC:          moveq   #1,D0L08CD:          bra.s   L08D1L08CE:          move.w  16(A6),D0                cmp.w   12(A6),D0                bgt.s   L08CF                move.w  12(A6),D0                cmp.w   8(A6),D0                ble.s   L08D0L08CF:          clr.w   D0                bra.s   L08D1L08D0:          moveq   #1,D0L08D1:          move.w  D0,-2(A6)                move.w  10(A6),D0                cmp.w   18(A6),D0                bgt.s   L08D5                move.w  10(A6),D0                cmp.w   14(A6),D0                bgt.s   L08D2                move.w  14(A6),D0                cmp.w   18(A6),D0                ble.s   L08D3L08D2:          clr.w   D0                bra.s   L08D4L08D3:          moveq   #1,D0L08D4:          bra.s   L08D8L08D5:          move.w  18(A6),D0                cmp.w   14(A6),D0                bgt.s   L08D6                move.w  14(A6),D0                cmp.w   10(A6),D0                ble.s   L08D7L08D6:          clr.w   D0                bra.s   L08D8L08D7:          moveq   #1,D0L08D8:          move.w  D0,-4(A6)                tst.w   -2(A6)                beq.s   L08D9                tst.w   -4(A6)                bne.s   L08DAL08D9:          clr.w   D0                bra.s   L08DBL08DA:          moveq   #1,D0L08DB:          unlk    A6                rts                ENDPART                >PART 'L08DD'L08DD:          link    A6,#-14                movea.l 12(A6),A0                tst.w   (A0)                blt.s   L08E0                movea.l 8(A6),A0                move.w  (A0),D0                movea.l 12(A6),A1                move.w  (A1),D1                neg.w   D1                cmp.w   D1,D0                blt.s   L08DE                clr.w   D0                bra.s   L08DFL08DE:          moveq   #1,D0L08DF:          bra.s   L08E2L08E0:          movea.l 8(A6),A0                move.w  (A0),D0                movea.l 12(A6),A1                move.w  (A1),D1                cmp.w   D1,D0                blt.s   L08E1                clr.w   D0                bra.s   L08E2L08E1:          moveq   #1,D0L08E2:          move.w  D0,-2(A6)                movea.l 20(A6),A0                tst.w   (A0)                blt.s   L08E5                movea.l 16(A6),A0                move.w  (A0),D0                movea.l 20(A6),A1                move.w  (A1),D1                neg.w   D1                cmp.w   D1,D0                blt.s   L08E3                clr.w   D0                bra.s   L08E4L08E3:          moveq   #1,D0L08E4:          bra.s   L08E7L08E5:          movea.l 16(A6),A0                move.w  (A0),D0                movea.l 20(A6),A1                move.w  (A1),D1                cmp.w   D1,D0                blt.s   L08E6                clr.w   D0                bra.s   L08E7L08E6:          moveq   #1,D0L08E7:          move.w  D0,-4(A6)                tst.w   -2(A6)                beq.s   L08E8                tst.w   -4(A6)                beq.s   L08E8                moveq   #1,D0                bra     L08F5L08E8:          tst.w   -2(A6)                bne     L08F1                tst.w   -4(A6)                bne     L08F1                movea.l 12(A6),A0                move.w  (A0),D0                movea.l 20(A6),A1                muls    (A1),D0                blt.s   L08E9                clr.w   D0                bra     L08F5L08E9:          move.l  A6,(SP)                subq.l  #8,(SP)                move.l  A6,-(SP)                subq.l  #6,(SP)                clr.w   -(SP)                movea.l 20(A6),A0                move.w  (A0),-(SP)                movea.l 16(A6),A0                move.w  (A0),-(SP)                movea.l 12(A6),A0                move.w  (A0),-(SP)                movea.l 8(A6),A0                move.w  (A0),-(SP)                bsr     L08C3                lea     14(SP),SP                tst.w   D0                beq     L08EF                tst.w   -6(A6)                blt.s   L08EA                clr.w   D0                bra     L08F5L08EA:          movea.l 12(A6),A0                move.w  (A0),D0                movea.l 20(A6),A1                move.w  (A1),D1                cmp.w   D1,D0                ble.s   L08EB                movea.l 8(A6),A0                move.w  (A0),-10(A6)                movea.l 16(A6),A1                move.w  (A1),(A0)                move.w  -10(A6),(A1)                movea.l 12(A6),A0                move.w  (A0),-10(A6)                movea.l 20(A6),A1                move.w  (A1),(A0)                move.w  -10(A6),(A1)L08EB:          move.l  A6,(SP)                subq.l  #8,(SP)                move.l  A6,-(SP)                subq.l  #6,(SP)                move.w  #1,-(SP)                movea.l 20(A6),A0                move.w  (A0),-(SP)                movea.l 16(A6),A0                move.w  (A0),-(SP)                movea.l 12(A6),A0                move.w  (A0),-(SP)                movea.l 8(A6),A0                move.w  (A0),-(SP)                bsr     L08C3                lea     14(SP),SP                tst.w   D0                beq.s   L08EC                movea.l 8(A6),A0                move.w  -6(A6),(A0)                movea.l 12(A6),A0                move.w  -8(A6),(A0)L08EC:          move.l  A6,(SP)                subq.l  #8,(SP)                move.l  A6,-(SP)                subq.l  #6,(SP)                move.w  #-1,-(SP)                movea.l 20(A6),A0                move.w  (A0),-(SP)                movea.l 16(A6),A0                move.w  (A0),-(SP)                movea.l 12(A6),A0                move.w  (A0),-(SP)                movea.l 8(A6),A0                move.w  (A0),-(SP)                bsr     L08C3                lea     14(SP),SP                tst.w   D0                beq.s   L08ED                movea.l 16(A6),A0                move.w  -6(A6),(A0)                movea.l 20(A6),A0                move.w  -8(A6),(A0)L08ED:          moveq   #1,D0                bra     L08F5L08EF:          clr.w   D0                bra     L08F5L08F1:          tst.w   -4(A6)                beq.s   L08F2                movea.l 8(A6),A0                move.w  (A0),-10(A6)                movea.l 16(A6),A1                move.w  (A1),(A0)                movea.l 16(A6),A0                move.w  -10(A6),(A0)                movea.l 12(A6),A0                move.w  (A0),-10(A6)                movea.l 20(A6),A1                move.w  (A1),(A0)                move.w  -10(A6),(A1)L08F2:          move.l  A6,(SP)                subq.l  #8,(SP)                move.l  A6,-(SP)                subq.l  #6,(SP)                move.w  #1,-(SP)                movea.l 20(A6),A0                move.w  (A0),-(SP)                movea.l 16(A6),A0                move.w  (A0),-(SP)                movea.l 12(A6),A0                move.w  (A0),-(SP)                movea.l 8(A6),A0                move.w  (A0),-(SP)                bsr     L08C3                lea     14(SP),SP                tst.w   D0                beq.s   L08F3                movea.l 20(A6),A0                move.w  (A0),(SP)                movea.l 16(A6),A0                move.w  (A0),-(SP)                move.w  -8(A6),-(SP)                move.w  -6(A6),-(SP)                movea.l 12(A6),A0                move.w  (A0),-(SP)                movea.l 8(A6),A0                move.w  (A0),-(SP)                bsr     L08CA                lea     10(SP),SP                tst.w   D0                beq.s   L08F3                movea.l 16(A6),A0                move.w  -6(A6),(A0)                movea.l 20(A6),A0                move.w  -8(A6),(A0)L08F3:          move.l  A6,(SP)                subq.l  #8,(SP)                move.l  A6,-(SP)                subq.l  #6,(SP)                move.w  #-1,-(SP)                movea.l 20(A6),A0                move.w  (A0),-(SP)                movea.l 16(A6),A0                move.w  (A0),-(SP)                movea.l 12(A6),A0                move.w  (A0),-(SP)                movea.l 8(A6),A0                move.w  (A0),-(SP)                bsr     L08C3                lea     14(SP),SP                tst.w   D0                beq.s   L08F4                movea.l 20(A6),A0                move.w  (A0),(SP)                movea.l 16(A6),A0                move.w  (A0),-(SP)                move.w  -8(A6),-(SP)                move.w  -6(A6),-(SP)                movea.l 12(A6),A0                move.w  (A0),-(SP)                movea.l 8(A6),A0                move.w  (A0),-(SP)                bsr     L08CA                lea     10(SP),SP                tst.w   D0                beq.s   L08F4                movea.l 16(A6),A0                move.w  -6(A6),(A0)                movea.l 20(A6),A0                move.w  -8(A6),(A0)L08F4:          moveq   #1,D0L08F5:          unlk    A6                rts                ENDPART                >PART 'calc_to_koord' ;in absolute Koordinaten umrechnencalc_to_koord:  move.w  (A1),D0                muls    window_width,D0                divs    (A0),D0                move.w  word_per_line,D1                asl.w   #8,D1                ext.l   D1                divs    (A0),D1                neg.w   D0                add.w   window_width,D0                move.w  D0,(A0)                neg.w   D1                move.w  D1,(A1)                rts                ENDPART                >PART 'calc_sin_table' ;Tabelle fŸr 256 Richtungen errechnencalc_sin_table: link    A6,#-10                moveq   #0,D7                lea     xy_speed_table,A0calc_sin_table1:move.w  #-32,-4(A6)     ;Y-Delta                clr.w   -6(A6)          ;X-Delta                move.l  A0,-(SP)                move.w  D7,D0                neg.w   D0                move.w  D0,-(SP)                pea     -6(A6)          ;X-Delta=COS(Y)+SIN(X)                pea     -4(A6)          ;Y-Delta=COS(X)-SIN(Y)                bsr.s   sincos                lea     10(SP),SP                movea.l (SP)+,A0                move.w  -4(A6),(A0)+    ;Y-Delta                move.w  -6(A6),(A0)+    ;X-Delta                addq.w  #1,D7                cmp.w   #256,D7         ;256 Richtungen errechnet?                blo.s   calc_sin_table1 ;Nein! =>                unlk    A6                rts                ENDPART                >PART 'to_draw_list';************************************************************************;* to_draw_list() - Werte auf dem Stack in die Zeichenliste Ÿbernehmen  *;* Wand    : Farbe, X1,H1 ,X2,H2                                        *;* Spieler : ???,X,Spriteno,Y,Farbe                                     *;* Schu§   : ---,X,Spriteno,Y,Farbe                                     *;************************************************************************to_draw_list:   move.w  draw_elem_count,D0                lea     draw_elem_list,A0                mulu    #12,D0                adda.w  D0,A0                lea     4(SP),A1                move.l  (A1)+,(A0)+     ;Funktion (1=Wand, 2=Spieler, 3=Schu§)                move.l  (A1)+,(A0)+                move.l  (A1),(A0)                addq.w  #1,draw_elem_count                rts                ENDPART                >PART 'draw_list' ;erstellte Liste zeichnen -> das 3D-Maze zeichnendraw_list:      movem.l D0-A6,-(SP)                tst.w   screen_rez      ;Farbe?                beq.s   draw_list1      ;Ja! =>                bsr     clr_sw_window   ;Hintergrund mit SW-Muster fŸllen                bra.s   draw_list2draw_list1:     bsr     clr_cwindow     ;Fenster mit Farbe fŸllendraw_list2:     move.w  draw_elem_count,D6                bra.s   draw_list6draw_list3:     lea     draw_elem_list,A0                move.w  D6,D0                mulu    #12,D0                movem.w 0(A0,D0.w),D0-D5 ;alle 6 Parameter holen                bclr    #7,D0                seq     no_color        ;$00: Shape ist farblos                subq.w  #1,D0           ;Funktion 1 = Wand setzen?                bne.s   draw_list4      ;Nein! =>                add.w   D1,D1                lea     wand_farb_tab(PC),A1                move.w  0(A1,D1.w),-(SP) ;Farbe                move.w  D5,-(SP)        ;H2                move.w  D4,-(SP)        ;X2                move.w  D3,-(SP)        ;H1                move.w  D2,-(SP)        ;X1                bsr     draw_wand       ;Mauer setzen                lea     10(SP),SP                move.w  D3,-(SP)                move.w  D2,-(SP)                bsr.s   draw_vline      ;X1,H1 - linke Linie                addq.l  #4,SP                move.w  D5,-(SP)                move.w  D4,-(SP)                bsr.s   draw_vline      ;X2,H2 - rechte Linie                addq.l  #4,SP                bra.s   draw_list6draw_list4:     subq.w  #1,D0           ;Funktion 2 = ein Spieler?                bne.s   draw_list5      ;Nein! =>                move.w  D5,-(SP)        ;Farbe                move.w  D3,-(SP)        ;Spritegrš§e                move.w  D1,-(SP)        ;Spritenummer                move.w  D4,-(SP)        ;Y                move.w  D2,-(SP)        ;X                bsr     set_shape       ;Spieler setzen                lea     10(SP),SP                bra.s   draw_list6draw_list5:     subq.w  #1,D0           ;Funktion 3 = ein Schu§?                bne.s   draw_list6      ;Nein! =>                move.w  D5,-(SP)        ;Farbe                move.w  D3,-(SP)        ;Spritegrš§e                move.w  #10,-(SP)       ;Spritenummer                move.w  D4,-(SP)        ;Y                move.w  D2,-(SP)        ;X                bsr     set_shape       ;Schu§ setzen                lea     10(SP),SPdraw_list6:     dbra    D6,draw_list3                move.w  D6,draw_elem_count ;-1                bsr     switch_screens  ;neue Grafikseite anzeigen                movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'draw_vline' ;Wandbegrenzung (Vertikale Linie) ziehendraw_vline:     movem.l D0-D2/A0-A2,-(SP)                movem.w 6*4+4(SP),D1-D2 ;X,H holen                tst.w   D1              ;X-Koordinate negativ?                ble.s   draw_vline4     ;Ja! => Linie nicht zeichnen                move.w  window_width,D0                add.w   D0,D0                subq.w  #1,D0                cmp.w   D1,D0           ;X-Koordinate zu gro§?                ble.s   draw_vline4     ;Ja! => Linie nicht zeichnen                cmp.w   window_height,D2 ;Y-Koordinate zu gro§?                bls.s   draw_vline1     ;Nein! =>                move.w  window_height,D2 ;sonst Ymax nehmendraw_vline1:    clr.w   -(SP)           ;FŸllmuster/Farbe                move.w  D1,-(SP)        ;X                move.w  window_height,-(SP) ;Y2                add.w   D2,(SP)         ;+ Hšhe                move.w  window_height,-(SP)                sub.w   D2,(SP)         ;- Hšhe                tst.w   screen_rez      ;Farbe?                beq.s   draw_vline2     ;Ja! =>                bsr     dr_sw_vline     ;S/W-Linie                bra.s   draw_vline3draw_vline2:    bsr     dr_c_cvline     ;Farb-Liniedraw_vline3:    addq.l  #8,SPdraw_vline4:    movem.l (SP)+,D0-D2/A0-A2                rts                ENDPART                >PART 'draw_wand' ;eine Wand zeichnen;************************************************************************;* draw_wand(X1,H1,X2,H2,Farbe) - Wand zeichnen                         *;* Endlich gefunden: Die Routine, welche eine Wand zeichnet             *;* Ein paar ErklŠrungen dazu:                                           *;* Bei X1 fŠngt die Mauer an, bei X2 hšrt die Mauer auf.                *;* Die linke Hšhe ist H1, die rechte Hšhe ist H2.                       *;* Dabei ist zu beachten, da§ das Bild 160x100 Punkte gro§ ist und auch *;* auf S/W stets in dieser (Farb-)Auslšsung gezeichnet wird.            *;* Man hat sich eine Mauer als Spiegelung an der Halbierenden des Bildes*;* vorzustellen, d.h. zu einer X-Achse bei Y=50.                        *;************************************************************************draw_wand:      movem.l D0-A6,-(SP)                movem.w 15*4+4(SP),D2-D5 ;alle Koordinaten holen                move.w  15*4+4+4*2(SP),D1                tst.w   screen_rez      ;Farbe?                beq.s   draw_wand1      ;Ja! =>                asr.w   #1,D3                asr.w   #1,D5           ;die Hšhe halbierendraw_wand1:     cmp.w   D5,D3           ;H1 < H2?                bls.s   draw_wand2      ;dann ist alles i.O.                exg     D3,D5           ;Die kleine Hšhe stets in H1                exg     D2,D4           ;X1 <> X2draw_wand2:     cmp.w   #width,D2       ;X1 darf maximal 159 gro§ sein                bne.s   draw_wand3                subq.w  #1,D2draw_wand3:     cmp.w   #width,D4       ;X2 darf maximal 159 gro§ sein                bne.s   draw_wand4                subq.w  #1,D4draw_wand4:     cmp.w   #height/2,D3    ;die kleine Hšhe darf max.                bls.s   draw_wand5      ;50 Pixel hoch sein!                moveq   #height/2,D3draw_wand5:     moveq   #height/2,D0                move.w  D1,-(SP)        ;FŸllmuster                move.w  D3,-(SP)        ;Y1+50                add.w   D0,(SP)                move.w  D4,-(SP)        ;X2                sub.w   D3,D0           ;50-Y1                move.w  D0,-(SP)                move.w  D2,-(SP)        ;X1                tst.w   screen_rez      ;Farbe?                beq.s   draw_wand6      ;Ja! =>                bsr     dr_sw_cbox      ;Box in S/W zeichnen                bra.s   draw_wand7draw_wand6:     bsr     dr_c_box        ;Box in Farbe zeichnendraw_wand7:     lea     10(SP),SP                move.w  D4,D6           ;X2-X1                sub.w   D2,D6                asl.w   #4,D6           ;mal 16                move.w  D5,D0           ;Y2-Y1                sub.w   D3,D0                ext.l   D6                divs    D0,D6           ;((X2-X1)*16)/(Y2-Y1)=Delta                move.w  D2,D7                asl.w   #4,D7           ;X1*16                move.w  D6,D0                asr.w   #1,D0                add.w   D0,D7           ;X1*16+Delta/2+8                addq.w  #8,D7                bra.s   draw_wand11draw_wand8:     cmp.w   #height/2,D3                bhi.s   draw_wand12                move.w  D7,D2                asr.w   #4,D2                moveq   #height/2,D0                sub.w   D3,D0                move.w  D1,-(SP)        ;FŸllmuster/Farbe                move.w  D0,-(SP)        ;50-Y1                move.w  D2,-(SP)        ;X2                move.w  D4,-(SP)        ;X1                tst.w   screen_rez      ;Farbe?                beq.s   draw_wand9      ;Ja! =>                bsr     dr_sw_chline                addq.l  #8,SP                move.w  D1,-(SP)        ;FŸllmuster                move.w  D3,-(SP)        ;50+Y1                addi.w  #height/2,(SP)                move.w  D2,-(SP)        ;X2                move.w  D4,-(SP)        ;X1                bsr     dr_sw_chline                addq.l  #8,SP                bra.s   draw_wand10draw_wand9:     bsr     dr_c_cline                addq.l  #8,SP                move.w  D1,-(SP)        ;Farbe                move.w  D3,-(SP)                addi.w  #height/2,(SP)  ;50+Y1                move.w  D2,-(SP)        ;X2                move.w  D4,-(SP)        ;X1                bsr     dr_c_cline                addq.l  #8,SPdraw_wand10:    add.w   D6,D7           ;+ Deltadraw_wand11:    addq.w  #1,D3                cmp.w   D5,D3                bls.s   draw_wand8draw_wand12:    movem.l (SP)+,D0-A6                rts                ENDPART                >PART 'set_shape' ;set_shape(X,Y,Spritenr.,Spritegrš§e,Farbe); 8() : X;10() : Y;12() : Spritenummer (0 bis 19);14() : Spritegrš§e (0 bis 100);16() : Farbe (0 bis 15)set_shape:      link    A6,#-20                movem.l D0-A5,-(SP)                move.w  window_height,D0                add.w   D0,D0                move.w  D0,-12(A6)      ;Breite des Windows in Pixeln (160, 320)                tst.w   screen_rez      ;Farbe?                beq.s   set_shape1      ;Ja! =>                asr.w   10(A6)          ;fŸr s/w: Y/2set_shape1:     cmpi.w  #16,10(A6)      ;Y > 16?                bgt.s   set_shape2      ;Ja! =>                moveq   #24,D0                sub.w   10(A6),D0                bra.s   set_shape3set_shape2:     moveq   #8,D0                move.w  10(A6),D1                sub.w   #15,D1                asr.w   #1,D1                sub.w   D1,D0set_shape3:     move.w  D0,-4(A6)                move.w  10(A6),D0                subq.w  #1,D0                asr.w   #3,D0                addq.w  #1,D0                move.w  D0,-8(A6)                tst.w   screen_rez      ;Farbe?                beq.s   set_shape4      ;Ja! =>                asl.w   -8(A6)set_shape4:     movea.w -4(A6),A0                adda.l  A0,A0                adda.l  #set_shape_tab1,A0                move.w  (A0),-10(A6)                tst.w   screen_rez      ;Farbe?                beq.s   set_shape5      ;Ja! =>                asl.w   -10(A6)set_shape5:     move.w  -10(A6),D0                asr.w   #1,D0                add.w   D0,14(A6)                movea.w -4(A6),A0                adda.l  A0,A0                adda.l  #set_shape_tab2,A0                move.w  (A0),-2(A6)                move.w  14(A6),D0                cmp.w   -12(A6),D0                ble.s   set_shape7                move.w  14(A6),D0                sub.w   -10(A6),D0                addq.w  #1,D0                cmp.w   -12(A6),D0                bgt.s   set_shape7                move.w  14(A6),D0                sub.w   -12(A6),D0                ext.l   D0                tst.w   screen_rez                beq.s   set_shape6                asr.w   #1,D0set_shape6:     muls    -8(A6),D0                sub.w   D0,-2(A6)                move.w  14(A6),D0                sub.w   -12(A6),D0                sub.w   D0,-10(A6)                move.w  -12(A6),14(A6)set_shape7:     tst.w   screen_rez      ;Farbe?                beq.s   set_shape8      ;Ja! =>                asr.w   -10(A6)set_shape8:     move.w  14(A6),D0                cmp.w   -12(A6),D0                bgt.s   set_shape12                tst.w   -10(A6)                ble.s   set_shape12                move.w  -2(A6),D0                ext.l   D0                add.l   D0,D0                add.l   #set_shape_tab3,D0                move.l  D0,-16(A6)                tst.w   screen_rez      ;Farbe?                beq.s   set_shape10     ;Ja! =>                move.l  sw_fŸllmuster(PC),(SP)                move.w  -10(A6),-(SP)   ;Zeilenanzahl                move.w  -8(A6),-(SP)    ;X-Offset                move.l  -16(A6),-(SP)   ;Zeiger auf die Daten                move.w  14(A6),-(SP)    ;Y                move.w  8(A6),-(SP)     ;X                tst.b   no_color        ;Shape-Schatten nicht zeichnen?                beq.s   set_shape9      ;genau =>                bsr     dr_sw_shape     ;den Schatten zeichnenset_shape9:     lea     12(SP),SP                bra.s   set_shape12set_shape10:    move.l  dr_c_shp_tab2(PC),(SP)                move.w  -10(A6),-(SP)   ;Zeilenanzahl                move.w  -8(A6),-(SP)    ;X-Offset                move.l  -16(A6),-(SP)   ;Zeiger auf die Daten                move.w  14(A6),-(SP)    ;Y                move.w  8(A6),-(SP)     ;X                tst.b   no_color        ;Shape-Schatten nicht zeichnen?                beq.s   set_shape11     ;genau =>                bsr     dr_c_shape      ;den Schatten zeichnenset_shape11:    lea     12(SP),SPset_shape12:    movea.w -4(A6),A0                adda.l  A0,A0                adda.l  #set_shape_tab4,A0                move.w  (A0),-10(A6)                move.w  -10(A6),D0                tst.w   screen_rez      ;Farbe?                bne.s   set_shape13     ;Nein! =>                asr.w   #1,D0set_shape13:    add.w   window_height,D0                move.w  D0,-6(A6)                movea.w -4(A6),A0                adda.l  A0,A0                adda.l  #set_shape_tab5,A0                move.w  (A0),-2(A6)                move.w  -2(A6),D0                ext.l   D0                add.l   D0,D0                add.l   shape_face_ptr,D0                move.l  D0,-16(A6)                tst.w   screen_rez      ;Farbe?                beq.s   set_shape15     ;Ja! =>                movea.w 16(A6),A0                adda.l  A0,A0                lea     color_cnv_back,A1                movea.w 0(A0,A1.l),A0                adda.l  A0,A0                adda.l  A0,A0                move.l  #sw_farbfŸll_tab,D1                move.l  0(A0,D1.l),(SP)                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -16(A6),-(SP)                move.w  -6(A6),-(SP)    ;Y                move.w  8(A6),-(SP)     ;X                tst.b   no_color        ;Shape nicht zeichnen?                beq.s   set_shape14     ;genau =>                bsr     dr_sw_shape     ;Hintergrund (die Farbe) zeichnenset_shape14:    lea     12(SP),SP                bra.s   set_shape17set_shape15:    movea.w 16(A6),A0                adda.l  A0,A0                lea     color_cnv_back,A1                movea.w 0(A0,A1.l),A0                adda.l  A0,A0                adda.l  A0,A0                move.l  #col_farb_jmptab,D1                move.l  0(A0,D1.l),(SP)                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -16(A6),-(SP)                move.w  -6(A6),-(SP)    ;Y                move.w  8(A6),-(SP)     ;X                tst.b   no_color        ;Shape nicht zeichnen?                beq.s   set_shape16     ;genau =>                bsr     dr_c_shape      ;Hintergrund (die Farbe) zeichnenset_shape16:    lea     12(SP),SPset_shape17:    movea.w -4(A6),A0                adda.l  A0,A0                move.l  #set_shape_tab4,D1                move.w  0(A0,D1.l),D0                muls    -8(A6),D0                muls    12(A6),D0                move.w  D0,-2(A6)                move.w  -2(A6),D0                ext.l   D0                add.l   D0,D0                movea.w -4(A6),A1                adda.l  A1,A1                adda.l  A1,A1                adda.l  #set_shape_tab6,A1                move.l  (A1),D1                add.l   D1,D1                add.l   D1,D0                add.l   shape_ptr,D0                move.l  D0,-16(A6)                tst.w   screen_rez      ;Farbe?                beq.s   set_shape18     ;Ja! =>                movea.w 16(A6),A0                adda.l  A0,A0                lea     color_cnv_frame,A1                movea.w 0(A0,A1.l),A0                adda.l  A0,A0                adda.l  A0,A0                move.l  #sw_farbfŸll_tab,D1                move.l  0(A0,D1.l),(SP)                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -16(A6),-(SP)                move.w  -6(A6),-(SP)    ;Y                move.w  8(A6),-(SP)     ;X                bsr     dr_sw_shape     ;den Rahmen zeichnen                lea     12(SP),SP                bra.s   set_shape19set_shape18:    movea.w 16(A6),A0                adda.l  A0,A0                lea     color_cnv_frame,A1                movea.w 0(A0,A1.l),A0                adda.l  A0,A0                adda.l  A0,A0                move.l  #col_farb_jmptab,D1                move.l  0(A0,D1.l),(SP)                move.w  -10(A6),-(SP)                move.w  -8(A6),-(SP)                move.l  -16(A6),-(SP)                move.w  -6(A6),-(SP)    ;Y                move.w  8(A6),-(SP)     ;X                bsr     dr_c_shape      ;den Rahmen zeichnen                lea     12(SP),SPset_shape19:    st      no_color        ;Shape-Schatten nicht zeichnen                movem.l (SP)+,D0-A5                unlk    A6                rts                ENDPART                >PART 'init_maze' ;Maze von allen Spieler/Schu§daten befreieninit_maze:      movem.l D0-D1,-(SP)                moveq   #1,D0init_maze1:     moveq   #1,D1init_maze2:     move.w  #-1,-(SP)                move.w  D1,-(SP)                move.w  D0,-(SP)                bsr     put_maze_data                addq.l  #6,SP                addq.w  #2,D1                cmp.w   #63,D1                ble.s   init_maze2                addq.w  #2,D0                cmp.w   #63,D0                ble.s   init_maze1                movem.l (SP)+,D0-D1                rts                ENDPART                >PART 'init_all_player' ;alle Spieler auf eine zufŠllige Position setzen, Variablen initinit_all_player:movem.l D1-A6,-(SP)                bsr.s   init_maze       ;Maze von Spielerdaten befreien                clr.w   objekt_anz      ;keine zu lšschende Objekte mehr                moveq   #15,D0                lea     player_data,A0init_all_player3:clr.w  ply_lives(A0)   ;alle Leben lšschen                lea     ply_size(A0),A0                dbra    D0,init_all_player3                moveq   #0,D2init_all_player4:move.w D2,-(SP)                bsr.s   hunt_ply_pos                addq.l  #2,SP                tst.w   D0              ;Platz gefunden?                beq.s   init_all_player6 ;Fehler =>                lea     player_data,A0                move.w  D2,D0                mulu    #ply_size,D0                adda.w  D0,A0                clr.w   ply_refresh(A0) ;Refresh unnštig                clr.w   ply_shoot(A0)   ;kein Schu§ aktiv                clr.w   ply_reload(A0)  ;Nachgeladen                clr.w   ply_killscore(A0) ;keine AbschŸsse                clr.w   ply_score(A0)   ;keine Punkte                clr.w   ply_hits(A0)    ;keine temp.Treffer                clr.w   ply_hitscore(A0) ;keine Treffer                st      ply_warnflag(A0) ;keine Schu§warnung aktiv                clr.w   ply_shitscore(A0) ;gemerkter Hit-Score                clr.w   ply_hitflag(A0) ;nicht getroffen                move.w  ply_revive_live(A0),ply_lives(A0) ;Anzahl der Leben                clr.w   ply_looser(A0)                addq.w  #1,D2                cmp.w   all_players,D2                bne.s   init_all_player4                moveq   #1,D0           ;Alles ok! Z=0init_all_player6:movem.l (SP)+,D1-A6                rts                ENDPART                >PART 'hunt_ply_pos' ;freies PlŠtzchen fŸr einen Spieler suchenhunt_ply_pos:   link    A6,#-24                movem.l D1-A6,-(SP)                move.w  #1,-10(A6)      ;nicht gefunden                clr.w   -2(A6)          ;Anzahl der Versuche=0hunt_ply_pos1:  move.w  maze_size,-(SP) ;zufŠllige X-Position                bsr     _rnd                addq.l  #2,SP                or.w    #1,D0                move.w  D0,D1                move.w  maze_size,-(SP)                bsr     _rnd            ;zufŠllige Y-Position                addq.l  #2,SP                or.w    #1,D0                move.w  D0,D2                move.w  D2,-(SP)        ;X                move.w  D1,-(SP)        ;Y                bsr     get_maze_datayx                addq.l  #4,SP                bpl     hunt_ply_pos12  ;Floor? Nein! =>                moveq   #0,D3                move.w  D2,-(SP)        ;X                move.w  D1,-(SP)        ;Y-1                subq.w  #1,(SP)                bsr     get_maze_datayx                addq.l  #4,SP                bmi.s   hunt_ply_pos2   ;Eine Wand? Nein! =>                addq.w  #1,D3hunt_ply_pos2:  move.w  D2,-(SP)        ;X-1                subq.w  #1,(SP)                move.w  D1,-(SP)        ;Y                bsr     get_maze_datayx                addq.l  #4,SP                bmi.s   hunt_ply_pos3   ;Eine Wand? Nein! =>                addq.w  #1,D3hunt_ply_pos3:  move.w  D2,-(SP)        ;X                move.w  D1,-(SP)        ;Y+1                addq.w  #1,(SP)                bsr     get_maze_datayx                addq.l  #4,SP                bmi.s   hunt_ply_pos4   ;Eine Wand? Nein! =>                addq.w  #1,D3hunt_ply_pos4:  move.w  D2,-(SP)        ;X+1                addq.w  #1,(SP)                move.w  D1,-(SP)        ;Y                bsr     get_maze_datayx                addq.l  #4,SP                bmi.s   hunt_ply_pos5   ;Eine Wand? Nein! =>                addq.w  #1,D3hunt_ply_pos5:  subq.w  #4,D3           ;Ÿberall WŠnde?                beq     hunt_ply_pos12  ;Ja! => Illegales Feld =>                clr.w   -10(A6)         ;gefunden!                lea     player_data,A0                move.w  8(A6),D0                mulu    #ply_size,D0                adda.w  D0,A0                move.w  D1,D0           ;Y*128                lsl.w   #7,D0                move.w  D0,ply_y(A0)    ;= Y-Koordinate                move.w  D2,D0           ;X*128                lsl.w   #7,D0                move.w  D0,ply_x(A0)    ;= X-Koordinate                moveq   #5,D0                move.w  -2(A6),D1                ext.l   D1                divs    #20,D1                sub.w   D1,D0                asl.w   #8,D0                move.w  D0,-20(A6)                clr.w   -12(A6)hunt_ply_pos6:  move.w  8(A6),D0        ;Spielernummer                cmp.w   -12(A6),D0      ;= aktueller Spieler?                beq.s   hunt_ply_pos10  ;Ja! =>                lea     player_data,A0                move.w  -12(A6),D0                mulu    #ply_size,D0                adda.w  D0,A0                tst.w   ply_lives(A0)   ;lebt der aktuelle Spieler noch?                ble.s   hunt_ply_pos10  ;Nein! =>                move.w  ply_y(A0),D0    ;Y-Position holen                move.w  8(A6),D1        ;Spielernummer                mulu    #ply_size,D1                add.l   #player_data,D1                movea.l D1,A1                sub.w   ply_y(A1),D0    ;Y-Abstand der Spieler berechnen                bge.s   hunt_ply_pos7                neg.w   D0              ;ABS(Abstand)hunt_ply_pos7:  move.w  D0,-14(A6)      ;merken                move.w  ply_x(A0),D0    ;X-Abstand des aktuellen Spielers                sub.w   ply_x(A1),D0    ;X-Abstand der Spieler berechnen                bge.s   hunt_ply_pos8                neg.w   D0              ;ABS(Abstand)hunt_ply_pos8:  move.w  D0,-16(A6)      ;merken                move.w  -14(A6),D0                cmp.w   -20(A6),D0                blt.s   hunt_ply_pos9   ;X-Abstand zu klein? =>                move.w  -16(A6),D0                cmp.w   -20(A6),D0                bge.s   hunt_ply_pos10  ;Y-Abstand gro§ genug? =>hunt_ply_pos9:  move.w  #1,-10(A6)      ;not Found!                bra.s   hunt_ply_pos12hunt_ply_pos10: addq.w  #1,-12(A6)      ;nŠchster Spieler                move.w  -12(A6),D0                cmp.w   all_players,D0  ;schon alle Spieler?                blo.s   hunt_ply_pos6   ;Nein! =>hunt_ply_pos12: addq.w  #1,-2(A6)       ;Versuche+1                cmpi.w  #666,-2(A6)     ;666 gehen durch?                bge.s   hunt_ply_pos13  ;Ja! =>                tst.w   -10(A6)         ;gefunden?                bne     hunt_ply_pos1   ;Nein! => weiterhunt_ply_pos13:				tst.w   -10(A6)         ;gefunden?                beq.s   hunt_ply_pos14  ;ja! =>                clr.w   D0              ;Fehler, da nix gefunden!                bra.s   hunt_ply_pos23  ;raus =>hunt_ply_pos14: clr.w   -(SP)                lea     player_data,A0                move.w  8(A6),D0                mulu    #ply_size,D0                adda.w  D0,A0                move.w  ply_x(A0),-(SP) ;X                move.w  ply_y(A0),-(SP) ;Y                move.w  8(A6),-(SP)     ;Spielernummer                bsr     set_object      ;Spieler auf das Feld setzen                addq.l  #8,SP                move.w  #-1,ply_plist(A0) ;Liste abschlie§en, Feld sonst leer!                move.w  #$0100,-(SP)                bsr     _rnd            ;zufŠllige Richtung!                addq.l  #2,SP;~                and.w   #$C0,D0         ;erlaubt sind nur N,O,S,W                and.w   #$FF,D0                move.w  D0,ply_richtung(A0)                moveq   #1,D0           ;alles OK, Z=0hunt_ply_pos23: movem.l (SP)+,D1-A6                unlk    A6                rts                ENDPART                >PART 'move_player'************************************************************************* move_player(Player,Joystick/Tastencode) - Spieler komplett verwalten *************************************************************************move_player:    link    A6,#-40                movem.l D2-A5,-(SP)                move.w  8(A6),D5        ;Spielernummer                lea     player_data,A0                move.w  D5,D0                mulu    #ply_size,D0                adda.w  D0,A0                move.b  10+1(A6),D0     ;Joystick/Tastencode holen                move.l  ply_features(A0),D1                btst    #f_midicam,D1   ;MIDICAM?                beq.s   move_player1    ;Nein! =>                clr.w   10(A6)          ;Tastencode lšschen                bclr    #7,D0           ;eine Taste?                bne.s   move_player4    ;ja! => nix melden                move.w  D0,10(A6)       ;Joystickrichtung wieder setzen                btst    #4,D0           ;Feuertaste?                beq.s   move_player4    ;Nein =>                move.w  #$39|$80,D0     ;SPACE meldenmove_player1:   bclr    #7,D0           ;das spart mir unten $80 zu addieren...                beq.s   move_player4    ;Joystick =>                clr.w   10(A6)          ;Tastencode (Joystickabfrage!) lšschen                lea     f_key_tab(PC),A1 ;Tastentabelle                lea     f_pkt_tab(PC),A2 ;Kostentabelle                lea     f_bit_tab(PC),A3 ;Feature-Bit-Tabelle                moveq   #0,D3move_player2:   tst.b   (A1)            ;Ende der Tastencodeliste?                beq.s   move_player4    ;dann raus! =>                move.b  (A2)+,D2        ;Kosten holen                ext.w   D2                move.b  (A3)+,D3        ;Nummer des Bits holen                cmp.b   (A1)+,D0        ;Tastencode gefunden?                bne.s   move_player2    ;Nein! => weiter                move.l  ply_features(A0),D4 ;vorhandene Features                move.l  ply_features_(A0),D1 ;mšgliche Features                btst    D3,D1           ;Features stets mšglich?                bne.s   move_player3    ;Ja! => (sehr preisgŸnstig!)                move.l  ply_features_b(A0),D1 ;kaufbare Features                btst    D3,D1           ;kann der Spieler das Feature kaufen?                beq.s   move_player4    ;Nein! => raus                btst    D3,D4           ;Feature-Flag testen                bne.s   move_player3    ;ausschalten ist kostenlos... =>                move.w  ply_score(A0),D0 ;dann wollen wir mal das Konto plŸndern                sub.w   D2,D0           ;genug Score vorhanden?                bmi.s   move_player4    ;Nein! => weiter                move.w  D0,ply_score(A0) ;neuen Score setzen                bsr     update_zahlen                cmp.w   #f_karte_init,D3 ;Karte bezahlt?                bne.s   move_player3    ;Nein! =>                bclr    #f_karte,D4     ;dann erstmal die Karte ausmove_player3:   bchg    D3,D4           ;Feature-Flag toggeln                move.l  D4,ply_features(A0) ;vorhandene Features neu setzenmove_player4:   move.l  ply_features(A0),D0                bclr    #f_turn180,D0                beq.s   move_player5                move.l  D0,ply_features(A0) ;Hyperspace lšschen                move.w  ply_richtung(A0),D0                eori.w  #128,D0         ;Richtung umdrehen                move.w  D0,ply_richtung(A0)move_player5:   bclr    #f_onejump,D0   ;einmal Hyperspace?                beq.s   move_player6    ;Nein! =>                move.l  D0,ply_features(A0) ;Hyperspace lšschen                bra.s   move_player8    ;und ausfŸhrenmove_player6:   tst.w   ply_refresh(A0) ;keinen Refresh?                ble.s   move_player11   ;Genau =>                subq.w  #1,ply_refresh(A0)                bne.s   move_player11   ;noch nicht abgelaufen =>                move.w  ply_lives(A0),D0 ;Anzahl der Leben holen                beq.s   move_player7    ;0=Tot =>                addq.w  #1,ply_lives(A0) ;ein Leben mehr                subq.w  #2,D0           ;3 (maximale) Leben erreicht?                bpl.s   move_player10   ;Ja! =>                move.w  ply_refresh_t(A0),ply_refresh(A0) ;sonst Refresh-Counter neu                bra.s   move_player10move_player7:   move.w  ply_revive_live(A0),D0 ;Spieler wieder beleben                move.w  D0,ply_lives(A0)                subq.w  #3,D0           ;schon 3 max. Leben?                bpl.s   move_player8    ;Ja! =>                clr.w   ply_refresh(A0) ;bei 3 Leben keinen erneuten Refreshmove_player8:   move.w  D5,-(SP)                bsr     hunt_ply_pos    ;neue Position fŸr den Spieler suchen                addq.l  #2,SP                tst.w   D0                bne.s   move_player9                moveq   #-1,D0          ;keinen freien Platz gefunden!                bra     move_player80move_player9:   move.l  ply_features(A0),D0                bclr    #f_karte,D0     ;Karte nun aus                move.l  D0,ply_features(A0)                cmp.w   own_number,D5   ;Der eigene Spieler?                bne.s   move_player11   ;Nein! =>                bsr     redraw_small    ;SchŸtzen wieder lšschenmove_player10:  cmp.w   own_number,D5   ;Der eigene Spieler?                bne.s   move_player11   ;Nein! =>                moveq   #7,D0                bsr     con_out         ;Bell                movem.l D0-A6,-(SP)                bsr     update_smily                movem.l (SP)+,D0-A6move_player11:  tst.w   ply_lives(A0)   ;lebt der Spieler noch?                bne.s   move_player14   ;Ja! =>                tst.w   ply_shoot(A0)   ;oder fliegt noch ein Schu§?                beq.s   move_player12   ;Nein! =>                move.w  D5,-(SP)                bsr     move_shoot      ;den Schu§ verwalten                addq.l  #2,SPmove_player12:  tst.w   ply_reload(A0)  ;bereits Nachgeladen?                beq.s   move_player13   ;Ja! =>                subq.w  #1,ply_reload(A0) ;Nachladenmove_player13:  bra     move_player79   ;Raus! =>move_player14:  move.w  ply_y(A0),D7                move.w  ply_x(A0),D6                move.w  ply_richtung(A0),-6(A6)                move.w  D7,D0                asr.w   #7,D0                or.w    #1,D0                move.w  D0,-22(A6)                move.w  D6,D0                asr.w   #7,D0                or.w    #1,D0                move.w  D0,-24(A6)                move.w  -6(A6),D2                moveq   #16,D1          ;normales drehen                move.l  ply_features(A0),D0                btst    #f_turnfast,D0  ;schnelles Drehen?                bne.s   move_player15   ;Ja! =>                moveq   #8,D1           ;normales Drehen                btst    #f_turnslow,D0  ;langsames Drehen?                beq.s   move_player15   ;Nein! =>                moveq   #1,D1           ;langsames Drehenmove_player15:  btst    #2,1+10(A6)     ;Joystick links                beq.s   move_player16   ;Nein! =>                sub.w   D1,D2                bra.s   move_player17move_player16:  btst    #3,1+10(A6)     ;Joystick rechts                beq.s   move_player18   ;Nein! =>                add.w   D1,D2move_player17:  neg.w   D1                and.w   D1,D2           ;Winkel begradigen                and.w   #$FF,D2         ;und den †berlauf abfangen                move.w  D2,-6(A6)move_player18:  btst    #f_noshot,D0    ;Schie§en nicht mšglich?                bne.s   move_player20   ;Genau! =>                btst    #4,1+10(A6)     ;Feuertaste                beq.s   move_player20   ;Nein! =>                tst.w   ply_reload(A0)  ;wird noch nachgeladen?                bne.s   move_player20   ;Ja! =>                cmp.w   own_number,D5   ;Der eigene Spieler?                bne.s   move_player19   ;Nein!                movem.l D0-D2/A0-A2,-(SP)                pea     sound_1(PC)                move.w  #$20,-(SP)                trap    #14             ;Schu§!                addq.l  #6,SP                movem.l (SP)+,D0-D2/A0-A2move_player19:  move.w  -6(A6),ply_shootr(A0) ;Richtung des Schu§es                move.w  #10,ply_shoot(A0) ;Flag, da§ Schu§ fliegt                move.w  ply_reload_t(A0),ply_reload(A0) ;Reloadtime setzen                move.w  D7,ply_shooty(A0) ;Y-Position des Schu§es                move.w  D6,ply_shootx(A0) ;X-Position des Schu§es                move.w  ply_swioffset(A0),D0                asr.w   #1,D0           ;Offsetwinkel initialisieren                move.w  D0,ply_swoffset(A0)                move.w  ply_swcinit(A0),ply_swcounter(A0) ;ZŠhler neu setzen                addq.w  #1,ply_swcounter(A0)move_player20:  tst.w   ply_shoot(A0)   ;Schu§ aktiv?                beq.s   move_player21   ;Nein! =>                move.w  D5,-(SP)                bsr     move_shoot      ;Den Schu§ verwalten                addq.l  #2,SPmove_player21:  tst.w   ply_reload(A0)  ;bereits nachgeladen?                beq.s   move_player22   ;Ja! =>                subq.w  #1,ply_reload(A0) ;nachladen!move_player22:  lea     xy_speed_table,A1                move.w  -6(A6),D0                add.w   D0,D0                add.w   D0,D0                adda.w  D0,A1           ;Zeiger auf die Umrechnungstabelle                btst    #0,1+10(A6)     ;Joystick nach oben?                beq.s   move_player23   ;Nein! =>                move.w  (A1),D2         ;Y-Speed                move.w  2(A1),D1        ;X-Speed                move.w  D2,-32(A6)                move.w  D1,-34(A6)                move.l  ply_features(A0),D0                btst    #f_fastplayer,D0 ;Doppelt so schnell?                beq.s   move_player26   ;Nein! =>                add.w   D2,-32(A6)      ;Y-Speed                add.w   D1,-34(A6)      ;X-Speed                bra.s   move_player26move_player23:  btst    #1,1+10(A6)     ;Joystick nach unten?                beq.s   move_player25   ;Nein! =>                move.w  (A1),D1                move.w  2(A1),D2                move.l  ply_features(A0),D0                btst    #f_fastplayer,D0 ;doppelt so schnell?                beq.s   move_player24   ;Nein! =>                add.w   D1,D1                add.w   D2,D2move_player24:  neg.w   D1                move.w  D1,-32(A6)      ;Y-Speed                neg.w   D2                move.w  D2,-34(A6)      ;X-Speed                bra.s   move_player26move_player25:  clr.w   -32(A6)         ;Sofort stoppen!                clr.w   -34(A6)move_player26:  move.w  ply_y(A0),D7                add.w   -32(A6),D7      ;neue Y-Position                move.w  ply_x(A0),D6                add.w   -34(A6),D6      ;neue X-Position                move.w  D7,D4                asr.w   #7,D4                or.w    #1,D4           ;Y-Koordinate im Maze                move.w  D6,D3                asr.w   #7,D3                or.w    #1,D3           ;X-Koordinate im Maze                move.w  #1,-20(A6)                move.w  #-2,-16(A6)move_player27:  move.w  #-2,-18(A6)move_player28:  move.w  -18(A6),-(SP)                add.w   D3,(SP)                move.w  -16(A6),-(SP)                add.w   D4,(SP)                bsr     get_maze_datayx                addq.l  #4,SP                move.w  D0,-30(A6)                bra     move_player48move_player29:  cmpi.w  #16,-30(A6)                bge     move_player47                cmp.w   -30(A6),D5                beq     move_player46                lea     player_data,A1                move.w  -30(A6),D0                mulu    #ply_size,D0                adda.w  D0,A1                move.w  ply_y(A1),D0                sub.w   D7,D0                bge.s   move_player30                neg.w   D0move_player30:  move.w  D0,-26(A6)                move.w  ply_x(A1),D0                sub.w   D6,D0                bge.s   move_player31                neg.w   D0move_player31:  move.w  D0,-28(A6)                cmpi.w  #96,-26(A6)                bge     move_player46                cmpi.w  #96,-28(A6)                bge     move_player46                move.l  ply_features(A1),D0 ;Features des Spielers holen                btst    #f_luft,D0      ;Ist der Spieler "Luft"?                bne     move_player46   ;dann wird er ignoriert! =>                move.l  ply_features(A0),D0 ;Features des Spielers holen                btst    #f_luft,D0      ;Ist der Spieler "Luft"?                bne     move_player46   ;dann wird er ignoriert! =>                lea     player_data,A1                move.w  -30(A6),D0                mulu    #ply_size,D0                adda.w  D0,A1                move.w  ply_y(A1),D0                sub.w   ply_y(A0),D0                bpl.s   move_player32                neg.w   D0move_player32:  move.w  D0,-36(A6)                move.w  ply_x(A1),D0                sub.w   ply_x(A0),D0                bpl.s   move_player33                neg.w   D0move_player33:  move.w  D0,-38(A6)                cmpi.w  #96,-36(A6)                bge.s   move_player36                tst.w   -34(A6)                bge.s   move_player34                moveq   #96,D0                sub.w   -28(A6),D0                neg.w   D0                bra.s   move_player35move_player34:  moveq   #96,D0                sub.w   -28(A6),D0move_player35:  sub.w   D0,-34(A6)                bra.s   move_player45move_player36:  cmpi.w  #96,-38(A6)                bge.s   move_player39                tst.w   -32(A6)                bge.s   move_player37                moveq   #96,D0                sub.w   -26(A6),D0                neg.w   D0                bra.s   move_player38move_player37:  moveq   #96,D0                sub.w   -26(A6),D0move_player38:  sub.w   D0,-32(A6)                bra.s   move_player45move_player39:  move.w  -26(A6),D0                cmp.w   -28(A6),D0                ble.s   move_player42                tst.w   -32(A6)                bge.s   move_player40                moveq   #96,D0                sub.w   -26(A6),D0                neg.w   D0                bra.s   move_player41move_player40:  moveq   #96,D0                sub.w   -26(A6),D0move_player41:  sub.w   D0,-32(A6)                bra.s   move_player45move_player42:  tst.w   -34(A6)                bge.s   move_player43                moveq   #96,D0                sub.w   -28(A6),D0                neg.w   D0                bra.s   move_player44move_player43:  moveq   #96,D0                sub.w   -28(A6),D0move_player44:  sub.w   D0,-34(A6)move_player45:  move.w  ply_y(A0),D7                add.w   -32(A6),D7                move.w  ply_x(A0),D6                add.w   -34(A6),D6move_player46:  lea     player_data,A1                move.w  -30(A6),D0                mulu    #ply_size,D0                adda.w  D0,A1                move.w  ply_plist(A1),-30(A6)                bra.s   move_player48move_player47:  lea     player_data,A1                move.w  -30(A6),D0                sub.w   #16,D0                mulu    #ply_size,D0                adda.w  D0,A1                move.w  ply_slist(A1),-30(A6)move_player48:  tst.w   -30(A6)                bpl     move_player29                addq.w  #2,-18(A6)                cmpi.w  #2,-18(A6)                ble     move_player28                addq.w  #2,-16(A6)                cmpi.w  #2,-16(A6)                ble     move_player27                move.l  ply_features(A0),D2                btst    #f_nowand,D2    ;Wand ignorieren?                bne     move_player71   ;keine Wandabfrage                move.w  D7,D0                and.w   #$FF,D0                move.w  D0,-2(A6)                move.w  D6,D0                and.w   #$FF,D0                move.w  D0,-4(A6)                moveq   #1,D0                cmpi.w  #128-63,-2(A6)                blt.s   move_player49                moveq   #0,D0move_player49:  move.w  D0,-8(A6)                moveq   #1,D0                cmpi.w  #128+63,-2(A6)                bgt.s   move_player50                moveq   #0,D0move_player50:  move.w  D0,-10(A6)                moveq   #1,D0                cmpi.w  #128-63,-4(A6)                blt.s   move_player51                moveq   #0,D0move_player51:  move.w  D0,-12(A6)                moveq   #1,D0                cmpi.w  #128+63,-4(A6)                bgt.s   move_player52                moveq   #0,D0move_player52:  move.w  D0,-14(A6)                moveq   #-1,D0                tst.w   -8(A6)                bne.s   move_player53                moveq   #0,D0                tst.w   -10(A6)                beq.s   move_player53                moveq   #1,D0move_player53:  move.w  D0,-16(A6)                tst.w   -12(A6)                beq.s   move_player54                move.w  #-1,-18(A6)                bra.s   move_player56move_player54:  tst.w   -14(A6)                beq.s   move_player55                move.w  #1,-18(A6)                bra.s   move_player56move_player55:  clr.w   -18(A6)move_player56:  tst.w   -20(A6)                beq.s   move_player64                tst.w   -8(A6)                bne.s   move_player57                tst.w   -10(A6)                beq.s   move_player60move_player57:  move.w  D3,-(SP)                move.w  -16(A6),-(SP)                add.w   D4,(SP)                bsr     get_maze_datayx                addq.l  #4,SP                bmi.s   move_player60   ;Eine Wand? Nein! =>                btst    #f_key,D2       ;ein SchlŸssel                beq.s   move_player58   ;Nein! =>                subq.b  #3,D0           ;Eine TŸr?                beq.s   move_player60   ;Ja! =>move_player58:  clr.b   D7                moveq   #128-63,D0                tst.w   -10(A6)                beq.s   move_player59                move.w  #128+63,D0move_player59:  add.w   D0,D7                clr.w   -20(A6)move_player60:  tst.w   -12(A6)                bne.s   move_player61                tst.w   -14(A6)                beq.s   move_player64move_player61:  move.w  -18(A6),-(SP)                add.w   D3,(SP)                move.w  D4,-(SP)                bsr     get_maze_datayx                addq.l  #4,SP                bmi.s   move_player64   ;Eine Wand? Nein! =>                btst    #f_key,D2       ;ein SchlŸssel                beq.s   move_player62   ;Nein! =>                subq.b  #3,D0           ;Eine TŸr?                beq.s   move_player64   ;Ja! =>move_player62:  clr.b   D6                moveq   #128-63,D0                tst.w   -14(A6)                beq.s   move_player63                move.w  #128+63,D0move_player63:  add.w   D0,D6                clr.w   -20(A6)move_player64:  tst.w   -20(A6)                beq.s   move_player71                tst.w   -16(A6)                beq.s   move_player71                tst.w   -18(A6)                beq.s   move_player71                move.w  -18(A6),-(SP)                add.w   D3,(SP)                move.w  -16(A6),-(SP)                add.w   D4,(SP)                bsr     get_maze_datayx                addq.l  #4,SP                bmi.s   move_player71   ;Eine Wand? Nein! =>                btst    #f_key,D2       ;ein SchlŸssel                beq.s   move_player65   ;Nein! =>                subq.b  #3,D0           ;Eine TŸr?                beq.s   move_player71   ;Ja! =>move_player65:  move.w  -2(A6),D0                tst.w   -8(A6)                bne.s   move_player66                sub.w   #256,D0                neg.w   D0move_player66:  move.w  D0,-26(A6)                move.w  -4(A6),D0                tst.w   -12(A6)                bne.s   move_player67                sub.w   #256,D0                neg.w   D0move_player67:  move.w  D0,-28(A6)                move.w  -26(A6),D0                cmp.w   -28(A6),D0                blt.s   move_player69                clr.b   D7                moveq   #128-63,D0                tst.w   -10(A6)                beq.s   move_player68                move.w  #128+63,D0move_player68:  add.w   D0,D7                bra.s   move_player71move_player69:  clr.b   D6                moveq   #128-63,D0                tst.w   -14(A6)                beq.s   move_player70                move.w  #128+63,D0move_player70:  add.w   D0,D6move_player71:  move.w  maze_size,D0    ;Ab hier wird verhindert, da§ man                asl.w   #7,D0           ;au§erhalb des Mazes landen kann.                cmp.w   D0,D7                blt.s   move_player72                move.w  D0,D7move_player72:  cmp.w   D0,D6                blt.s   move_player73                move.w  D0,D6move_player73:  tst.w   D7                bpl.s   move_player74                moveq   #0,D7move_player74:  tst.w   D6                bpl.s   move_player75                moveq   #0,D6move_player75:  move.w  D7,ply_y(A0)    ;Die Spielerkoordinaten neu setzen                move.w  D6,ply_x(A0)                move.w  -6(A6),ply_richtung(A0)                move.l  ply_features(A0),D0                btst    #f_nowand,D0    ;durch Wand gehen?                bne.s   move_player79   ;Ja! => raus                asr.w   #7,D7           ;Ab hier:                or.w    #1,D7                asr.w   #7,D6           ;Testen, ob der Spieler von 4 WŠnden                or.w    #1,D6           ;umgeben ist, dann Spieler neu setzen                move.w  D6,-(SP)                move.w  D7,-(SP)                subq.w  #1,(SP)                bsr.s   get_maze_feld   ;(X,Y-1) testen                addq.l  #4,SP                bne.s   move_player79   ;Eine Wand? Nein! =>                move.w  D6,-(SP)                subq.w  #1,(SP)                move.w  D7,-(SP)                bsr.s   get_maze_feld   ;(X-1,Y) testen                addq.l  #4,SP                bne.s   move_player79   ;Eine Wand? Nein! =>                move.w  D6,-(SP)                move.w  D7,-(SP)                addq.w  #1,(SP)                bsr.s   get_maze_feld   ;(X,Y+1) testen                addq.l  #4,SP                bne.s   move_player79   ;Eine Wand? Nein! =>                move.w  D6,-(SP)                addq.w  #1,(SP)                move.w  D7,-(SP)                bsr.s   get_maze_feld   ;(X+1,Y) testen                addq.l  #4,SP                bne.s   move_player79   ;Eine Wand? Nein! =>                move.w  8(A6),-(SP)                bsr     hunt_ply_pos    ;Spieler neu setzen                addq.l  #2,SPmove_player79:  moveq   #0,D0move_player80:  tst.l   (SP)+                movem.l (SP)+,D3-A5                unlk    A6                rtsget_maze_feld:  bsr     get_maze_datayx ;(X+1,Y) testen                subq.w  #1,D0           ;eine Wand?                bne.s   get_maze_feld3  ;Nein! => dann eh ok =>                lea     object_datas,A0get_maze_feld1: tst.w   (A0)            ;Ende der Liste?                beq.s   get_maze_feld4  ;Ja! => Spieler ist umzingelt...                cmp.w   6(A0),D7        ;Y gleich?                bne.s   get_maze_feld2  ;Nein! => zum nŠchsten Eintrag                cmp.w   8(A0),D6        ;X gleich?                beq.s   get_maze_feld3  ;=> Spieler nicht umzingelt =>get_maze_feld2: lea     32(A0),A0       ;zum nŠchsten Eintrag                bra.s   get_maze_feld1  ;und testenget_maze_feld3: moveq   #1,D0           ;Spieler nicht umzingeltget_maze_feld4: rts                ENDPART                >PART 'move_shoot';************************************************************************;* move_shoot(Player) - Schu§ bewegen, Kollision testen                 *;************************************************************************move_shoot:     link    A6,#-20                movem.l D2-A5,-(SP)                move.w  #1,-6(A6)       ;Schu§flag setzen (Schu§ unterwegs)                lea     player_data,A0                move.w  8(A6),D7        ;schie§ender Spieler                move.w  D7,D0                mulu    #ply_size,D0                lea     0(A0,D0.w),A2   ;Zeiger auf den schie§enden Spieler                move.w  ply_shooty(A2),D6 ;Schu§-Koordinate Y                move.w  ply_shootx(A2),D5 ;Schu§-Koordinate X                move.l  ply_features(A2),D2 ;Feature-Maske holen                subq.w  #1,ply_swcounter(A2)                bpl.s   move_shoot0                neg.w   ply_swioffset(A2) ;Vorzeichen drehen                move.w  ply_swioffset(A2),ply_swoffset(A2)                move.w  ply_swcinit(A2),ply_swcounter(A2) ;ZŠhler neu setzenmove_shoot0:    move.w  ply_shootr(A2),D0                add.w   ply_swoffset(A2),D0 ;Winkeloffset drauf                and.w   #$FF,D0                add.w   D0,D0                add.w   D0,D0           ;mal 4 (Wortzeiger)                lea     xy_speed_table,A0                adda.w  D0,A0                move.w  (A0)+,D0        ;Y                move.w  (A0),D1         ;X                btst    #f_sfastshoot,D2 ;schneller Schu§?                beq.s   move_shoot100   ;Nein! =>                add.w   D0,D0           ;Y mal 2                add.w   D1,D1           ;X mal 2move_shoot100:  move.w  D0,ply_sdeltay(A2) ;Geschwindigkeit Y merken                move.w  D1,ply_sdeltax(A2) ;Geschwindigkeit X merken                move.w  D6,D4                asr.w   #7,D4                or.w    #1,D4           ;(Y/128)|1                move.w  D5,D3                asr.w   #7,D3                or.w    #1,D3           ;(X/128)|1                clr.w   -10(A6)         ;Z=0move_shoot1:    lea     player_data,A2                move.w  8(A6),D0        ;schie§ender Spieler                mulu    #ply_size,D0                adda.w  D0,A2                add.w   ply_sdeltay(A2),D6                add.w   ply_sdeltax(A2),D5                move.w  D4,-18(A6)                move.w  D3,-20(A6)                move.w  D6,D4                asr.w   #7,D4                or.w    #1,D4           ;(Y/128)|1                move.w  D5,D3                asr.w   #7,D3                or.w    #1,D3           ;(X/128)|1                cmp.w   -18(A6),D4                bne.s   move_shoot2                cmp.w   -20(A6),D3                beq     move_shoot3move_shoot2:    move.w  -20(A6),D0                add.w   D3,D0                lsr.w   #1,D0                move.w  D0,-(SP)        ;X                move.w  -18(A6),D0                add.w   D4,D0                lsr.w   #1,D0                move.w  D0,-(SP)        ;Y                bsr     get_maze_datayx                addq.l  #4,SP                bmi.s   move_shoot3     ;Eine Wand? Nein! =>                btst    #f_swalls,D2    ;"gro§e" Reichweite?                beq.s   move_shoot21    ;Nein! =>                moveq   #$C0,D0                and.w   D3,D0                bne.s   move_shoot21    ;noch auf der Karte? Nein! =>                moveq   #$C0,D0                and.w   D4,D0                beq.s   move_shoot3     ;Ja! =>move_shoot21:   btst    #f_sreflective,D2 ;Reflektion an?                beq.s   move_shoot22    ;Nein! =>                move.w  ply_shooty(A2),D6 ;Schu§-Koordinate Y                move.w  ply_shootx(A2),D5 ;Schu§-Koordinate X                move.w  -20(A6),D0                add.w   D3,D0                lsr.w   #1,D0                cmp.w   -20(A6),D0      ;X gleich                beq.s   move_shoot23                neg.w   ply_sdeltax(A2)                neg.b   ply_shootr+1(A2) ;X-Reflektionmove_shoot23:   move.w  -18(A6),D0                add.w   D4,D0                lsr.w   #1,D0                cmp.w   -18(A6),D0                beq.s   move_shoot24    ;Y gleich                neg.w   ply_sdeltay(A2)                move.w  #128,D0                sub.w   ply_shootr(A2),D0                move.b  D0,ply_shootr+1(A2) ;Y-Reflektionmove_shoot24:   add.w   ply_sdeltay(A2),D6                add.w   ply_sdeltax(A2),D5                move.w  D6,D4                asr.w   #7,D4                or.w    #1,D4           ;(Y/128)|1                move.w  D5,D3                asr.w   #7,D3                or.w    #1,D3           ;(X/128)|1                bra.s   move_shoot3move_shoot22:   clr.w   ply_shoot(A2)   ;den Schlu§ lšschen, wenn Kollision mit                bra     move_shoot20    ;Wand. Ende =>move_shoot3:    move.w  #-2,-2(A6)      ;Y-Schleifemove_shoot4:    move.w  #-2,-4(A6)      ;X-Schleifemove_shoot5:    move.w  -4(A6),-(SP)    ;X                add.w   D3,(SP)                move.w  -2(A6),-(SP)    ;Y                add.w   D4,(SP)                bsr     get_maze_datayx ;Eintrag im Maze bei (x,y) lesen                addq.l  #4,SP                bra     move_shoot17move_shoot6:    cmp.w   #16,D0          ;ein anderer Schu§?                bge     move_shoot16    ;ja! => dann raus =>                lea     player_data,A1                move.w  D0,D1                mulu    #ply_size,D1                adda.w  D1,A1                cmp.w   D7,D0           ;der eigene Spieler?                beq     move_shoot15    ;dat war wohl nix =>                tst.w   ply_lives(A1)   ;schon tot?                ble     move_shoot15    ;dann kam ich wohl zu spŠt =>                move.w  ply_y(A1),D0                sub.w   D6,D0                bpl.s   move_shoot7                neg.w   D0move_shoot7:    moveq   #48,D1                btst    #f_sradius,D2   ;vergrš§erter Schu§radius?                beq.s   move_shoot71    ;Nein! =>                add.w   D1,D1           ;(ein 3/4 Feld gro§)move_shoot71:   cmp.w   #128,D0         ;Schu§ in der Umgebung?                bhi     move_shoot15                move.w  #50,ply_warnflag(A1) ;Schu§ ist in der Umgebung                cmp.w   D1,D0                bhs     move_shoot15                move.w  ply_x(A1),D0                sub.w   D5,D0                bpl.s   move_shoot8                neg.w   D0move_shoot8:    cmp.w   #128,D0         ;Schu§ in der Umgebung?                bhi     move_shoot15                move.w  #50,ply_warnflag(A1) ;Schu§ ist in der Umgebung                cmp.w   D1,D0                bhs     move_shoot15                cmp.w   own_number,D7   ;"T R E F F E R !!!"                bne.s   move_shoot9     ;Nicht der eigene Spieler =>                movem.l D0-D2/A0-A2,-(SP)                pea     sound_2(PC)                move.w  #$20,-(SP)                trap    #14             ;Treffer "erschallen" lassen (leider...)                addq.l  #6,SP                movem.l (SP)+,D0-D2/A0-A2move_shoot9:    move.l  ply_features(A1),D1 ;Features des Angeschossenen                btst    #f_got_you,D1   ;Selbstmord des SchŸtzen                beq.s   move_shoot90    ;Nein =>                btst    #f_no_got_you,D2 ;kein Selbstmord                bne.s   move_shoot90                tst.w   ply_lives(A2)   ;SchŸtze schon tot?                ble     move_shoot15    ;dann kam ich wohl zu spŠt =>                exg     A1,A2           ;SchŸtzen und Getroffenen austauschen                move.w  -12(A6),D0                exg     D7,D0                move.w  D0,-12(A6)move_shoot90:   move.w  #1,ply_hitflag(A1) ;Treffer-Flag setzen                move.w  D7,ply_gunman(A1) ;den SchŸtzen merken                tst.w   team_flag       ;Teamplay?                beq.s   move_shoot10    ;Nein! =>                move.w  ply_team(A2),D0 ;Team des SchŸtzen ermitteln                cmp.w   ply_team(A1),D0 ;beide im selben Team?                bne.s   move_shoot10    ;Nein! =>                btst    #f_friendly,D1  ;"Friendly fire" an?                bne     move_shoot13    ;Ja! =>                btst    #f_deadly,D1    ;"Deadly fire" an?                beq.s   move_shoot90a   ;Ja! =>                cmpi.w  #1,ply_lives(A1) ;nur noch ein Leben?                beq.s   move_shoot13    ;dann nicht noch was abziehenmove_shoot90a:  move.w  ply_refresh_t(A1),ply_refresh(A1)                subq.w  #1,ply_lives(A1) ;noch min. ein Leben?                bne.s   move_shoot13    ;Ja! =>                bra.s   move_shoot10b   ;der ist tot... =>move_shoot10:   move.w  ply_refresh_t(A1),ply_refresh(A1)                btst    #f_autoanswer,D1 ;Antwort des Angeschossenen                beq.s   move_shoot10c                move.w  ply_shootr(A2),D0 ;Richtung des Schusses des SchŸtzen                eori.w  #128,D0         ;Richtung umdrehen                move.w  D0,ply_shootr(A1) ;Richtung des Schu§es (=> ZurŸck)                move.w  #10,ply_shoot(A1) ;Flag, da§ Schu§ fliegt                move.w  ply_reload_t(A1),ply_reload(A1) ;Reloadtime setzen                move.w  ply_y(A1),ply_shooty(A1) ;Y-Position des Schu§es                move.w  ply_x(A1),ply_shootx(A1) ;X-Position des Schu§es                clr.w   ply_swoffset(A1)                clr.w   ply_swcounter(A1) ;ZŠhler neu setzenmove_shoot10c:  btst    #f_absdeadly,D2 ;tšdlicher Schu§?                beq.s   move_shoot10a   ;Nein! =>                btst    #f_noabsdeadly,D1 ;Gegenwehr?                bne.s   move_shoot10a   ;Ja! =>                move.w  #1,ply_lives(A1) ;alle Leben lšschenmove_shoot10a:  addq.w  #1,ply_hitscore(A2) ;Anzahl der Treffer hochzŠhlen                addq.w  #1,ply_score(A2) ;Punktestand erhšhen                subq.w  #1,ply_lives(A1) ;Leben=0?                bne.s   move_shoot13    ;Nein! =>                addq.w  #2,ply_score(A2) ;Score+3move_shoot10b:  st      ply_looser(A2)  ;Spieler abgeschossen!                addq.w  #1,ply_killscore(A2) ;AbschŸsse+1                move.w  ply_regen_t(A1),ply_refresh(A1)move_shoot13:   move.w  -12(A6),D0                move.b  D0,ply_looser+1(A2) ;angeschossenen Spieler merken                cmp.w   own_number,D0   ;der eigene Spieler angeschossen worden?                bne.s   move_shoot14    ;Nein! =>                movem.l D0-A6,-(SP)                bsr     update_smily    ;Smily neu zeichnen                movem.l (SP)+,D0-A6move_shoot14:   clr.w   -6(A6)          ;der Schu§ ist weg                btst    #f_got_you,D1   ;Selbstmord des SchŸtzen                beq.s   move_shoot13a   ;Nein! =>                btst    #f_no_got_you,D2 ;kein Selbstmord                bne.s   move_shoot13a   ;Nein! =>                exg     A1,A2           ;SchŸtzen und Getroffenen zurŸcktauschen                move.w  -12(A6),D7move_shoot13a:  clr.w   ply_shoot(A2)   ;den Schu§ nun lšschenmove_shoot15:   move.w  ply_plist(A1),D0                bra.s   move_shoot17move_shoot16:   move.w  -12(A6),D0                sub.w   #16,D0                mulu    #ply_size,D0                add.l   #player_data,D0                movea.l D0,A1                move.w  ply_slist(A1),D0move_shoot17:   move.w  D0,-12(A6)                bpl     move_shoot6     ;Nein! =>                addq.w  #2,-4(A6)       ;X+2                cmpi.w  #2,-4(A6)                bgt.s   move_shoot18                tst.w   -6(A6)                bne     move_shoot5move_shoot18:   addq.w  #2,-2(A6)       ;Y+2                cmpi.w  #2,-2(A6)                bgt.s   move_shoot19                tst.w   -6(A6)                bne     move_shoot4move_shoot19:   addq.w  #1,-10(A6)      ;Z+1                cmpi.w  #3,-10(A6)                blo     move_shoot1move_shoot20:   move.w  D6,ply_shooty(A2) ;Schu§-Koordinate Y neu setzen                move.w  D5,ply_shootx(A2) ;Schu§-Koordinate X neu setzen                movem.l (SP)+,D2-A5                unlk    A6                rts                ENDPART                >PART 'Grafik-Allg';************************************************************************;* Die Grafiktreiber                                                    *;************************************************************************calc_160_tab:   lea     mult_tab_160,A0                clr.w   D0                move.w  #255,D1calc_160_tab1:  move.w  D0,(A0)+                add.w   #160,D0                dbra    D1,calc_160_tab1                rtscalc_80_tab:    lea     mult_tab_80,A0                clr.w   D0                move.w  #399,D1calc_80_tab1:   move.w  D0,(A0)+                add.w   #80,D0                dbra    D1,calc_80_tab1                rts                ENDPART                >PART 'Grafik-SW'************************************************************************* Grafiktreiber fŸr S/W                                                *************************************************************************dr_sw_shape:    link    A6,#-2                movem.l D0-D7,-(SP)                movea.l screen_offs_adr,A0                move.w  10(A6),D2       ;Y                add.w   D2,D2                move.w  D2,-2(A6)                lea     mult_tab_80,A2                move.w  0(A2,D2.w),D2                lea     0(A0,D2.w),A1                movea.l 20(A6),A2       ;FŸllmuster/Farbe                movea.l 12(A6),A0       ;Zeiger auf die Daten                move.w  18(A6),D5       ;Zeilenzahl                subq.w  #1,D5                move.w  8(A6),D2        ;X                move.w  D2,D4                andi.w  #$0F,D2                asr.w   #4,D4           ;X/16                add.w   16(A6),D4       ;???                add.w   D4,D4           ;mal 2                move.w  D4,8(A6)        ;und merken                subq.w  #1,16(A6)                cmp.w   #8,D2                bgt.s   dr_sw_shape3dr_sw_shape1:   move.w  8(A6),D4                move.w  16(A6),D3                move.w  -2(A6),D6                andi.w  #6,D6                move.w  2(A2,D6.w),D7                move.w  0(A2,D6.w),D6                move.w  D5,-(SP)                clr.w   D1dr_sw_shape2:   move.w  -(A0),D0                swap    D0                move.w  D1,D0                lsr.l   D2,D0                bsr.s   dr_sw_shape6                subq.w  #2,D4                move.w  (A0),D1                dbra    D3,dr_sw_shape2                lsr.w   D2,D1                move.w  D1,D0                bsr.s   dr_sw_shape6                subq.w  #2,D4                suba.w  #160,A1                subq.w  #4,-2(A6)                move.w  (SP)+,D5                dbra    D5,dr_sw_shape1                movem.l (SP)+,D0-D7                unlk    A6                rtsdr_sw_shape3:   neg.w   D2                add.w   #16,D2dr_sw_shape4:   move.w  8(A6),D4                move.w  16(A6),D3                move.w  -2(A6),D6                andi.w  #6,D6                move.w  2(A2,D6.w),D7                move.w  0(A2,D6.w),D6                move.w  D5,-(SP)                moveq   #0,D0                clr.w   D1dr_sw_shape5:   move.w  -(A0),D0                asl.l   D2,D0                or.w    D1,D0                bsr.s   dr_sw_shape6                clr.w   D0                swap    D0                move.w  D0,D1                subq.w  #2,D4                dbra    D3,dr_sw_shape5                move.w  D1,D0                bsr.s   dr_sw_shape6                suba.w  #160,A1                subq.w  #4,-2(A6)                move.w  (SP)+,D5                dbra    D5,dr_sw_shape4                movem.l (SP)+,D0-D7                unlk    A6                rtsdr_sw_shape6:   cmp.w   #40,D4                bhs.s   dr_sw_shape7                move.w  0(A1,D4.w),D5                eor.w   D7,D5                and.w   D0,D5                eor.w   D5,0(A1,D4.w)                move.w  -80(A1,D4.w),D5                eor.w   D6,D5                and.w   D0,D5                eor.w   D5,-80(A1,D4.w)dr_sw_shape7:   rts************************************************************************* H-Linie ziehen************************************************************************dr_sw_hline:    link    A6,#0                movem.l D0-D7,-(SP)                move.w  8(A6),D0        ;X1                move.w  10(A6),D1       ;X2                move.w  12(A6),D2       ;Y                move.w  14(A6),D3       ;Farbe/FŸllmuster                movea.l screen_offs_adr,A0                bsr     sw_fill_line                movem.l (SP)+,D0-D7                unlk    A6                rts*************************************************************************************************************************************************dr_sw_chline:   link    A6,#0                movem.l D0-D7,-(SP)                move.w  8(A6),D0        ;X1                move.w  10(A6),D1       ;X2                move.w  12(A6),D2       ;Y                move.w  14(A6),D3       ;Farbe/FŸllmuster                movea.l screen_offs_adr,A0                bsr     sw_fill_cline                movem.l (SP)+,D0-D7                unlk    A6                rts*************************************************************************************************************************************************dr_sw_vline:    link    A6,#0                movem.l D0-D7,-(SP)                move.w  8(A6),D0        ;Y1                move.w  10(A6),D1       ;Y2                move.w  12(A6),D2       ;X                move.w  14(A6),D3       ;FŸllmuster                movea.l screen_offs_adr,A0                bsr     sw_fill_vline                movem.l (SP)+,D0-D7                unlk    A6                rts************************************************************************* clr_sbitblk(X1,Y1,X2,Y2,Farbe) fŸr S/W************************************************************************dr_sw_box:      link    A6,#0                movem.l D3-D7,-(SP)                move.w  8(A6),D0        ;X1                move.w  12(A6),D1       ;X2                move.w  16(A6),D3       ;Farbe/FŸllmuster                movea.l screen_offs_adr,A0                move.w  10(A6),D2       ;Y1dr_sw_box1:     bsr     sw_fill_line                addq.w  #1,10(A6)       ;Y1+1                move.w  10(A6),D2                cmp.w   14(A6),D2       ;Y2>Y1?                bls.s   dr_sw_box1      ;Nein! =>                movem.l (SP)+,D3-D7                unlk    A6                rtsdr_sw_cbox:     link    A6,#0                movem.l D0-D7,-(SP)                move.w  8(A6),D0                move.w  12(A6),D1                movea.l screen_offs_adr,A0                move.w  10(A6),D2dr_sw_cbox1:    move.w  16(A6),D3                bsr     sw_fill_cline                addq.w  #1,10(A6)                move.w  10(A6),D2                cmp.w   14(A6),D2                bls.s   dr_sw_cbox1                movem.l (SP)+,D0-D7                unlk    A6                rtsclr_sw_window:  movea.l screen_offs_adr,A0                move.w  #height-1,D0                moveq   #-1,D2clr_sw_window1: moveq   #9,D1clr_sw_window2: move.l  D2,(A0)+                dbra    D1,clr_sw_window2                lea     40(A0),A0                dbra    D0,clr_sw_window1                moveq   #height/2,D0clr_sw_window3: moveq   #9,D1clr_sw_window4: move.l  D2,(A0)+                dbra    D1,clr_sw_window4                lea     40(A0),A0                eori.l  #$AAAAAAAA,D2                moveq   #9,D1clr_sw_window5: move.l  D2,(A0)+                dbra    D1,clr_sw_window5                lea     40(A0),A0                eori.l  #$AAAAAAAA,D2                dbra    D0,clr_sw_window3                rtssw_fill_line:   lea     sw_farbfŸll_tab(PC),A2                move.w  D3,D7           ;Farbe/FŸllmuster                asl.w   #2,D7                movea.l 0(A2,D7.w),A2   ;Zeiger auf das entsprechende Muster                move.w  D2,D7           ;Zeile                add.w   D7,D7                and.w   #6,D7                move.w  2(A2,D7.w),D7                cmp.w   D0,D1                bge.s   fill_sline1                exg     D1,D0fill_sline1:    add.w   D2,D2           ;Wortzeiger auf die Tabelle                lea     mult_tab_80,A2                move.w  0(A2,D2.w),D2   ;Zeilenoffset holen                move.w  D0,D4                lsr.w   #4,D4                add.w   D4,D4                add.w   D4,D2           ;+INT(X1/16)*2                lea     0(A0,D2.w),A1   ;Zeiger auf die Adresse im Screen                move.w  D0,D4                lsr.w   #4,D4                move.w  D1,D2                lsr.w   #4,D2                sub.w   D4,D2                subq.w  #1,D2                bge.s   fill_sline2                move.w  D0,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_a(PC),A2                move.w  0(A2,D4.w),D5                move.w  D1,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_b(PC),A2                and.w   0(A2,D4.w),D5                bra.s   fill_sline5fill_sline2:    move.w  D0,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_a(PC),A2                move.w  0(A2,D4.w),D5                bsr.s   fill_sline5                bra.s   fill_sline4fill_sline3:    move.w  D7,(A1)+fill_sline4:    dbra    D2,fill_sline3                move.w  D1,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_b(PC),A2                move.w  0(A2,D4.w),D5fill_sline5:    move.w  (A1),D6                eor.w   D7,(A1)                and.w   D5,(A1)                eor.w   D6,(A1)+                rtssw_fill_cline:  lea     sw_farbfŸll_tab(PC),A2                move.w  D3,D7                asl.w   #2,D7                movea.l 0(A2,D7.w),A2                add.w   D2,D2                move.w  D2,D7                addq.w  #1,D7                add.w   D7,D7                andi.w  #6,D7                move.w  0(A2,D7.w),D3                move.w  2(A2,D7.w),D7                cmp.w   D0,D1                bge.s   sw_fill_cline1                exg     D1,D0sw_fill_cline1: lea     mult_tab_160,A2                move.w  0(A2,D2.w),D2                move.w  D0,D4                lsr.w   #4,D4                add.w   D4,D4                add.w   D4,D2                lea     0(A0,D2.w),A1                move.w  D0,D4                lsr.w   #4,D4                move.w  D1,D2                lsr.w   #4,D2                sub.w   D4,D2                subq.w  #1,D2                bge.s   sw_fill_cline2                move.w  D0,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_a(PC),A2                move.w  0(A2,D4.w),D5                move.w  D1,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_b(PC),A2                and.w   0(A2,D4.w),D5                bra.s   sw_fill_cline5sw_fill_cline2: move.w  D0,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_a(PC),A2                move.w  0(A2,D4.w),D5                bsr.s   sw_fill_cline5                bra.s   sw_fill_cline4sw_fill_cline3: move.w  D7,80(A1)                move.w  D3,(A1)+sw_fill_cline4: dbra    D2,sw_fill_cline3                move.w  D1,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_b(PC),A2                move.w  0(A2,D4.w),D5sw_fill_cline5: move.w  (A1),D6                eor.w   D3,(A1)                and.w   D5,(A1)                eor.w   D6,(A1)                lea     80(A1),A1                move.w  (A1),D6                eor.w   D7,(A1)                and.w   D5,(A1)                eor.w   D6,(A1)+                lea     -80(A1),A1                rtssw_fill_vline:  cmp.w   D0,D1                bge.s   sw_fill_vline1                exg     D1,D0sw_fill_vline1: sub.w   D0,D1           ;LŠnge der Linie                add.w   D0,D0                lea     mult_tab_80,A2                adda.w  0(A2,D0.w),A0   ;Zeilenoffset                move.w  D2,D4                lsr.w   #3,D4                and.w   #-2,D4                adda.w  D4,A0           ;Word-Offset der Spalte dazu                and.w   #$0F,D2                add.w   D2,D2           ;Pixelposition der Spalte                lea     bmask_c(PC),A2                move.w  0(A2,D2.w),D5   ;Maske fŸr die Pixelposition                move.w  D5,D6                not.w   D6                lea     sw_farbfŸll_tab(PC),A1                lsl.w   #2,D3                movea.l 0(A1,D3.w),A1sw_fill_vline2: and.w   #6,D0                move.w  0(A1,D0.w),D3                addq.w  #2,D0                and.w   D5,D3                beq.s   sw_fill_vline3                or.w    D5,(A0)                bra.s   sw_fill_vline4sw_fill_vline3: and.w   D6,(A0)sw_fill_vline4: lea     80(A0),A0                dbra    D1,sw_fill_vline2                rts                ENDPART                >PART 'Grafik-Farbe'************************************************************************* Grafiktreiber fŸr Farbe                                              *************************************************************************dr_c_shape:     link    A6,#0                movem.l D0-D7,-(SP)                movea.l screen_offs_adr,A0                move.w  10(A6),D2                add.w   D2,D2                lea     mult_tab_160,A2                move.w  0(A2,D2.w),D2                lea     0(A0,D2.w),A1                movea.l 20(A6),A2                movea.l 12(A6),A0                move.w  18(A6),D5                subq.w  #1,D5                move.w  8(A6),D2                move.w  D2,D4                andi.w  #$0F,D2                asr.w   #4,D4                add.w   16(A6),D4                asl.w   #3,D4                move.w  D4,8(A6)                subq.w  #1,16(A6)                cmp.w   #8,D2                bgt.s   dr_c_shape3dr_c_shape1:    move.w  8(A6),D4                move.w  16(A6),D3                clr.w   D1dr_c_shape2:    move.w  -(A0),D0                swap    D0                move.w  D1,D0                lsr.l   D2,D0                bsr.s   dr_c_shape6                subq.w  #8,D4                move.w  (A0),D1                dbra    D3,dr_c_shape2                lsr.w   D2,D1                move.w  D1,D0                bsr.s   dr_c_shape6                lea     -160(A1),A1                dbra    D5,dr_c_shape1                movem.l (SP)+,D0-D7                unlk    A6                rtsdr_c_shape3:    neg.w   D2                add.w   #16,D2dr_c_shape4:    move.w  8(A6),D4                move.w  16(A6),D3                moveq   #0,D0                clr.w   D1dr_c_shape5:    move.w  -(A0),D0                asl.l   D2,D0                or.w    D1,D0                bsr.s   dr_c_shape6                clr.w   D0                swap    D0                move.w  D0,D1                subq.w  #8,D4                dbra    D3,dr_c_shape5                move.w  D1,D0                bsr.s   dr_c_shape6                lea     -160(A1),A1                dbra    D5,dr_c_shape4                movem.l (SP)+,D0-D7                unlk    A6                rtsdr_c_shape6:    cmp.w   #80,D4                bhs.s   dr_c_shape7                move.w  D0,D6                not.w   D6                jmp     (A2)dr_c_shape7:    rtsdr_c_shape8:    and.w   D6,6(A1,D4.w)                and.w   D6,4(A1,D4.w)                and.w   D6,2(A1,D4.w)                and.w   D6,0(A1,D4.w)                rtsdr_c_shape9:    and.w   D6,6(A1,D4.w)                and.w   D6,4(A1,D4.w)                and.w   D6,2(A1,D4.w)                or.w    D0,0(A1,D4.w)                rtsdr_c_shape10:   and.w   D6,6(A1,D4.w)                and.w   D6,4(A1,D4.w)                or.w    D0,2(A1,D4.w)                and.w   D6,0(A1,D4.w)                rtsdr_c_shape11:   and.w   D6,6(A1,D4.w)                and.w   D6,4(A1,D4.w)                or.w    D0,2(A1,D4.w)                or.w    D0,0(A1,D4.w)                rtsdr_c_shape12:   and.w   D6,6(A1,D4.w)                or.w    D0,4(A1,D4.w)                and.w   D6,2(A1,D4.w)                and.w   D6,0(A1,D4.w)                rtsdr_c_shape13:   and.w   D6,6(A1,D4.w)                or.w    D0,4(A1,D4.w)                and.w   D6,2(A1,D4.w)                or.w    D0,0(A1,D4.w)                rtsdr_c_shape14:   and.w   D6,6(A1,D4.w)                or.w    D0,4(A1,D4.w)                or.w    D0,2(A1,D4.w)                and.w   D6,0(A1,D4.w)                rtsdr_c_shape15:   and.w   D6,6(A1,D4.w)                or.w    D0,4(A1,D4.w)                or.w    D0,2(A1,D4.w)                or.w    D0,0(A1,D4.w)                rtsdr_c_shape16:   or.w    D0,6(A1,D4.w)                and.w   D6,4(A1,D4.w)                and.w   D6,2(A1,D4.w)                and.w   D6,0(A1,D4.w)                rtsdr_c_shape17:   or.w    D0,6(A1,D4.w)                and.w   D6,4(A1,D4.w)                and.w   D6,2(A1,D4.w)                or.w    D0,0(A1,D4.w)                rtsdr_c_shape18:   or.w    D0,6(A1,D4.w)                and.w   D6,4(A1,D4.w)                or.w    D0,2(A1,D4.w)                and.w   D6,0(A1,D4.w)                rtsdr_c_shape19:   or.w    D0,6(A1,D4.w)                and.w   D6,4(A1,D4.w)                or.w    D0,2(A1,D4.w)                or.w    D0,0(A1,D4.w)                rtsdr_c_shape20:   or.w    D0,6(A1,D4.w)                or.w    D0,4(A1,D4.w)                and.w   D6,2(A1,D4.w)                and.w   D6,0(A1,D4.w)                rtsdr_c_shape21:   or.w    D0,6(A1,D4.w)                or.w    D0,4(A1,D4.w)                and.w   D6,2(A1,D4.w)                or.w    D0,0(A1,D4.w)                rtsdr_c_shape22:   or.w    D0,6(A1,D4.w)                or.w    D0,4(A1,D4.w)                or.w    D0,2(A1,D4.w)                and.w   D6,0(A1,D4.w)                rtsdr_c_shape23:   or.w    D0,6(A1,D4.w)                or.w    D0,4(A1,D4.w)                or.w    D0,2(A1,D4.w)                or.w    D0,0(A1,D4.w)                rtsdr_c_cline:     link    A6,#0                movem.l D0-D7,-(SP)                move.w  8(A6),D0                move.w  10(A6),D1                move.w  12(A6),D2                move.w  14(A6),D3                movea.l screen_offs_adr,A0                bsr     fill_cline                movem.l (SP)+,D0-D7                unlk    A6                rtsdr_c_cvline:    link    A6,#0                movem.l D0-D7,-(SP)                move.w  8(A6),D0        ;X1                move.w  10(A6),D1       ;X2                move.w  12(A6),D2       ;Y                move.w  14(A6),D3       ;Farbe                movea.l screen_offs_adr,A0                bsr     fill_vline                movem.l (SP)+,D0-D7                unlk    A6                rts************************************************************************* clr_sbitblk(X1,Y1,X2,Y2,Farbe) fŸr Farbe************************************************************************dr_c_box:       link    A6,#0                movem.l D0-D7,-(SP)                move.w  8(A6),D0        ;X1                move.w  12(A6),D1       ;X2                move.w  16(A6),D3       ;Farbe                movea.l screen_offs_adr,A0                move.w  10(A6),D2       ;Y1dr_c_box1:      bsr.s   fill_cline                addq.w  #1,10(A6)       ;Y1+1                move.w  10(A6),D2                cmp.w   14(A6),D2       ;Y2<Y1?                bls.s   dr_c_box1       ;Nein! =>                movem.l (SP)+,D0-D7                unlk    A6                rtsclr_cwindow:    movea.l screen_offs_adr,A0                moveq   #-1,D2                moveq   #height/2-1,D0clr_cwindow1:   moveq   #4,D1clr_cwindow2:   move.l  D2,(A0)+                clr.l   (A0)+                move.l  D2,(A0)+                clr.l   (A0)+                dbra    D1,clr_cwindow2                lea     80(A0),A0                dbra    D0,clr_cwindow1                moveq   #height/2,D0clr_cwindow3:   moveq   #9,D1clr_cwindow4:   move.w  D2,(A0)+                move.l  D2,(A0)+                clr.w   (A0)+                dbra    D1,clr_cwindow4                lea     80(A0),A0                dbra    D0,clr_cwindow3                rtsfill_cline:     cmp.w   D0,D1                bge.s   fill_cline1                exg     D1,D0fill_cline1:    add.w   D2,D2                lea     mult_tab_160,A2                move.w  0(A2,D2.w),D2                move.w  D0,D4                lsr.w   #4,D4                asl.w   #3,D4                add.w   D4,D2                lea     0(A0,D2.w),A1                move.w  D0,D4                lsr.w   #4,D4                move.w  D1,D2                lsr.w   #4,D2                sub.w   D4,D2                subq.w  #1,D2                bge.s   fill_cline2                move.w  D0,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_a(PC),A2                move.w  0(A2,D4.w),D5                move.w  D1,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_b(PC),A2                and.w   0(A2,D4.w),D5                bra.s   fill_cline5fill_cline2:    move.w  D0,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_a(PC),A2                move.w  0(A2,D4.w),D5                bsr.s   fill_cline5                subq.w  #1,D2                bmi.s   fill_cline4                lea     bmask_d(PC),A2                move.w  D3,D4                andi.w  #3,D4                asl.w   #2,D4                move.l  0(A2,D4.w),D6                move.w  D3,D4                andi.w  #$0C,D4                move.l  0(A2,D4.w),D7fill_cline3:    move.l  D6,(A1)+                move.l  D7,(A1)+                dbra    D2,fill_cline3fill_cline4:    move.w  D1,D4                andi.w  #$0F,D4                add.w   D4,D4                lea     bmask_b(PC),A2                move.w  0(A2,D4.w),D5fill_cline5:    move.w  D5,D6                not.w   D6fill_cline6:    btst    #0,D3                beq.s   fill_cline7                or.w    D5,(A1)+                bra.s   fill_cline8fill_cline7:    and.w   D6,(A1)+fill_cline8:    btst    #1,D3                beq.s   fill_cline9                or.w    D5,(A1)+                bra.s   fill_cline10fill_cline9:    and.w   D6,(A1)+fill_cline10:   btst    #2,D3                beq.s   fill_cline11                or.w    D5,(A1)+                bra.s   fill_cline12fill_cline11:   and.w   D6,(A1)+fill_cline12:   btst    #3,D3                beq.s   fill_cline13                or.w    D5,(A1)+                rtsfill_cline13:   and.w   D6,(A1)+                rtsfill_vline:     cmp.w   D0,D1                bge.s   fill_vline1                exg     D1,D0fill_vline1:    sub.w   D0,D1                add.w   D0,D0                lea     mult_tab_160,A2                move.w  0(A2,D0.w),D0                move.w  D2,D4                lsr.w   #1,D4                andi.w  #-8,D4                add.w   D0,D4                lea     0(A0,D4.w),A1                and.w   #$0F,D2                add.w   D2,D2                lea     bmask_c(PC),A2                move.w  0(A2,D2.w),D5                move.w  D5,D6                not.w   D6fill_vline2:    bsr.s   fill_cline6                lea     152(A1),A1                dbra    D1,fill_vline2                rts                ENDPART                >PART 'aes'     ;fŸr den File-Selector************************************************************************* Mein eigener kleiner AES-Aufruf                                      ** D0=Die ersten 4 EintrŠge im contrl-Array (Bytebreite!)               *************************************************************************aes:            movem.l D1-A6,-(SP)     ;besser retten, man kann nie wissen                lea     control,A0                clr.l   (A0)                clr.l   4(A0)           ;contrl-Array lšschen                movep.l D0,1(A0)        ;und die neuen Daten eintragen                lea     aes_pb(PC),A0                move.l  A0,D1                move.w  #200,D0                trap    #2              ;AES aufrufen                move.w  int_out,D0                movem.l (SP)+,D1-A6                rtsaes_pb:         DC.L control    ;Der AES-Parameterblock                DC.L global                DC.L int_in                DC.L int_out                DC.L addr_in                DC.L addr_outfsel_input      EQU $5A000202fsel_exinput    EQU $5B000203   ;ab TOS 1.4appl_init       EQU $0A000100appl_exit       EQU $13000100                ENDPART                >PART 'play_tmusic'************************************************************************* Die Titelmusik nachladen und spielen************************************************************************play_tmusic:    bsr     check_con       ;Taste gedrŸckt?                bne     play_tmusic8    ;Ja! => raus                move.l  #500000,-(SP)                move.w  #$48,-(SP)                trap    #1              ;Malloc()                addq.l  #6,SP                tst.l   D0                beq     play_tmusic8                movea.l D0,A5                lea     sound_str(PC),A0                bsr     print_line                lea     play_routine(PC),A0                movea.l A5,A1                move.w  #(play_routine_e-play_routine)/4-1,D0play_tmusic2:   move.l  (A0)+,(A1)+     ;Routine in den Buffer kopieren                dbra    D0,play_tmusic2                clr.w   $36(A5)         ;Maus nicht sichtbar                jsr     (A5)                lea     title_song(PC),A1                lea     $0160(A5),A0play_tmusic3:   move.b  (A1)+,(A0)+                bne.s   play_tmusic3                bsr     check_con       ;Taste gedrŸckt?                bne.s   play_tmusic7    ;Ja! => raus                jsr     (A5)                tst.l   $24(A5)         ;TOS-Fehler?                bmi.s   play_tmusic7    ;Ja! => raus                bsr     check_con       ;Taste gedrŸckt?                bne.s   play_tmusic7    ;Ja! => raus                jsr     (A5)                tst.l   $24(A5)         ;TOS-Fehler?                bmi.s   play_tmusic7    ;Ja! => raus                bsr     check_con       ;Taste gedrŸckt?                bne.s   play_tmusic7    ;Ja! => raus                jsr     (A5)                tst.l   $24(A5)         ;TOS-Fehler?                bmi.s   play_tmusic7    ;Ja! => raus                bsr     check_con       ;Taste gedrŸckt?                bne.s   play_tmusic7    ;Ja! => raus                jsr     (A5)play_tmusic4:   jsr     (A5)                moveq   #1,D0                cmp.l   $24(A5),D0      ;Taste bei Keyboard oder Maus?                bne.s   play_tmusic4    ;Nein! => weiter                move.w  #-1,$1A(A5)     ;STOP setzen                bra.s   play_tmusic6play_tmusic5:   jsr     (A5)play_tmusic6:   tst.w   $2A(A5)         ;Play beendet?                blt.s   play_tmusic5    ;Nein! => warten                clr.l   -(SP)                move.w  #$20,-(SP)                trap    #1              ;Supervisormode an                move.l  D0,2(SP)                move.b  #$03,$FFFFFC04.w ;MIDI zurŸcksetzen                move.b  #$95,$FFFFFC04.w                trap    #1              ;und wieder aus                addq.l  #6,SPplay_tmusic7:   move.l  A5,-(SP)                move.w  #$49,-(SP)                trap    #1              ;Mfree()                addq.l  #6,SPplay_tmusic8:   rtstitle_song:     DC.B 'MIDIMAZE.CMP',0 ;Name der Titelmusicsound_str:      DC.B 'Soundtrack by JŸrgen Piscol',0                EVENplay_routine:   IBYTES 'SMS_SMP.IMG' ;Die Abspielroutineplay_routine_e: ENDPART                DATAcolor_palette:  DC.W $00,$0566,$0455,$0227                DC.W $0444,$0122,$0344,$0233                DC.W $0770,$0740,$0403,$0707                DC.W $57,$60,$0700,$0777color_ply_back: DC.W 8,3,9,13                DC.W 11,12,10,15                DC.W 8,3,9,13                DC.W 11,12,10,15color_ply_frame:DC.W 0,0,0,0                DC.W 0,0,0,0                DC.W 10,11,10,11                DC.W 10,10,11,10face_shape_tab: DC.W 0,19,18,17 ;Shapenummern fŸr die Blickrichtung                DC.W 16,15,14,13 ;in AbhŠngigkeit vom Blickwinkel                DC.W 12,11,10,10 ;in 11¬¡ (32 pro 256)                DC.W 10,10,10,10                DC.W 10,10,10,10                DC.W 10,10,9,8                DC.W 7,6,5,4                DC.W 3,2,1,0live_shape_img: DC.B $00,$FF,$00,$00,$03,$00,$C0,$00                DC.B $0C,$00,$30,$00,$11,$81,$88,$00                DC.B $23,$C3,$C4,$00,$43,$C3,$C2,$00                DC.B $43,$C3,$C2,$00,$83,$C3,$C1,$00                DC.B $83,$C3,$C1,$00,$81,$81,$81,$00                DC.B $80,$00,$01,$00,$98,$00,$19,$00                DC.B $8C,$00,$31,$00,$46,$00,$62,$00                DC.B $43,$81,$C2,$00,$20,$FF,$04,$00                DC.B $10,$00,$08,$00,$0C,$00,$30,$00                DC.B $03,$00,$C0,$00,$00,$FF,$00,$00                DC.B $00,$FF,$00,$00,$03,$00,$C0,$00                DC.B $0C,$00,$30,$00,$11,$81,$88,$00                DC.B $23,$C3,$C4,$00,$43,$C3,$C2,$00                DC.B $43,$C3,$C2,$00,$83,$C3,$C1,$00                DC.B $83,$C3,$C1,$00,$81,$81,$81,$00                DC.B $80,$00,$01,$00,$80,$00,$01,$00                DC.B $80,$00,$01,$00,$43,$FF,$C2,$00                DC.B $44,$00,$22,$00,$20,$00,$04,$00                DC.B $10,$00,$08,$00,$0C,$00,$30,$00                DC.B $03,$00,$C0,$00,$00,$FF,$00,$00                DC.B $00,$FF,$00,$00,$03,$00,$C0,$00                DC.B $0C,$00,$30,$00,$11,$81,$88,$00                DC.B $23,$C3,$C4,$00,$43,$C3,$C2,$00                DC.B $43,$C3,$C2,$00,$83,$C3,$C1,$00                DC.B $83,$C3,$C1,$00,$81,$81,$81,$00                DC.B $80,$00,$01,$00,$80,$00,$01,$00                DC.B $80,$00,$01,$00,$40,$7E,$02,$00                DC.B $41,$81,$82,$00,$22,$00,$44,$00                DC.B $10,$00,$08,$00,$0C,$00,$30,$00                DC.B $03,$00,$C0,$00,$00,$FF,$00,$00                DC.B $00,$FF,$00,$00,$03,$00,$C0,$00                DC.B $0C,$00,$30,$00,$10,$00,$08,$00                DC.B $22,$81,$44,$00,$41,$00,$82,$00                DC.B $42,$81,$42,$00,$84,$00,$21,$00                DC.B $80,$00,$01,$00,$80,$00,$01,$00                DC.B $80,$00,$01,$00,$80,$7F,$01,$00                DC.B $81,$80,$C1,$00,$42,$00,$22,$00                DC.B $40,$00,$02,$00,$20,$00,$04,$00                DC.B $10,$00,$08,$00,$0C,$00,$30,$00                DC.B $03,$00,$C0,$00,$00,$FF,$00,$00                DS.W 24                DC.B $00,$7F,$00,$00,$00,$7F,$00,$00                DC.B $00,$3E,$00,$00,$00,$1C,$00,$00                DS.W 208wand_farb_tab:  DC.W 2          ;andere Perspektive                DC.W 6          ;normale Wandfarbe (bei SW=2)                DC.W 8          ;andere Perspektive                DC.W 8          ;Doorbmask_d:        DC.W $00,$00,$FFFF,$00                DC.W $00,$FFFF,$FFFF,$FFFFbmask_a:        DC.W $FFFF,$7FFF,$3FFF,$1FFF                DC.W $0FFF,$07FF,$03FF,$01FF                DC.W $FF,$7F,$3F,$1F                DC.W $0F,$07,$03,$01bmask_b:        DC.W $8000,$C000,$E000,$F000                DC.W $F800,$FC00,$FE00,$FF00                DC.W $FF80,$FFC0,$FFE0,$FFF0                DC.W $FFF8,$FFFC,$FFFE,$FFFFbmask_c:        DC.W $8000,$4000,$2000,$1000                DC.W $0800,$0400,$0200,$0100                DC.W $80,$40,$20,$10                DC.W $08,$04,$02,$01fm_sw_0:        DS.W 5fm_sw_1:        DS.W 5,-1fm_sw_muster0:  DC.W $AAAA,$5555,$AAAA,$5555,$AAAAfm_sw_muster1:  DC.W $00,$FFFF,$00,$FFFF,$00fm_sw_muster2:  DC.W $AAAA,$AAAA,$AAAA,$AAAA,$AAAAfm_sw_muster3:  DC.W $1111,$8888,$4444,$2222,$1111fm_sw_muster4:  DC.W $8888,$1111,$2222,$4444,$8888fm_sw_muster5:  DC.W $4444,$8888,$4444,$2222,$4444fm_sw_muster6:  DC.W $00,$8888,$5555,$2222,$00fm_sw_muster7:  DC.W $4444,$2222,$5555,$AAAA,$4444fm_sw_muster8:  DC.W $00,$CCCC,$CCCC,$00,$00fm_sw_muster9:  DC.W $9249,$CCCC,$6666,$3333,$9249fm_sw_muster10: DC.W $6666,$CCCC,$9999,$3333,$6666fm_sw_muster11: DC.W $8888,$FFFF,$8888,$8888,$8888fm_sw_muster12: DC.W $00,$EEEE,$00,$7777,$00fm_sw_muster13: DC.W $00,$4444,$EEEE,$4444,$00fm_sw_muster14: DC.W $2222,$8888,$AAAA,$AAAA,$2222fm_sw_muster15: DC.W $00,$4444,$AAAA,$4444,$00fm_sw_muster16: DC.W $3333,$CCCC,$CCCC,$3333,$3333sw_farbfŸll_tab:DC.L fm_sw_0                DC.L fm_sw_1sw_fŸllmuster:  DC.L fm_sw_muster0                DC.L fm_sw_muster1                DC.L fm_sw_muster2                DC.L fm_sw_muster3                DC.L fm_sw_muster4                DC.L fm_sw_muster5                DC.L fm_sw_muster6                DC.L fm_sw_muster7                DC.L fm_sw_muster8                DC.L fm_sw_muster9                DC.L fm_sw_muster10                DC.L fm_sw_muster11                DC.L fm_sw_muster12                DC.L fm_sw_muster13                DC.L fm_sw_muster14                DC.L fm_sw_muster15                DC.L fm_sw_muster16col_farb_jmptab:DC.L dr_c_shape8                DC.L dr_c_shape9                DC.L dr_c_shape10                DC.L dr_c_shape11                DC.L dr_c_shape12dr_c_shp_tab2:  DC.L dr_c_shape13                DC.L dr_c_shape14                DC.L dr_c_shape15                DC.L dr_c_shape16                DC.L dr_c_shape17                DC.L dr_c_shape18                DC.L dr_c_shape19                DC.L dr_c_shape20                DC.L dr_c_shape21col_farb2jmptab:DC.L dr_c_shape22                DC.L dr_c_shape23richtung_table: DC.W -7,-7,1,9,-1,1,0 ;N                DC.W 8,8,-8,0,1,-1,1 ;NO                DC.W -7,8,9,0,1,1,1 ;O                DC.W 8,-7,0,9,1,1,0 ;SO                DC.W 8,8,0,-8,1,-1,0 ;S                DC.W -7,-7,9,1,-1,1,1 ;SW                DC.W 8,-7,-8,1,-1,-1,1 ;W                DC.W -7,8,1,-8,-1,-1,0 ;NWsound_1:        DC.B $07,$34,$08,$00,$09,$00,$01,$00                DC.B $03,$00,$00,$96,$08,$0F,$06,$04                DC.B $02,$C8,$09,$0F,$82,$01,$00,$82                DC.B $08,$0E,$06,$06,$02,$B4,$09,$0E                DC.B $82,$01,$00,$8C,$08,$0D,$06,$08                DC.B $02,$BE,$09,$0D,$82,$01,$00,$78                DC.B $08,$0C,$06,$0A,$02,$AA,$09,$0C                DC.B $82,$01,$00,$82,$08,$0B,$06,$0C                DC.B $02,$B4,$09,$0B,$82,$01,$00,$6E                DC.B $08,$0A,$06,$0E,$02,$A0,$09,$0A                DC.B $82,$01,$00,$78,$08,$09,$06,$10                DC.B $02,$AA,$09,$09,$82,$01,$00,$64                DC.B $08,$08,$06,$12,$02,$96,$09,$08                DC.B $82,$01,$00,$6E,$08,$07,$06,$14                DC.B $02,$A0,$09,$07,$82,$01,$00,$5A                DC.B $08,$06,$06,$16,$02,$8C,$09,$06                DC.B $82,$01,$00,$64,$08,$05,$06,$18                DC.B $02,$96,$09,$05,$82,$01,$00,$50                DC.B $08,$04,$06,$1A,$02,$82,$09,$04                DC.B $82,$01,$00,$5A,$08,$03,$06,$1C                DC.B $02,$8C,$09,$03,$82,$01,$00,$46                DC.B $08,$02,$06,$1E,$02,$78,$09,$02                DC.B $82,$01,$00,$50,$08,$01,$06,$1F                DC.B $02,$82,$09,$01,$82,$01,$08,$00                DC.B $09,$00,$82,$00sound_2:        DC.B $07,$36,$08,$10,$00,$FF,$01,$0F                DC.B $06,$1F,$0B,$00,$0C,$10,$0D,$00                DC.B $82,$00loosershape_img:DC.B $80,$00,$40,$00,$E0,$01,$C0,$00 ;die Zunge beim Verlierer                DC.B $FF,$7F,$C0,$00,$FF,$7F,$80,$00                DC.B $7F,$FF,$00,$00,$3F,$FF,$00,$00                DC.B $1F,$FE,$00,$00,$0F,$F8,$00,$00                DC.B $03,$E0,$00,$00,$00,$00,$00,$00                DS.W 16blinzshape_img: DC.B $80,$02,$C0,$06,$60,$0C,$BF,$FA ;Blinzeln des Gewinners                DC.B $2A,$A8,$0A,$A0,$00,$00,$00,$00                DS.W 4lose_anim:      DC.W 0,1,2,3,3                DC.W 2,1,0,19                DC.W 18,17,17,18                DC.W 19,0,1,2                DC.W 3,3,2,1,0                DC.W 19,18,17,17                DC.W 18,19,0winner_anim:    DC.W 0,0,0                DC.W 19,19,18,17                DC.W 16,15,14,13                DC.W 12,11,10,10                DC.W 10,10,10,10                DC.W 9,8,7,6                DC.W 5,4,3,2                DC.W 1,0crossedsmil_img:DC.B $03,$F0,$00,$00,$0F,$FC,$00,$00 ;durchgekreuzter Smily                DC.B $3E,$1F,$00,$00,$70,$07,$80,$00 ;in der Scoreanzeige                DC.B $60,$0D,$80,$00,$C0,$18,$C0,$00                DC.B $C0,$70,$C0,$00,$C0,$E0,$C0,$00                DC.B $C1,$C0,$C0,$00,$C3,$80,$C0,$00                DC.B $63,$01,$80,$00,$7E,$03,$80,$00                DC.B $3C,$0F,$00,$00,$0F,$FC,$00,$00                DC.B $03,$F0,$00,$00,$00,$00,$00,$00                DS.W 28mapsmily_img:   DC.B $70,$00,$F8,$00,$F8,$00,$F8,$00                DC.B $70,$00,$00,$00,$00,$00,$00,$00                DS.W 2mapsmily2_img:  DS.W 1                DC.B $50,$00,$00,$00,$70,$00,$00,$00                DS.W 6midimaze_maz:   DC.B 'MIDIMAZE.MZE',0read_error:     DC.B 'Error reading maze file',0mze_err_text1:  DC.B 'Incompatible maze file version',0cant_open_error:DC.B 'Can''t open "',0cant_opn2_error:DC.B '"',0sending_str:    DC.B 'Sending',0receiving_str:  DC.B 'Receiving',0mouse_on:       DC.B 'Mouse control selected',0joystick_on:    DC.B 'Joystick control selected',0midi_booboo:    DC.B 'MIDI ring boo-boo',0too_many:       DC.B 'Too many machines on-line!',0no_maze:        DC.B 'Please load a maze first',0time_out:       DC.B 'The MIDI ring has timed out',0maze_too_small: DC.B 'Guru bu-bu: (maze too small?)',0quit_alert:     DC.B 'Do you really wanna quit?',0wrong_rez:      DC.B 'Please run in LOW resolution or HIGH res',0suspended:      DC.B 'Game suspended. Continue?',0terminated:     DC.B 'Game terminated',0suspended_slave:DC.B 'Game suspended',0slave_text:     DC.B 'Slave active',0master_text:    DC.B 'Master active',0solo_text:      DC.B 'Solo active',0info_text:      DC.B "ä-soft's MIDI-MAZE II V1.5",0your_team_win:  DC.B 'Your team wins!',0your_team_lose: DC.B 'Your team loses!',0you_win:        DC.B 'You win!',0wins:           DC.B ' wins!',0waiting:        DC.B 'Waiting for names',0all_names:      DC.B 'Names completed',0edit_page1:     DC.B 27,'E',9,'Masterpage-Editor:',13,10,9,'ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ',13,10,9edit_page2:     DC.B '??? Player? online.',13,10                DC.B '  Name',9,9,9,9,'  Win TLFGV Z'                DC.B 'iwhfas7qrdngb8435 0~6129#k<>c'                DC.B 13,10,0default_name:   DC.B 'Noname',0name_text:      DC.B 27,'Y8 ?:',0load_text:      DC.B 'LOAD MAZE',0                EVENlzs_file:       IBYTES 'MIDIMAZE.LZS'                EVEN                BSSlast_time:      DS.L 1random_base:    DS.L 1init_joy_flag:  DS.B 1init_mouse_flag:DS.B 1joystick_flag:  DS.W 1calc_tab:       DS.W 2*153table_size:     DS.W 1table_list:     DS.W 40draw_elem_count:DS.W 1screen_offs_adr:DS.L 1          ;Hier beginnt der Arbeitsbereich des Screensscore_table:    DS.W 16player_joy_table:DS.W 16team_flag:      DS.W 1          ;<>0 => Spiel mit Teamsmaze_size:      DS.W 1color_cnv_back: DS.W 16         ;Umrechnung von Spielernummer in Spielerfarbeset_shape_tab3: DS.B 1504reload_time:    DS.W 1var_richtung:   DS.W 1set_shape_tab5: DS.W 24         ;Spritenummer gemŠ§ der Blickrichtung (das Gesicht)set_shape_tab1: DS.W 24sinus_table:    DS.L 1refresh_time:   DS.W 1player_data:    DS.B ply_size*16player_data2:   DS.B ply_size*16player_data3:color_cnv_frame:DS.W 16         ;Farbumrechnungset_shape_tab6: DS.B 96akt_score:      DS.W 16screen_offset:  DS.W 1          ;aktueller Screen-Offsetcrossedsmil_ptr:DS.L 1live_shape_ptr: DS.L 1screen_rez:     DS.W 1          ;XBIOS(4)blinzshape_ptr: DS.L 1var_y_koord:    DS.W 1var_x_koord:    DS.W 1mapsmily2_ptr:  DS.L 1set_shape_tab2: DS.B 48mouse_button:   DS.W 1mouse_dx:       DS.W 1mouse_dy:       DS.W 1_random_seed:   DS.W 1screen_flag:    DS.W 1          ;aktuelle Grafikseiteall_players:    DS.W 1word_per_line:  DS.W 1regen_time:     DS.W 1mapsmily_ptr:   DS.L 1ikbd_base:      DS.L 1own_number:     DS.W 1machines_online:DS.W 1shape_ptr:      DS.L 1main_wind_off:  DS.W 1live_wind_off:  DS.W 1pscore_wind_off:DS.W 1no_color:       DS.W 1maus_or_joy:    DS.B 1joystick:       DS.B 1maze_name:      DS.B 41         ;max.40 Zeichenmaze_designer:  DS.B 41         ;max.40 Zeichenredraw_karte:   DS.B 1          ;<>0 => Karte neu zeichnen                EVENlast_date:      DS.W 4object_datas:   DS.B 32000maze_datas:     DS.B 4096       ;Daten des aktuellen Mazessave_mousevec:  DS.L 1save_joyvec:    DS.L 1team_scores:    DS.W t_anzrevive_lives:   DS.W 1loosershape_ptr:DS.L 1objekt_anz:     DS.W 1shape_face_ptr: DS.L 1          ;Zeiger auf die Shapes fŸr das Gesichtwindow_height:  DS.W 1          ;Hšhe des Windows in «-Pixeln (s/w: 100)set_shape_tab4: DS.B 48window_width:   DS.W 1          ;Breite des Windows in «-Pixeln (s/w: 160)mouse_dy2:      DS.W 1screen_1:       DS.L 1          ;zwei Bildschirmseitenscreen_2:       DS.L 1maze_filename:  DS.B 14save_midi:      DS.W 5timeout:        DS.L 1save_colors:    DS.W 16         ;gerettete Farbpalettemaze_loaded_flag:DS.W 1control:        DS.W 16global:         DS.W 15int_in:         DS.W 16int_out:        DS.W 7addr_in:        DS.L 2addr_out:       DS.L 1buffer:         DS.B 80draw_elem_list: DS.B 12*max_elementshacker_flag:    DS.W 1          ;=1 => ein Hacker war unterwegs (aber nicht lange...)mult_tab_160:   DS.W 256        ;160er Multiplikationstabellemult_tab_80:    DS.W 400        ;80er Multiplikationstabelleobj_clr_buffer: DS.W 16*4xy_speed_table: DS.W 256*2midi_buffer:    DS.B 8192maze_path:      DS.B 128maze_path2:     DS.B 128scr_buffer:     DS.B 40*200load_buffer1:   DS.B 130shape_face_data:DS.B 3172shape_img:      DS.B 130052*1convert_table:  DS.W 256        ;Farbe nach s/w-Umrechnungstabelle_object_datas:  DS.B 32000_maze_datas:    DS.B 4096       ;Daten des aktuellen Mazesscreen_buffer:  DS.B 32256save_page:      DS.B 32000allg_buffer:    DS.B 4096text_buf:       DS.B N+F-1      ;Ring-Buffer des Entpackers                EVENlzs_pnt:        DS.L 1          ;Pointer auf den nŠchsten lzs-Eintrag                END